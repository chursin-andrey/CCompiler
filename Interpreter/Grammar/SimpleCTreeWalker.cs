//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 Grammar\\SimpleCTreeWalker.g 2015-10-11 22:15:09

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


#pragma warning disable 3021
using SimpleC.Tree;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  SimpleC.Grammar 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class SimpleCTreeWalker : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "ASSIGN", "BIT_AND", "BIT_NOT", "BIT_OR", "BIT_XOR", "BOOL_AND", "BOOL_NOT", "BOOL_OR", "CHAR", "CHARACTER_LITERAL", "Char", "DEC_POST", "DEC_PRE", "DEREF", "DIV", "DO", "ELSE", "EQUAL", "EXPRESSION", "FALSE", "FOR", "FUNC_BODY", "FUNC_CALL", "FUNC_DECL", "FUNC_DEF", "GREATER", "GREATER_OR_EQUAL", "IDENT", "IF", "INCLUDE", "INCLUDE_STRING", "INC_POST", "INC_PRE", "INTEGER", "Identifier", "Int", "Integer", "LESS", "LESS_OR_EQUAL", "LINE_COMMENT", "ML_COMMENT", "MOD", "MUL", "NOT_EQUAL", "PARAM_LIST", "PARAM_SPEC_LIST", "PROGRAM", "REF", "RETURN", "SHIFT_LEFT", "SHIFT_RIGHT", "SIZEOF_EXPR", "SIZEOF_TYPE", "STATEMENT", "STRING", "STRING_LITERAL", "STRUCT_DEREF", "STRUCT_MEMBER", "SUB", "SUBSCRIPT", "SizeOf", "String", "TRUE", "TYPECAST", "TYPE_SPEC", "U_MINUS", "U_PLUS", "VAR_CALL", "VAR_DECL", "VAR_DEF", "VAR_SPEC", "VOID", "Void", "WHILE", "Whitespace", "'!'", "'#include'", "'('", "')'", "'++'", "','", "'--'", "'->'", "'.'", "';'", "'['", "']'", "'{'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int ADD=4;
	public const int ASSIGN=5;
	public const int BIT_AND=6;
	public const int BIT_NOT=7;
	public const int BIT_OR=8;
	public const int BIT_XOR=9;
	public const int BOOL_AND=10;
	public const int BOOL_NOT=11;
	public const int BOOL_OR=12;
	public const int CHAR=13;
	public const int CHARACTER_LITERAL=14;
	public const int Char=15;
	public const int DEC_POST=16;
	public const int DEC_PRE=17;
	public const int DEREF=18;
	public const int DIV=19;
	public const int DO=20;
	public const int ELSE=21;
	public const int EQUAL=22;
	public const int EXPRESSION=23;
	public const int FALSE=24;
	public const int FOR=25;
	public const int FUNC_BODY=26;
	public const int FUNC_CALL=27;
	public const int FUNC_DECL=28;
	public const int FUNC_DEF=29;
	public const int GREATER=30;
	public const int GREATER_OR_EQUAL=31;
	public const int IDENT=32;
	public const int IF=33;
	public const int INCLUDE=34;
	public const int INCLUDE_STRING=35;
	public const int INC_POST=36;
	public const int INC_PRE=37;
	public const int INTEGER=38;
	public const int Identifier=39;
	public const int Int=40;
	public const int Integer=41;
	public const int LESS=42;
	public const int LESS_OR_EQUAL=43;
	public const int LINE_COMMENT=44;
	public const int ML_COMMENT=45;
	public const int MOD=46;
	public const int MUL=47;
	public const int NOT_EQUAL=48;
	public const int PARAM_LIST=49;
	public const int PARAM_SPEC_LIST=50;
	public const int PROGRAM=51;
	public const int REF=52;
	public const int RETURN=53;
	public const int SHIFT_LEFT=54;
	public const int SHIFT_RIGHT=55;
	public const int SIZEOF_EXPR=56;
	public const int SIZEOF_TYPE=57;
	public const int STATEMENT=58;
	public const int STRING=59;
	public const int STRING_LITERAL=60;
	public const int STRUCT_DEREF=61;
	public const int STRUCT_MEMBER=62;
	public const int SUB=63;
	public const int SUBSCRIPT=64;
	public const int SizeOf=65;
	public const int String=66;
	public const int TRUE=67;
	public const int TYPECAST=68;
	public const int TYPE_SPEC=69;
	public const int U_MINUS=70;
	public const int U_PLUS=71;
	public const int VAR_CALL=72;
	public const int VAR_DECL=73;
	public const int VAR_DEF=74;
	public const int VAR_SPEC=75;
	public const int VOID=76;
	public const int Void=77;
	public const int WHILE=78;
	public const int Whitespace=79;

	public SimpleCTreeWalker(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public SimpleCTreeWalker(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return SimpleCTreeWalker.tokenNames; } }
	public override string GrammarFileName { get { return "Grammar\\SimpleCTreeWalker.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_walk();
	partial void LeaveRule_walk();

	// $ANTLR start "walk"
	// Grammar\\SimpleCTreeWalker.g:17:1: public walk returns [RootNode node] : ^( PROGRAM ( programStatement )* ) ;
	[GrammarRule("walk")]
	public RootNode walk()
	{
		EnterRule_walk();
		EnterRule("walk", 1);
		TraceIn("walk", 1);
		RootNode node = default(RootNode);


		ISCNode programStatement1 = default(ISCNode);


			node = new RootNode();

		try { DebugEnterRule(GrammarFileName, "walk");
		DebugLocation(17, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:20:3: ( ^( PROGRAM ( programStatement )* ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:22:2: ^( PROGRAM ( programStatement )* )
			{
			DebugLocation(22, 2);
			DebugLocation(22, 4);
			Match(input,PROGRAM,Follow._PROGRAM_in_walk61); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(22, 12);
				// Grammar\\SimpleCTreeWalker.g:22:12: ( programStatement )*
				try { DebugEnterSubRule(1);
				while (true)
				{
					int alt1=2;
					try { DebugEnterDecision(1, false);
					int LA1_0 = input.LA(1);

					if (((LA1_0>=FUNC_DECL && LA1_0<=FUNC_DEF)||LA1_0==VAR_DEF))
					{
						alt1 = 1;
					}


					} finally { DebugExitDecision(1); }
					switch ( alt1 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:22:13: programStatement
						{
						DebugLocation(22, 13);
						PushFollow(Follow._programStatement_in_walk64);
						programStatement1=programStatement();
						PopFollow();

						DebugLocation(22, 30);
						 node.Children.Add(programStatement1); 

						}
						break;

					default:
						goto loop1;
					}
				}

				loop1:
					;

				} finally { DebugExitSubRule(1); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("walk", 1);
			LeaveRule("walk", 1);
			LeaveRule_walk();
		}
		DebugLocation(23, 0);
		} finally { DebugExitRule(GrammarFileName, "walk"); }
		return node;

	}
	// $ANTLR end "walk"

	partial void EnterRule_programStatement();
	partial void LeaveRule_programStatement();

	// $ANTLR start "programStatement"
	// Grammar\\SimpleCTreeWalker.g:25:1: programStatement returns [ISCNode node] : ( varDef | funcDecl | funcDef );
	[GrammarRule("programStatement")]
	private ISCNode programStatement()
	{
		EnterRule_programStatement();
		EnterRule("programStatement", 2);
		TraceIn("programStatement", 2);
		ISCNode node = default(ISCNode);


		VarDefNode varDef2 = default(VarDefNode);
		FuncDeclNode funcDecl3 = default(FuncDeclNode);
		FuncDefNode funcDef4 = default(FuncDefNode);

		try { DebugEnterRule(GrammarFileName, "programStatement");
		DebugLocation(25, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:26:2: ( varDef | funcDecl | funcDef )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case VAR_DEF:
				{
				alt2 = 1;
				}
				break;
			case FUNC_DECL:
				{
				alt2 = 2;
				}
				break;
			case FUNC_DEF:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleCTreeWalker.g:26:4: varDef
				{
				DebugLocation(26, 4);
				PushFollow(Follow._varDef_in_programStatement83);
				varDef2=varDef();
				PopFollow();

				DebugLocation(26, 11);
				 node = varDef2; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleCTreeWalker.g:27:4: funcDecl
				{
				DebugLocation(27, 4);
				PushFollow(Follow._funcDecl_in_programStatement90);
				funcDecl3=funcDecl();
				PopFollow();

				DebugLocation(27, 13);

						FuncDeclNode funcDeclNode = funcDecl3;
						node = funcDeclNode; 
						FuncDeclsContainer.Add(funcDeclNode);
					

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleCTreeWalker.g:32:4: funcDef
				{
				DebugLocation(32, 4);
				PushFollow(Follow._funcDef_in_programStatement97);
				funcDef4=funcDef();
				PopFollow();

				DebugLocation(32, 12);
					
						FuncDefNode funcDefNode = funcDef4;
						node = funcDefNode; 
						FuncDeclsContainer.Add(funcDefNode);
					

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("programStatement", 2);
			LeaveRule("programStatement", 2);
			LeaveRule_programStatement();
		}
		DebugLocation(43, 0);
		} finally { DebugExitRule(GrammarFileName, "programStatement"); }
		return node;

	}
	// $ANTLR end "programStatement"

	partial void EnterRule_varDef();
	partial void LeaveRule_varDef();

	// $ANTLR start "varDef"
	// Grammar\\SimpleCTreeWalker.g:45:1: varDef returns [VarDefNode node] : ^( VAR_DEF varSpec ) ;
	[GrammarRule("varDef")]
	private VarDefNode varDef()
	{
		EnterRule_varDef();
		EnterRule("varDef", 3);
		TraceIn("varDef", 3);
		VarDefNode node = default(VarDefNode);


		VarSpecNode varSpec5 = default(VarSpecNode);

		try { DebugEnterRule(GrammarFileName, "varDef");
		DebugLocation(45, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:45:33: ( ^( VAR_DEF varSpec ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:46:2: ^( VAR_DEF varSpec )
			{
			DebugLocation(46, 2);
			DebugLocation(46, 4);
			Match(input,VAR_DEF,Follow._VAR_DEF_in_varDef116); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(46, 12);
			PushFollow(Follow._varSpec_in_varDef118);
			varSpec5=varSpec();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(46, 21);
			 node = new VarDefNode(varSpec5); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("varDef", 3);
			LeaveRule("varDef", 3);
			LeaveRule_varDef();
		}
		DebugLocation(47, 0);
		} finally { DebugExitRule(GrammarFileName, "varDef"); }
		return node;

	}
	// $ANTLR end "varDef"

	partial void EnterRule_funcDecl();
	partial void LeaveRule_funcDecl();

	// $ANTLR start "funcDecl"
	// Grammar\\SimpleCTreeWalker.g:49:1: funcDecl returns [FuncDeclNode node] : ^( FUNC_DECL typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) ) ;
	[GrammarRule("funcDecl")]
	private FuncDeclNode funcDecl()
	{
		EnterRule_funcDecl();
		EnterRule("funcDecl", 4);
		TraceIn("funcDecl", 4);
		FuncDeclNode node = default(FuncDeclNode);


		CommonTree IDENT7 = default(CommonTree);
		TypeSpecNode typeSpec6 = default(TypeSpecNode);
		VarSpecNode varSpec8 = default(VarSpecNode);


			node = new FuncDeclNode();

		try { DebugEnterRule(GrammarFileName, "funcDecl");
		DebugLocation(49, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:52:3: ( ^( FUNC_DECL typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:53:2: ^( FUNC_DECL typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) )
			{
			DebugLocation(53, 2);
			DebugLocation(53, 4);
			Match(input,FUNC_DECL,Follow._FUNC_DECL_in_funcDecl141); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(54, 3);
			PushFollow(Follow._typeSpec_in_funcDecl146);
			typeSpec6=typeSpec();
			PopFollow();

			DebugLocation(54, 12);
			 node.ReturnTypeSpec = typeSpec6; 
			DebugLocation(55, 3);
			IDENT7=(CommonTree)Match(input,IDENT,Follow._IDENT_in_funcDecl153); 
			DebugLocation(55, 9);
			 node.Name = IDENT7.Text; 
			DebugLocation(56, 3);
			DebugLocation(56, 5);
			Match(input,PARAM_SPEC_LIST,Follow._PARAM_SPEC_LIST_in_funcDecl160); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(56, 21);
				// Grammar\\SimpleCTreeWalker.g:56:21: ( varSpec )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_0 = input.LA(1);

					if ((LA3_0==VAR_SPEC))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:56:22: varSpec
						{
						DebugLocation(56, 22);
						PushFollow(Follow._varSpec_in_funcDecl163);
						varSpec8=varSpec();
						PopFollow();

						DebugLocation(56, 30);
						 node.Parameters.Add(varSpec8); 

						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }


				Match(input, TokenTypes.Up, null); 
			}


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcDecl", 4);
			LeaveRule("funcDecl", 4);
			LeaveRule_funcDecl();
		}
		DebugLocation(58, 0);
		} finally { DebugExitRule(GrammarFileName, "funcDecl"); }
		return node;

	}
	// $ANTLR end "funcDecl"

	partial void EnterRule_macroDecl();
	partial void LeaveRule_macroDecl();

	// $ANTLR start "macroDecl"
	// Grammar\\SimpleCTreeWalker.g:60:1: macroDecl returns [FuncDeclNode node] : ^( FUNC_DECL typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) ) ;
	[GrammarRule("macroDecl")]
	private FuncDeclNode macroDecl()
	{
		EnterRule_macroDecl();
		EnterRule("macroDecl", 5);
		TraceIn("macroDecl", 5);
		FuncDeclNode node = default(FuncDeclNode);


		CommonTree IDENT10 = default(CommonTree);
		TypeSpecNode typeSpec9 = default(TypeSpecNode);
		VarSpecNode varSpec11 = default(VarSpecNode);


			node = new FuncDeclNode();

		try { DebugEnterRule(GrammarFileName, "macroDecl");
		DebugLocation(60, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:63:3: ( ^( FUNC_DECL typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:64:2: ^( FUNC_DECL typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) )
			{
			DebugLocation(64, 2);
			DebugLocation(64, 4);
			Match(input,FUNC_DECL,Follow._FUNC_DECL_in_macroDecl191); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(65, 3);
			PushFollow(Follow._typeSpec_in_macroDecl196);
			typeSpec9=typeSpec();
			PopFollow();

			DebugLocation(65, 12);
			 node.ReturnTypeSpec = typeSpec9; 
			DebugLocation(66, 3);
			IDENT10=(CommonTree)Match(input,IDENT,Follow._IDENT_in_macroDecl203); 
			DebugLocation(66, 9);
			 node.Name = IDENT10.Text; 
			DebugLocation(67, 3);
			DebugLocation(67, 5);
			Match(input,PARAM_SPEC_LIST,Follow._PARAM_SPEC_LIST_in_macroDecl210); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(67, 21);
				// Grammar\\SimpleCTreeWalker.g:67:21: ( varSpec )*
				try { DebugEnterSubRule(4);
				while (true)
				{
					int alt4=2;
					try { DebugEnterDecision(4, false);
					int LA4_0 = input.LA(1);

					if ((LA4_0==VAR_SPEC))
					{
						alt4 = 1;
					}


					} finally { DebugExitDecision(4); }
					switch ( alt4 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:67:22: varSpec
						{
						DebugLocation(67, 22);
						PushFollow(Follow._varSpec_in_macroDecl213);
						varSpec11=varSpec();
						PopFollow();

						DebugLocation(67, 30);
						 node.Parameters.Add(varSpec11); 

						}
						break;

					default:
						goto loop4;
					}
				}

				loop4:
					;

				} finally { DebugExitSubRule(4); }


				Match(input, TokenTypes.Up, null); 
			}


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("macroDecl", 5);
			LeaveRule("macroDecl", 5);
			LeaveRule_macroDecl();
		}
		DebugLocation(69, 0);
		} finally { DebugExitRule(GrammarFileName, "macroDecl"); }
		return node;

	}
	// $ANTLR end "macroDecl"

	partial void EnterRule_funcDef();
	partial void LeaveRule_funcDef();

	// $ANTLR start "funcDef"
	// Grammar\\SimpleCTreeWalker.g:71:1: funcDef returns [FuncDefNode node] : ^( FUNC_DEF typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) funcBody ) ;
	[GrammarRule("funcDef")]
	private FuncDefNode funcDef()
	{
		EnterRule_funcDef();
		EnterRule("funcDef", 6);
		TraceIn("funcDef", 6);
		FuncDefNode node = default(FuncDefNode);


		CommonTree IDENT13 = default(CommonTree);
		TypeSpecNode typeSpec12 = default(TypeSpecNode);
		VarSpecNode varSpec14 = default(VarSpecNode);
		CompoundStatementNode funcBody15 = default(CompoundStatementNode);


			node = new FuncDefNode();

		try { DebugEnterRule(GrammarFileName, "funcDef");
		DebugLocation(71, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:74:3: ( ^( FUNC_DEF typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) funcBody ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:75:2: ^( FUNC_DEF typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) funcBody )
			{
			DebugLocation(75, 2);
			DebugLocation(75, 4);
			Match(input,FUNC_DEF,Follow._FUNC_DEF_in_funcDef241); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(76, 3);
			PushFollow(Follow._typeSpec_in_funcDef246);
			typeSpec12=typeSpec();
			PopFollow();

			DebugLocation(76, 12);
			 node.ReturnTypeSpec = typeSpec12; 
			DebugLocation(77, 3);
			IDENT13=(CommonTree)Match(input,IDENT,Follow._IDENT_in_funcDef252); 
			DebugLocation(77, 9);
			 node.Name = IDENT13.Text; 
			DebugLocation(78, 3);
			DebugLocation(78, 5);
			Match(input,PARAM_SPEC_LIST,Follow._PARAM_SPEC_LIST_in_funcDef259); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(78, 21);
				// Grammar\\SimpleCTreeWalker.g:78:21: ( varSpec )*
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0==VAR_SPEC))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch ( alt5 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:78:22: varSpec
						{
						DebugLocation(78, 22);
						PushFollow(Follow._varSpec_in_funcDef262);
						varSpec14=varSpec();
						PopFollow();

						DebugLocation(78, 30);
						 node.Parameters.Add(varSpec14); 

						}
						break;

					default:
						goto loop5;
					}
				}

				loop5:
					;

				} finally { DebugExitSubRule(5); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(79, 3);
			PushFollow(Follow._funcBody_in_funcDef272);
			funcBody15=funcBody();
			PopFollow();

			DebugLocation(79, 12);
			 node.Body = funcBody15; 

			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcDef", 6);
			LeaveRule("funcDef", 6);
			LeaveRule_funcDef();
		}
		DebugLocation(80, 0);
		} finally { DebugExitRule(GrammarFileName, "funcDef"); }
		return node;

	}
	// $ANTLR end "funcDef"

	partial void EnterRule_varSpec();
	partial void LeaveRule_varSpec();

	// $ANTLR start "varSpec"
	// Grammar\\SimpleCTreeWalker.g:82:1: varSpec returns [VarSpecNode node] : ^( VAR_SPEC typeSpec IDENT ) ;
	[GrammarRule("varSpec")]
	private VarSpecNode varSpec()
	{
		EnterRule_varSpec();
		EnterRule("varSpec", 7);
		TraceIn("varSpec", 7);
		VarSpecNode node = default(VarSpecNode);


		CommonTree IDENT17 = default(CommonTree);
		TypeSpecNode typeSpec16 = default(TypeSpecNode);


			node = new VarSpecNode();

		try { DebugEnterRule(GrammarFileName, "varSpec");
		DebugLocation(82, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:85:3: ( ^( VAR_SPEC typeSpec IDENT ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:86:2: ^( VAR_SPEC typeSpec IDENT )
			{
			DebugLocation(86, 2);
			DebugLocation(86, 4);
			Match(input,VAR_SPEC,Follow._VAR_SPEC_in_varSpec295); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(86, 13);
			PushFollow(Follow._typeSpec_in_varSpec297);
			typeSpec16=typeSpec();
			PopFollow();

			DebugLocation(86, 22);
			IDENT17=(CommonTree)Match(input,IDENT,Follow._IDENT_in_varSpec299); 

			Match(input, TokenTypes.Up, null); 

			DebugLocation(86, 29);
			 
					node.TypeSpec = typeSpec16; 
					node.Name = IDENT17.Text;
				

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("varSpec", 7);
			LeaveRule("varSpec", 7);
			LeaveRule_varSpec();
		}
		DebugLocation(90, 0);
		} finally { DebugExitRule(GrammarFileName, "varSpec"); }
		return node;

	}
	// $ANTLR end "varSpec"

	partial void EnterRule_typeSpec();
	partial void LeaveRule_typeSpec();

	// $ANTLR start "typeSpec"
	// Grammar\\SimpleCTreeWalker.g:92:1: typeSpec returns [TypeSpecNode node] : ^( TYPE_SPEC IDENT ) ;
	[GrammarRule("typeSpec")]
	private TypeSpecNode typeSpec()
	{
		EnterRule_typeSpec();
		EnterRule("typeSpec", 8);
		TraceIn("typeSpec", 8);
		TypeSpecNode node = default(TypeSpecNode);


		CommonTree IDENT18 = default(CommonTree);


			node = new TypeSpecNode();

		try { DebugEnterRule(GrammarFileName, "typeSpec");
		DebugLocation(92, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:95:3: ( ^( TYPE_SPEC IDENT ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:96:2: ^( TYPE_SPEC IDENT )
			{
			DebugLocation(96, 2);
			DebugLocation(96, 4);
			Match(input,TYPE_SPEC,Follow._TYPE_SPEC_in_typeSpec322); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(96, 14);
			IDENT18=(CommonTree)Match(input,IDENT,Follow._IDENT_in_typeSpec324); 

			Match(input, TokenTypes.Up, null); 

			DebugLocation(96, 21);
			 
					node.PrimaryTypeName = IDENT18.Text; 
				

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeSpec", 8);
			LeaveRule("typeSpec", 8);
			LeaveRule_typeSpec();
		}
		DebugLocation(99, 0);
		} finally { DebugExitRule(GrammarFileName, "typeSpec"); }
		return node;

	}
	// $ANTLR end "typeSpec"

	partial void EnterRule_funcBody();
	partial void LeaveRule_funcBody();

	// $ANTLR start "funcBody"
	// Grammar\\SimpleCTreeWalker.g:101:1: funcBody returns [CompoundStatementNode node] : ^( FUNC_BODY ( statement )* ) ;
	[GrammarRule("funcBody")]
	private CompoundStatementNode funcBody()
	{
		EnterRule_funcBody();
		EnterRule("funcBody", 9);
		TraceIn("funcBody", 9);
		CompoundStatementNode node = default(CompoundStatementNode);


		ISCNode statement19 = default(ISCNode);


			node = new CompoundStatementNode();

		try { DebugEnterRule(GrammarFileName, "funcBody");
		DebugLocation(101, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:104:3: ( ^( FUNC_BODY ( statement )* ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:105:2: ^( FUNC_BODY ( statement )* )
			{
			DebugLocation(105, 2);
			DebugLocation(105, 4);
			Match(input,FUNC_BODY,Follow._FUNC_BODY_in_funcBody347); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(105, 14);
				// Grammar\\SimpleCTreeWalker.g:105:14: ( statement )*
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=2;
					try { DebugEnterDecision(6, false);
					int LA6_0 = input.LA(1);

					if ((LA6_0==STATEMENT||LA6_0==VAR_DEF))
					{
						alt6 = 1;
					}


					} finally { DebugExitDecision(6); }
					switch ( alt6 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:105:15: statement
						{
						DebugLocation(105, 15);
						PushFollow(Follow._statement_in_funcBody350);
						statement19=statement();
						PopFollow();

						DebugLocation(105, 25);
						 node.Statements.Add(statement19); 

						}
						break;

					default:
						goto loop6;
					}
				}

				loop6:
					;

				} finally { DebugExitSubRule(6); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcBody", 9);
			LeaveRule("funcBody", 9);
			LeaveRule_funcBody();
		}
		DebugLocation(106, 0);
		} finally { DebugExitRule(GrammarFileName, "funcBody"); }
		return node;

	}
	// $ANTLR end "funcBody"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// Grammar\\SimpleCTreeWalker.g:108:1: statement returns [ISCNode node] : ( varDef | STATEMENT | ^( STATEMENT expression ) | ^( STATEMENT (st= statement )+ ) );
	[GrammarRule("statement")]
	private ISCNode statement()
	{
		EnterRule_statement();
		EnterRule("statement", 10);
		TraceIn("statement", 10);
		ISCNode node = default(ISCNode);


		ISCNode st = default(ISCNode);
		VarDefNode varDef20 = default(VarDefNode);
		IExprNode expression21 = default(IExprNode);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(108, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:108:33: ( varDef | STATEMENT | ^( STATEMENT expression ) | ^( STATEMENT (st= statement )+ ) )
			int alt8=4;
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==VAR_DEF))
			{
				alt8 = 1;
			}
			else if ((LA8_0==STATEMENT))
			{
				int LA8_2 = input.LA(2);

				if ((LA8_2==DOWN))
				{
					int LA8_3 = input.LA(3);

					if (((LA8_3>=ADD && LA8_3<=BIT_AND)||(LA8_3>=BIT_OR && LA8_3<=BOOL_AND)||LA8_3==BOOL_OR||LA8_3==DIV||LA8_3==EQUAL||LA8_3==FUNC_CALL||(LA8_3>=GREATER && LA8_3<=IDENT)||LA8_3==INTEGER||(LA8_3>=LESS && LA8_3<=LESS_OR_EQUAL)||(LA8_3>=MOD && LA8_3<=NOT_EQUAL)||(LA8_3>=SHIFT_LEFT && LA8_3<=SHIFT_RIGHT)||LA8_3==STRING||LA8_3==SUB))
					{
						alt8 = 3;
					}
					else if ((LA8_3==STATEMENT||LA8_3==VAR_DEF))
					{
						alt8 = 4;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 8, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA8_2==UP||LA8_2==STATEMENT||LA8_2==VAR_DEF))
				{
					alt8 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 8, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleCTreeWalker.g:109:2: varDef
				{
				DebugLocation(109, 2);
				PushFollow(Follow._varDef_in_statement368);
				varDef20=varDef();
				PopFollow();

				DebugLocation(109, 9);
				 node = varDef20; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleCTreeWalker.g:110:4: STATEMENT
				{
				DebugLocation(110, 4);
				Match(input,STATEMENT,Follow._STATEMENT_in_statement375); 
				DebugLocation(110, 14);
				 node = new CompoundStatementNode(); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleCTreeWalker.g:111:4: ^( STATEMENT expression )
				{
				DebugLocation(111, 4);
				DebugLocation(111, 6);
				Match(input,STATEMENT,Follow._STATEMENT_in_statement384); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(111, 16);
				PushFollow(Follow._expression_in_statement386);
				expression21=expression();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(111, 28);
				 node = expression21; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleCTreeWalker.g:112:4: ^( STATEMENT (st= statement )+ )
				{
				DebugLocation(112, 4);
				DebugLocation(112, 6);
				Match(input,STATEMENT,Follow._STATEMENT_in_statement395); 

				DebugLocation(112, 16);
				 
						node = new CompoundStatementNode(); 
						CompoundStatementNode compoundNode = (CompoundStatementNode)node; 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(115, 5);
				// Grammar\\SimpleCTreeWalker.g:115:5: (st= statement )+
				int cnt7=0;
				try { DebugEnterSubRule(7);
				while (true)
				{
					int alt7=2;
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==STATEMENT||LA7_0==VAR_DEF))
					{
						alt7 = 1;
					}


					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:115:6: st= statement
						{
						DebugLocation(115, 8);
						PushFollow(Follow._statement_in_statement407);
						st=statement();
						PopFollow();

						DebugLocation(115, 19);
						 compoundNode.Statements.Add(st); 

						}
						break;

					default:
						if (cnt7 >= 1)
							goto loop7;

						EarlyExitException eee7 = new EarlyExitException( 7, input );
						DebugRecognitionException(eee7);
						throw eee7;
					}
					cnt7++;
				}
				loop7:
					;

				} finally { DebugExitSubRule(7); }


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 10);
			LeaveRule("statement", 10);
			LeaveRule_statement();
		}
		DebugLocation(116, 0);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return node;

	}
	// $ANTLR end "statement"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// Grammar\\SimpleCTreeWalker.g:118:1: expression returns [IExprNode node] : ( ( ^(type= ADD left= expression right= expression ) | ^(type= SUB left= expression right= expression ) | ^(type= MUL left= expression right= expression ) | ^(type= DIV left= expression right= expression ) | ^(type= MOD left= expression right= expression ) | ^(type= SHIFT_LEFT left= expression right= expression ) | ^(type= SHIFT_RIGHT left= expression right= expression ) | ^(type= ASSIGN left= expression right= expression ) | ^(type= GREATER left= expression right= expression ) | ^(type= GREATER_OR_EQUAL left= expression right= expression ) | ^(type= LESS left= expression right= expression ) | ^(type= LESS_OR_EQUAL left= expression right= expression ) | ^(type= EQUAL left= expression right= expression ) | ^(type= NOT_EQUAL left= expression right= expression ) | ^(type= BOOL_AND left= expression right= expression ) | ^(type= BOOL_OR left= expression right= expression ) | ^(type= BIT_AND left= expression right= expression ) | ^(type= BIT_OR left= expression right= expression ) | ^(type= BIT_XOR left= expression right= expression ) ) | IDENT | INTEGER | STRING | ^( FUNC_CALL IDENT ^( PARAM_LIST (parameter= expression )* ) ) );
	[GrammarRule("expression")]
	private IExprNode expression()
	{
		EnterRule_expression();
		EnterRule("expression", 11);
		TraceIn("expression", 11);
		IExprNode node = default(IExprNode);


		CommonTree type = default(CommonTree);
		CommonTree IDENT22 = default(CommonTree);
		CommonTree INTEGER23 = default(CommonTree);
		CommonTree STRING24 = default(CommonTree);
		CommonTree IDENT25 = default(CommonTree);
		IExprNode left = default(IExprNode);
		IExprNode right = default(IExprNode);
		IExprNode parameter = default(IExprNode);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(118, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:118:36: ( ( ^(type= ADD left= expression right= expression ) | ^(type= SUB left= expression right= expression ) | ^(type= MUL left= expression right= expression ) | ^(type= DIV left= expression right= expression ) | ^(type= MOD left= expression right= expression ) | ^(type= SHIFT_LEFT left= expression right= expression ) | ^(type= SHIFT_RIGHT left= expression right= expression ) | ^(type= ASSIGN left= expression right= expression ) | ^(type= GREATER left= expression right= expression ) | ^(type= GREATER_OR_EQUAL left= expression right= expression ) | ^(type= LESS left= expression right= expression ) | ^(type= LESS_OR_EQUAL left= expression right= expression ) | ^(type= EQUAL left= expression right= expression ) | ^(type= NOT_EQUAL left= expression right= expression ) | ^(type= BOOL_AND left= expression right= expression ) | ^(type= BOOL_OR left= expression right= expression ) | ^(type= BIT_AND left= expression right= expression ) | ^(type= BIT_OR left= expression right= expression ) | ^(type= BIT_XOR left= expression right= expression ) ) | IDENT | INTEGER | STRING | ^( FUNC_CALL IDENT ^( PARAM_LIST (parameter= expression )* ) ) )
			int alt11=5;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case ADD:
			case ASSIGN:
			case BIT_AND:
			case BIT_OR:
			case BIT_XOR:
			case BOOL_AND:
			case BOOL_OR:
			case DIV:
			case EQUAL:
			case GREATER:
			case GREATER_OR_EQUAL:
			case LESS:
			case LESS_OR_EQUAL:
			case MOD:
			case MUL:
			case NOT_EQUAL:
			case SHIFT_LEFT:
			case SHIFT_RIGHT:
			case SUB:
				{
				alt11 = 1;
				}
				break;
			case IDENT:
				{
				alt11 = 2;
				}
				break;
			case INTEGER:
				{
				alt11 = 3;
				}
				break;
			case STRING:
				{
				alt11 = 4;
				}
				break;
			case FUNC_CALL:
				{
				alt11 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleCTreeWalker.g:120:2: ( ^(type= ADD left= expression right= expression ) | ^(type= SUB left= expression right= expression ) | ^(type= MUL left= expression right= expression ) | ^(type= DIV left= expression right= expression ) | ^(type= MOD left= expression right= expression ) | ^(type= SHIFT_LEFT left= expression right= expression ) | ^(type= SHIFT_RIGHT left= expression right= expression ) | ^(type= ASSIGN left= expression right= expression ) | ^(type= GREATER left= expression right= expression ) | ^(type= GREATER_OR_EQUAL left= expression right= expression ) | ^(type= LESS left= expression right= expression ) | ^(type= LESS_OR_EQUAL left= expression right= expression ) | ^(type= EQUAL left= expression right= expression ) | ^(type= NOT_EQUAL left= expression right= expression ) | ^(type= BOOL_AND left= expression right= expression ) | ^(type= BOOL_OR left= expression right= expression ) | ^(type= BIT_AND left= expression right= expression ) | ^(type= BIT_OR left= expression right= expression ) | ^(type= BIT_XOR left= expression right= expression ) )
				{
				DebugLocation(120, 2);
				// Grammar\\SimpleCTreeWalker.g:120:2: ( ^(type= ADD left= expression right= expression ) | ^(type= SUB left= expression right= expression ) | ^(type= MUL left= expression right= expression ) | ^(type= DIV left= expression right= expression ) | ^(type= MOD left= expression right= expression ) | ^(type= SHIFT_LEFT left= expression right= expression ) | ^(type= SHIFT_RIGHT left= expression right= expression ) | ^(type= ASSIGN left= expression right= expression ) | ^(type= GREATER left= expression right= expression ) | ^(type= GREATER_OR_EQUAL left= expression right= expression ) | ^(type= LESS left= expression right= expression ) | ^(type= LESS_OR_EQUAL left= expression right= expression ) | ^(type= EQUAL left= expression right= expression ) | ^(type= NOT_EQUAL left= expression right= expression ) | ^(type= BOOL_AND left= expression right= expression ) | ^(type= BOOL_OR left= expression right= expression ) | ^(type= BIT_AND left= expression right= expression ) | ^(type= BIT_OR left= expression right= expression ) | ^(type= BIT_XOR left= expression right= expression ) )
				int alt9=19;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				switch (input.LA(1))
				{
				case ADD:
					{
					alt9 = 1;
					}
					break;
				case SUB:
					{
					alt9 = 2;
					}
					break;
				case MUL:
					{
					alt9 = 3;
					}
					break;
				case DIV:
					{
					alt9 = 4;
					}
					break;
				case MOD:
					{
					alt9 = 5;
					}
					break;
				case SHIFT_LEFT:
					{
					alt9 = 6;
					}
					break;
				case SHIFT_RIGHT:
					{
					alt9 = 7;
					}
					break;
				case ASSIGN:
					{
					alt9 = 8;
					}
					break;
				case GREATER:
					{
					alt9 = 9;
					}
					break;
				case GREATER_OR_EQUAL:
					{
					alt9 = 10;
					}
					break;
				case LESS:
					{
					alt9 = 11;
					}
					break;
				case LESS_OR_EQUAL:
					{
					alt9 = 12;
					}
					break;
				case EQUAL:
					{
					alt9 = 13;
					}
					break;
				case NOT_EQUAL:
					{
					alt9 = 14;
					}
					break;
				case BOOL_AND:
					{
					alt9 = 15;
					}
					break;
				case BOOL_OR:
					{
					alt9 = 16;
					}
					break;
				case BIT_AND:
					{
					alt9 = 17;
					}
					break;
				case BIT_OR:
					{
					alt9 = 18;
					}
					break;
				case BIT_XOR:
					{
					alt9 = 19;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleCTreeWalker.g:121:3: ^(type= ADD left= expression right= expression )
					{
					DebugLocation(121, 3);
					DebugLocation(121, 9);
					type=(CommonTree)Match(input,ADD,Follow._ADD_in_expression435); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(121, 18);
					PushFollow(Follow._expression_in_expression439);
					left=expression();
					PopFollow();

					DebugLocation(121, 35);
					PushFollow(Follow._expression_in_expression443);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammar\\SimpleCTreeWalker.g:122:5: ^(type= SUB left= expression right= expression )
					{
					DebugLocation(122, 5);
					DebugLocation(122, 11);
					type=(CommonTree)Match(input,SUB,Follow._SUB_in_expression453); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(122, 20);
					PushFollow(Follow._expression_in_expression457);
					left=expression();
					PopFollow();

					DebugLocation(122, 37);
					PushFollow(Follow._expression_in_expression461);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammar\\SimpleCTreeWalker.g:123:5: ^(type= MUL left= expression right= expression )
					{
					DebugLocation(123, 5);
					DebugLocation(123, 11);
					type=(CommonTree)Match(input,MUL,Follow._MUL_in_expression471); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(123, 20);
					PushFollow(Follow._expression_in_expression475);
					left=expression();
					PopFollow();

					DebugLocation(123, 37);
					PushFollow(Follow._expression_in_expression479);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Grammar\\SimpleCTreeWalker.g:124:5: ^(type= DIV left= expression right= expression )
					{
					DebugLocation(124, 5);
					DebugLocation(124, 11);
					type=(CommonTree)Match(input,DIV,Follow._DIV_in_expression489); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(124, 20);
					PushFollow(Follow._expression_in_expression493);
					left=expression();
					PopFollow();

					DebugLocation(124, 37);
					PushFollow(Follow._expression_in_expression497);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Grammar\\SimpleCTreeWalker.g:125:5: ^(type= MOD left= expression right= expression )
					{
					DebugLocation(125, 5);
					DebugLocation(125, 11);
					type=(CommonTree)Match(input,MOD,Follow._MOD_in_expression507); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(125, 20);
					PushFollow(Follow._expression_in_expression511);
					left=expression();
					PopFollow();

					DebugLocation(125, 37);
					PushFollow(Follow._expression_in_expression515);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 6:
					DebugEnterAlt(6);
					// Grammar\\SimpleCTreeWalker.g:126:5: ^(type= SHIFT_LEFT left= expression right= expression )
					{
					DebugLocation(126, 5);
					DebugLocation(126, 11);
					type=(CommonTree)Match(input,SHIFT_LEFT,Follow._SHIFT_LEFT_in_expression525); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(126, 27);
					PushFollow(Follow._expression_in_expression529);
					left=expression();
					PopFollow();

					DebugLocation(126, 44);
					PushFollow(Follow._expression_in_expression533);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 7:
					DebugEnterAlt(7);
					// Grammar\\SimpleCTreeWalker.g:127:5: ^(type= SHIFT_RIGHT left= expression right= expression )
					{
					DebugLocation(127, 5);
					DebugLocation(127, 11);
					type=(CommonTree)Match(input,SHIFT_RIGHT,Follow._SHIFT_RIGHT_in_expression543); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(127, 28);
					PushFollow(Follow._expression_in_expression547);
					left=expression();
					PopFollow();

					DebugLocation(127, 45);
					PushFollow(Follow._expression_in_expression551);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 8:
					DebugEnterAlt(8);
					// Grammar\\SimpleCTreeWalker.g:128:5: ^(type= ASSIGN left= expression right= expression )
					{
					DebugLocation(128, 5);
					DebugLocation(128, 11);
					type=(CommonTree)Match(input,ASSIGN,Follow._ASSIGN_in_expression561); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(128, 23);
					PushFollow(Follow._expression_in_expression565);
					left=expression();
					PopFollow();

					DebugLocation(128, 40);
					PushFollow(Follow._expression_in_expression569);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 9:
					DebugEnterAlt(9);
					// Grammar\\SimpleCTreeWalker.g:129:5: ^(type= GREATER left= expression right= expression )
					{
					DebugLocation(129, 5);
					DebugLocation(129, 11);
					type=(CommonTree)Match(input,GREATER,Follow._GREATER_in_expression579); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(129, 24);
					PushFollow(Follow._expression_in_expression583);
					left=expression();
					PopFollow();

					DebugLocation(129, 41);
					PushFollow(Follow._expression_in_expression587);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 10:
					DebugEnterAlt(10);
					// Grammar\\SimpleCTreeWalker.g:130:5: ^(type= GREATER_OR_EQUAL left= expression right= expression )
					{
					DebugLocation(130, 5);
					DebugLocation(130, 11);
					type=(CommonTree)Match(input,GREATER_OR_EQUAL,Follow._GREATER_OR_EQUAL_in_expression597); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(130, 33);
					PushFollow(Follow._expression_in_expression601);
					left=expression();
					PopFollow();

					DebugLocation(130, 50);
					PushFollow(Follow._expression_in_expression605);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 11:
					DebugEnterAlt(11);
					// Grammar\\SimpleCTreeWalker.g:131:5: ^(type= LESS left= expression right= expression )
					{
					DebugLocation(131, 5);
					DebugLocation(131, 11);
					type=(CommonTree)Match(input,LESS,Follow._LESS_in_expression615); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(131, 21);
					PushFollow(Follow._expression_in_expression619);
					left=expression();
					PopFollow();

					DebugLocation(131, 38);
					PushFollow(Follow._expression_in_expression623);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 12:
					DebugEnterAlt(12);
					// Grammar\\SimpleCTreeWalker.g:132:5: ^(type= LESS_OR_EQUAL left= expression right= expression )
					{
					DebugLocation(132, 5);
					DebugLocation(132, 11);
					type=(CommonTree)Match(input,LESS_OR_EQUAL,Follow._LESS_OR_EQUAL_in_expression633); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(132, 30);
					PushFollow(Follow._expression_in_expression637);
					left=expression();
					PopFollow();

					DebugLocation(132, 47);
					PushFollow(Follow._expression_in_expression641);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 13:
					DebugEnterAlt(13);
					// Grammar\\SimpleCTreeWalker.g:133:5: ^(type= EQUAL left= expression right= expression )
					{
					DebugLocation(133, 5);
					DebugLocation(133, 11);
					type=(CommonTree)Match(input,EQUAL,Follow._EQUAL_in_expression651); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(133, 22);
					PushFollow(Follow._expression_in_expression655);
					left=expression();
					PopFollow();

					DebugLocation(133, 39);
					PushFollow(Follow._expression_in_expression659);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 14:
					DebugEnterAlt(14);
					// Grammar\\SimpleCTreeWalker.g:134:5: ^(type= NOT_EQUAL left= expression right= expression )
					{
					DebugLocation(134, 5);
					DebugLocation(134, 11);
					type=(CommonTree)Match(input,NOT_EQUAL,Follow._NOT_EQUAL_in_expression669); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(134, 26);
					PushFollow(Follow._expression_in_expression673);
					left=expression();
					PopFollow();

					DebugLocation(134, 43);
					PushFollow(Follow._expression_in_expression677);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 15:
					DebugEnterAlt(15);
					// Grammar\\SimpleCTreeWalker.g:135:5: ^(type= BOOL_AND left= expression right= expression )
					{
					DebugLocation(135, 5);
					DebugLocation(135, 11);
					type=(CommonTree)Match(input,BOOL_AND,Follow._BOOL_AND_in_expression687); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(135, 25);
					PushFollow(Follow._expression_in_expression691);
					left=expression();
					PopFollow();

					DebugLocation(135, 42);
					PushFollow(Follow._expression_in_expression695);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 16:
					DebugEnterAlt(16);
					// Grammar\\SimpleCTreeWalker.g:136:5: ^(type= BOOL_OR left= expression right= expression )
					{
					DebugLocation(136, 5);
					DebugLocation(136, 11);
					type=(CommonTree)Match(input,BOOL_OR,Follow._BOOL_OR_in_expression705); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(136, 24);
					PushFollow(Follow._expression_in_expression709);
					left=expression();
					PopFollow();

					DebugLocation(136, 41);
					PushFollow(Follow._expression_in_expression713);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 17:
					DebugEnterAlt(17);
					// Grammar\\SimpleCTreeWalker.g:137:5: ^(type= BIT_AND left= expression right= expression )
					{
					DebugLocation(137, 5);
					DebugLocation(137, 11);
					type=(CommonTree)Match(input,BIT_AND,Follow._BIT_AND_in_expression723); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(137, 24);
					PushFollow(Follow._expression_in_expression727);
					left=expression();
					PopFollow();

					DebugLocation(137, 41);
					PushFollow(Follow._expression_in_expression731);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 18:
					DebugEnterAlt(18);
					// Grammar\\SimpleCTreeWalker.g:138:5: ^(type= BIT_OR left= expression right= expression )
					{
					DebugLocation(138, 5);
					DebugLocation(138, 11);
					type=(CommonTree)Match(input,BIT_OR,Follow._BIT_OR_in_expression741); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(138, 23);
					PushFollow(Follow._expression_in_expression745);
					left=expression();
					PopFollow();

					DebugLocation(138, 40);
					PushFollow(Follow._expression_in_expression749);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 19:
					DebugEnterAlt(19);
					// Grammar\\SimpleCTreeWalker.g:139:5: ^(type= BIT_XOR left= expression right= expression )
					{
					DebugLocation(139, 5);
					DebugLocation(139, 11);
					type=(CommonTree)Match(input,BIT_XOR,Follow._BIT_XOR_in_expression759); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(139, 24);
					PushFollow(Follow._expression_in_expression763);
					left=expression();
					PopFollow();

					DebugLocation(139, 41);
					PushFollow(Follow._expression_in_expression767);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(140, 4);
				 node = new BinaryExprNode(type.Type, left, right); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleCTreeWalker.g:165:4: IDENT
				{
				DebugLocation(165, 4);
				IDENT22=(CommonTree)Match(input,IDENT,Follow._IDENT_in_expression781); 
				DebugLocation(165, 10);
				 
						node = new IdentNode();
						(node as IdentNode).Name = IDENT22.Text;
					

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleCTreeWalker.g:169:4: INTEGER
				{
				DebugLocation(169, 4);
				INTEGER23=(CommonTree)Match(input,INTEGER,Follow._INTEGER_in_expression788); 
				DebugLocation(169, 12);

						node = new IntegerNode(INTEGER23.Text);
					

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleCTreeWalker.g:172:4: STRING
				{
				DebugLocation(172, 4);
				STRING24=(CommonTree)Match(input,STRING,Follow._STRING_in_expression795); 
				DebugLocation(172, 11);

						node = new StringNode(STRING24.Text);
					

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammar\\SimpleCTreeWalker.g:175:4: ^( FUNC_CALL IDENT ^( PARAM_LIST (parameter= expression )* ) )
				{
				DebugLocation(175, 4);
				DebugLocation(175, 6);
				Match(input,FUNC_CALL,Follow._FUNC_CALL_in_expression803); 

				DebugLocation(175, 16);

							List<IExprNode> parameters = new List<IExprNode>();
						

				Match(input, TokenTypes.Down, null); 
				DebugLocation(178, 4);
				IDENT25=(CommonTree)Match(input,IDENT,Follow._IDENT_in_expression811); 
				DebugLocation(178, 10);

								if (!FuncDeclsContainer.Contains(new FuncDeclEquatable(IDENT25.Text)))
							
				DebugLocation(181, 4);
				DebugLocation(181, 6);
				Match(input,PARAM_LIST,Follow._PARAM_LIST_in_expression820); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(181, 17);
					// Grammar\\SimpleCTreeWalker.g:181:17: (parameter= expression )*
					try { DebugEnterSubRule(10);
					while (true)
					{
						int alt10=2;
						try { DebugEnterDecision(10, false);
						int LA10_0 = input.LA(1);

						if (((LA10_0>=ADD && LA10_0<=BIT_AND)||(LA10_0>=BIT_OR && LA10_0<=BOOL_AND)||LA10_0==BOOL_OR||LA10_0==DIV||LA10_0==EQUAL||LA10_0==FUNC_CALL||(LA10_0>=GREATER && LA10_0<=IDENT)||LA10_0==INTEGER||(LA10_0>=LESS && LA10_0<=LESS_OR_EQUAL)||(LA10_0>=MOD && LA10_0<=NOT_EQUAL)||(LA10_0>=SHIFT_LEFT && LA10_0<=SHIFT_RIGHT)||LA10_0==STRING||LA10_0==SUB))
						{
							alt10 = 1;
						}


						} finally { DebugExitDecision(10); }
						switch ( alt10 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammar\\SimpleCTreeWalker.g:181:18: parameter= expression
							{
							DebugLocation(181, 27);
							PushFollow(Follow._expression_in_expression825);
							parameter=expression();
							PopFollow();

							DebugLocation(181, 39);
							 parameters.Add(parameter); 

							}
							break;

						default:
							goto loop10;
						}
					}

					loop10:
						;

					} finally { DebugExitSubRule(10); }


					Match(input, TokenTypes.Up, null); 
				}


				Match(input, TokenTypes.Up, null); 

				DebugLocation(181, 80);


						FuncCallNode funcCallNode = new FuncCallNode();
						node = funcCallNode;
						funcCallNode.Function = FuncDeclsContainer.Get(new FuncDeclEquatable(IDENT25.Text));

						// Check parameters
						switch(FuncCallNode.ParameterListMatches(funcCallNode.Function.Parameters, parameters))
						{
							case FuncCallNode.ParameterMatching.ParameterCountMismatch:
								break;
							case FuncCallNode.ParameterMatching.ParameterTypeMismatch:
								break;
							default:
								// There is no error so do nothing
								break;
						}

						funcCallNode.Parameters = parameters;
					

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 11);
			LeaveRule("expression", 11);
			LeaveRule_expression();
		}
		DebugLocation(201, 0);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return node;

	}
	// $ANTLR end "expression"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _PROGRAM_in_walk61 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _programStatement_in_walk64 = new BitSet(new ulong[]{0x30000008UL,0x400UL});
		public static readonly BitSet _varDef_in_programStatement83 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcDecl_in_programStatement90 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcDef_in_programStatement97 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_DEF_in_varDef116 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _varSpec_in_varDef118 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FUNC_DECL_in_funcDecl141 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeSpec_in_funcDecl146 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _IDENT_in_funcDecl153 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _PARAM_SPEC_LIST_in_funcDecl160 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _varSpec_in_funcDecl163 = new BitSet(new ulong[]{0x8UL,0x800UL});
		public static readonly BitSet _FUNC_DECL_in_macroDecl191 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeSpec_in_macroDecl196 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _IDENT_in_macroDecl203 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _PARAM_SPEC_LIST_in_macroDecl210 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _varSpec_in_macroDecl213 = new BitSet(new ulong[]{0x8UL,0x800UL});
		public static readonly BitSet _FUNC_DEF_in_funcDef241 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeSpec_in_funcDef246 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _IDENT_in_funcDef252 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _PARAM_SPEC_LIST_in_funcDef259 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _varSpec_in_funcDef262 = new BitSet(new ulong[]{0x8UL,0x800UL});
		public static readonly BitSet _funcBody_in_funcDef272 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VAR_SPEC_in_varSpec295 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeSpec_in_varSpec297 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _IDENT_in_varSpec299 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_SPEC_in_typeSpec322 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENT_in_typeSpec324 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FUNC_BODY_in_funcBody347 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_funcBody350 = new BitSet(new ulong[]{0x400000000000008UL,0x400UL});
		public static readonly BitSet _varDef_in_statement368 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STATEMENT_in_statement375 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STATEMENT_in_statement384 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_statement386 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STATEMENT_in_statement395 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_statement407 = new BitSet(new ulong[]{0x400000000000008UL,0x400UL});
		public static readonly BitSet _ADD_in_expression435 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression439 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression443 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SUB_in_expression453 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression457 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression461 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MUL_in_expression471 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression475 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression479 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DIV_in_expression489 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression493 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression497 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MOD_in_expression507 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression511 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression515 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SHIFT_LEFT_in_expression525 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression529 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression533 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SHIFT_RIGHT_in_expression543 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression547 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression551 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASSIGN_in_expression561 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression565 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression569 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GREATER_in_expression579 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression583 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression587 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GREATER_OR_EQUAL_in_expression597 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression601 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression605 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LESS_in_expression615 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression619 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression623 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LESS_OR_EQUAL_in_expression633 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression637 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression641 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EQUAL_in_expression651 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression655 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression659 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NOT_EQUAL_in_expression669 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression673 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression677 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BOOL_AND_in_expression687 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression691 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression695 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BOOL_OR_in_expression705 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression709 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression713 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BIT_AND_in_expression723 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression727 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression731 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BIT_OR_in_expression741 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression745 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression749 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BIT_XOR_in_expression759 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression763 = new BitSet(new ulong[]{0x88C1CC41C8481770UL});
		public static readonly BitSet _expression_in_expression767 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IDENT_in_expression781 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_expression788 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_expression795 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNC_CALL_in_expression803 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENT_in_expression811 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _PARAM_LIST_in_expression820 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression825 = new BitSet(new ulong[]{0x88C1CC41C8481778UL});
	}
	#endregion Follow sets
}

} // namespace  SimpleC.Grammar 
