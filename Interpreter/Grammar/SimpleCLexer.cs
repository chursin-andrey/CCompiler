//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 Grammar\\SimpleC.g 2015-10-11 22:15:09

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


#pragma warning disable 3021


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  SimpleC.Grammar 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class SimpleCLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int ADD=4;
	public const int ASSIGN=5;
	public const int BIT_AND=6;
	public const int BIT_NOT=7;
	public const int BIT_OR=8;
	public const int BIT_XOR=9;
	public const int BOOL_AND=10;
	public const int BOOL_NOT=11;
	public const int BOOL_OR=12;
	public const int CHAR=13;
	public const int CHARACTER_LITERAL=14;
	public const int Char=15;
	public const int DEC_POST=16;
	public const int DEC_PRE=17;
	public const int DEREF=18;
	public const int DIV=19;
	public const int DO=20;
	public const int ELSE=21;
	public const int EQUAL=22;
	public const int EXPRESSION=23;
	public const int FALSE=24;
	public const int FOR=25;
	public const int FUNC_BODY=26;
	public const int FUNC_CALL=27;
	public const int FUNC_DECL=28;
	public const int FUNC_DEF=29;
	public const int GREATER=30;
	public const int GREATER_OR_EQUAL=31;
	public const int IDENT=32;
	public const int IF=33;
	public const int INCLUDE=34;
	public const int INCLUDE_STRING=35;
	public const int INC_POST=36;
	public const int INC_PRE=37;
	public const int INTEGER=38;
	public const int Identifier=39;
	public const int Int=40;
	public const int Integer=41;
	public const int LESS=42;
	public const int LESS_OR_EQUAL=43;
	public const int LINE_COMMENT=44;
	public const int ML_COMMENT=45;
	public const int MOD=46;
	public const int MUL=47;
	public const int NOT_EQUAL=48;
	public const int PARAM_LIST=49;
	public const int PARAM_SPEC_LIST=50;
	public const int PROGRAM=51;
	public const int REF=52;
	public const int RETURN=53;
	public const int SHIFT_LEFT=54;
	public const int SHIFT_RIGHT=55;
	public const int SIZEOF_EXPR=56;
	public const int SIZEOF_TYPE=57;
	public const int STATEMENT=58;
	public const int STRING=59;
	public const int STRING_LITERAL=60;
	public const int STRUCT_DEREF=61;
	public const int STRUCT_MEMBER=62;
	public const int SUB=63;
	public const int SUBSCRIPT=64;
	public const int SizeOf=65;
	public const int String=66;
	public const int TRUE=67;
	public const int TYPECAST=68;
	public const int TYPE_SPEC=69;
	public const int U_MINUS=70;
	public const int U_PLUS=71;
	public const int VAR_CALL=72;
	public const int VAR_DECL=73;
	public const int VAR_DEF=74;
	public const int VAR_SPEC=75;
	public const int VOID=76;
	public const int Void=77;
	public const int WHILE=78;
	public const int Whitespace=79;

    // delegates
    // delegators

	public SimpleCLexer()
	{
		OnCreated();
	}

	public SimpleCLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public SimpleCLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Grammar\\SimpleC.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_ADD();
	partial void LeaveRule_ADD();

	// $ANTLR start "ADD"
	[GrammarRule("ADD")]
	private void mADD()
	{
		EnterRule_ADD();
		EnterRule("ADD", 1);
		TraceIn("ADD", 1);
		try
		{
			int _type = ADD;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:13:5: ( '+' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:13:7: '+'
			{
			DebugLocation(13, 7);
			Match('+'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ADD", 1);
			LeaveRule("ADD", 1);
			LeaveRule_ADD();
		}
	}
	// $ANTLR end "ADD"

	partial void EnterRule_ASSIGN();
	partial void LeaveRule_ASSIGN();

	// $ANTLR start "ASSIGN"
	[GrammarRule("ASSIGN")]
	private void mASSIGN()
	{
		EnterRule_ASSIGN();
		EnterRule("ASSIGN", 2);
		TraceIn("ASSIGN", 2);
		try
		{
			int _type = ASSIGN;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:14:8: ( '=' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:14:10: '='
			{
			DebugLocation(14, 10);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASSIGN", 2);
			LeaveRule("ASSIGN", 2);
			LeaveRule_ASSIGN();
		}
	}
	// $ANTLR end "ASSIGN"

	partial void EnterRule_BIT_AND();
	partial void LeaveRule_BIT_AND();

	// $ANTLR start "BIT_AND"
	[GrammarRule("BIT_AND")]
	private void mBIT_AND()
	{
		EnterRule_BIT_AND();
		EnterRule("BIT_AND", 3);
		TraceIn("BIT_AND", 3);
		try
		{
			int _type = BIT_AND;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:15:9: ( '&' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:15:11: '&'
			{
			DebugLocation(15, 11);
			Match('&'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BIT_AND", 3);
			LeaveRule("BIT_AND", 3);
			LeaveRule_BIT_AND();
		}
	}
	// $ANTLR end "BIT_AND"

	partial void EnterRule_BIT_OR();
	partial void LeaveRule_BIT_OR();

	// $ANTLR start "BIT_OR"
	[GrammarRule("BIT_OR")]
	private void mBIT_OR()
	{
		EnterRule_BIT_OR();
		EnterRule("BIT_OR", 4);
		TraceIn("BIT_OR", 4);
		try
		{
			int _type = BIT_OR;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:16:8: ( '|' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:16:10: '|'
			{
			DebugLocation(16, 10);
			Match('|'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BIT_OR", 4);
			LeaveRule("BIT_OR", 4);
			LeaveRule_BIT_OR();
		}
	}
	// $ANTLR end "BIT_OR"

	partial void EnterRule_BIT_XOR();
	partial void LeaveRule_BIT_XOR();

	// $ANTLR start "BIT_XOR"
	[GrammarRule("BIT_XOR")]
	private void mBIT_XOR()
	{
		EnterRule_BIT_XOR();
		EnterRule("BIT_XOR", 5);
		TraceIn("BIT_XOR", 5);
		try
		{
			int _type = BIT_XOR;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:17:9: ( '^' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:17:11: '^'
			{
			DebugLocation(17, 11);
			Match('^'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BIT_XOR", 5);
			LeaveRule("BIT_XOR", 5);
			LeaveRule_BIT_XOR();
		}
	}
	// $ANTLR end "BIT_XOR"

	partial void EnterRule_BOOL_AND();
	partial void LeaveRule_BOOL_AND();

	// $ANTLR start "BOOL_AND"
	[GrammarRule("BOOL_AND")]
	private void mBOOL_AND()
	{
		EnterRule_BOOL_AND();
		EnterRule("BOOL_AND", 6);
		TraceIn("BOOL_AND", 6);
		try
		{
			int _type = BOOL_AND;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:18:10: ( '&&' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:18:12: '&&'
			{
			DebugLocation(18, 12);
			Match("&&"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BOOL_AND", 6);
			LeaveRule("BOOL_AND", 6);
			LeaveRule_BOOL_AND();
		}
	}
	// $ANTLR end "BOOL_AND"

	partial void EnterRule_BOOL_OR();
	partial void LeaveRule_BOOL_OR();

	// $ANTLR start "BOOL_OR"
	[GrammarRule("BOOL_OR")]
	private void mBOOL_OR()
	{
		EnterRule_BOOL_OR();
		EnterRule("BOOL_OR", 7);
		TraceIn("BOOL_OR", 7);
		try
		{
			int _type = BOOL_OR;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:19:9: ( '||' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:19:11: '||'
			{
			DebugLocation(19, 11);
			Match("||"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BOOL_OR", 7);
			LeaveRule("BOOL_OR", 7);
			LeaveRule_BOOL_OR();
		}
	}
	// $ANTLR end "BOOL_OR"

	partial void EnterRule_DIV();
	partial void LeaveRule_DIV();

	// $ANTLR start "DIV"
	[GrammarRule("DIV")]
	private void mDIV()
	{
		EnterRule_DIV();
		EnterRule("DIV", 8);
		TraceIn("DIV", 8);
		try
		{
			int _type = DIV;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:20:5: ( '/' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:20:7: '/'
			{
			DebugLocation(20, 7);
			Match('/'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIV", 8);
			LeaveRule("DIV", 8);
			LeaveRule_DIV();
		}
	}
	// $ANTLR end "DIV"

	partial void EnterRule_DO();
	partial void LeaveRule_DO();

	// $ANTLR start "DO"
	[GrammarRule("DO")]
	private void mDO()
	{
		EnterRule_DO();
		EnterRule("DO", 9);
		TraceIn("DO", 9);
		try
		{
			int _type = DO;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:21:4: ( 'do' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:21:6: 'do'
			{
			DebugLocation(21, 6);
			Match("do"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DO", 9);
			LeaveRule("DO", 9);
			LeaveRule_DO();
		}
	}
	// $ANTLR end "DO"

	partial void EnterRule_ELSE();
	partial void LeaveRule_ELSE();

	// $ANTLR start "ELSE"
	[GrammarRule("ELSE")]
	private void mELSE()
	{
		EnterRule_ELSE();
		EnterRule("ELSE", 10);
		TraceIn("ELSE", 10);
		try
		{
			int _type = ELSE;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:22:6: ( 'else' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:22:8: 'else'
			{
			DebugLocation(22, 8);
			Match("else"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ELSE", 10);
			LeaveRule("ELSE", 10);
			LeaveRule_ELSE();
		}
	}
	// $ANTLR end "ELSE"

	partial void EnterRule_EQUAL();
	partial void LeaveRule_EQUAL();

	// $ANTLR start "EQUAL"
	[GrammarRule("EQUAL")]
	private void mEQUAL()
	{
		EnterRule_EQUAL();
		EnterRule("EQUAL", 11);
		TraceIn("EQUAL", 11);
		try
		{
			int _type = EQUAL;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:23:7: ( '==' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:23:9: '=='
			{
			DebugLocation(23, 9);
			Match("=="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQUAL", 11);
			LeaveRule("EQUAL", 11);
			LeaveRule_EQUAL();
		}
	}
	// $ANTLR end "EQUAL"

	partial void EnterRule_FALSE();
	partial void LeaveRule_FALSE();

	// $ANTLR start "FALSE"
	[GrammarRule("FALSE")]
	private void mFALSE()
	{
		EnterRule_FALSE();
		EnterRule("FALSE", 12);
		TraceIn("FALSE", 12);
		try
		{
			int _type = FALSE;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:24:7: ( 'false' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:24:9: 'false'
			{
			DebugLocation(24, 9);
			Match("false"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FALSE", 12);
			LeaveRule("FALSE", 12);
			LeaveRule_FALSE();
		}
	}
	// $ANTLR end "FALSE"

	partial void EnterRule_FOR();
	partial void LeaveRule_FOR();

	// $ANTLR start "FOR"
	[GrammarRule("FOR")]
	private void mFOR()
	{
		EnterRule_FOR();
		EnterRule("FOR", 13);
		TraceIn("FOR", 13);
		try
		{
			int _type = FOR;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:25:5: ( 'for' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:25:7: 'for'
			{
			DebugLocation(25, 7);
			Match("for"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FOR", 13);
			LeaveRule("FOR", 13);
			LeaveRule_FOR();
		}
	}
	// $ANTLR end "FOR"

	partial void EnterRule_GREATER();
	partial void LeaveRule_GREATER();

	// $ANTLR start "GREATER"
	[GrammarRule("GREATER")]
	private void mGREATER()
	{
		EnterRule_GREATER();
		EnterRule("GREATER", 14);
		TraceIn("GREATER", 14);
		try
		{
			int _type = GREATER;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:26:9: ( '>' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:26:11: '>'
			{
			DebugLocation(26, 11);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GREATER", 14);
			LeaveRule("GREATER", 14);
			LeaveRule_GREATER();
		}
	}
	// $ANTLR end "GREATER"

	partial void EnterRule_GREATER_OR_EQUAL();
	partial void LeaveRule_GREATER_OR_EQUAL();

	// $ANTLR start "GREATER_OR_EQUAL"
	[GrammarRule("GREATER_OR_EQUAL")]
	private void mGREATER_OR_EQUAL()
	{
		EnterRule_GREATER_OR_EQUAL();
		EnterRule("GREATER_OR_EQUAL", 15);
		TraceIn("GREATER_OR_EQUAL", 15);
		try
		{
			int _type = GREATER_OR_EQUAL;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:27:18: ( '>=' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:27:20: '>='
			{
			DebugLocation(27, 20);
			Match(">="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GREATER_OR_EQUAL", 15);
			LeaveRule("GREATER_OR_EQUAL", 15);
			LeaveRule_GREATER_OR_EQUAL();
		}
	}
	// $ANTLR end "GREATER_OR_EQUAL"

	partial void EnterRule_IF();
	partial void LeaveRule_IF();

	// $ANTLR start "IF"
	[GrammarRule("IF")]
	private void mIF()
	{
		EnterRule_IF();
		EnterRule("IF", 16);
		TraceIn("IF", 16);
		try
		{
			int _type = IF;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:28:4: ( 'if' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:28:6: 'if'
			{
			DebugLocation(28, 6);
			Match("if"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IF", 16);
			LeaveRule("IF", 16);
			LeaveRule_IF();
		}
	}
	// $ANTLR end "IF"

	partial void EnterRule_LESS();
	partial void LeaveRule_LESS();

	// $ANTLR start "LESS"
	[GrammarRule("LESS")]
	private void mLESS()
	{
		EnterRule_LESS();
		EnterRule("LESS", 17);
		TraceIn("LESS", 17);
		try
		{
			int _type = LESS;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:29:6: ( '<' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:29:8: '<'
			{
			DebugLocation(29, 8);
			Match('<'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LESS", 17);
			LeaveRule("LESS", 17);
			LeaveRule_LESS();
		}
	}
	// $ANTLR end "LESS"

	partial void EnterRule_LESS_OR_EQUAL();
	partial void LeaveRule_LESS_OR_EQUAL();

	// $ANTLR start "LESS_OR_EQUAL"
	[GrammarRule("LESS_OR_EQUAL")]
	private void mLESS_OR_EQUAL()
	{
		EnterRule_LESS_OR_EQUAL();
		EnterRule("LESS_OR_EQUAL", 18);
		TraceIn("LESS_OR_EQUAL", 18);
		try
		{
			int _type = LESS_OR_EQUAL;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:30:15: ( '<=' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:30:17: '<='
			{
			DebugLocation(30, 17);
			Match("<="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LESS_OR_EQUAL", 18);
			LeaveRule("LESS_OR_EQUAL", 18);
			LeaveRule_LESS_OR_EQUAL();
		}
	}
	// $ANTLR end "LESS_OR_EQUAL"

	partial void EnterRule_MOD();
	partial void LeaveRule_MOD();

	// $ANTLR start "MOD"
	[GrammarRule("MOD")]
	private void mMOD()
	{
		EnterRule_MOD();
		EnterRule("MOD", 19);
		TraceIn("MOD", 19);
		try
		{
			int _type = MOD;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:31:5: ( '%' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:31:7: '%'
			{
			DebugLocation(31, 7);
			Match('%'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MOD", 19);
			LeaveRule("MOD", 19);
			LeaveRule_MOD();
		}
	}
	// $ANTLR end "MOD"

	partial void EnterRule_MUL();
	partial void LeaveRule_MUL();

	// $ANTLR start "MUL"
	[GrammarRule("MUL")]
	private void mMUL()
	{
		EnterRule_MUL();
		EnterRule("MUL", 20);
		TraceIn("MUL", 20);
		try
		{
			int _type = MUL;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:32:5: ( '*' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:32:7: '*'
			{
			DebugLocation(32, 7);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MUL", 20);
			LeaveRule("MUL", 20);
			LeaveRule_MUL();
		}
	}
	// $ANTLR end "MUL"

	partial void EnterRule_NOT_EQUAL();
	partial void LeaveRule_NOT_EQUAL();

	// $ANTLR start "NOT_EQUAL"
	[GrammarRule("NOT_EQUAL")]
	private void mNOT_EQUAL()
	{
		EnterRule_NOT_EQUAL();
		EnterRule("NOT_EQUAL", 21);
		TraceIn("NOT_EQUAL", 21);
		try
		{
			int _type = NOT_EQUAL;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:33:11: ( '!=' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:33:13: '!='
			{
			DebugLocation(33, 13);
			Match("!="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT_EQUAL", 21);
			LeaveRule("NOT_EQUAL", 21);
			LeaveRule_NOT_EQUAL();
		}
	}
	// $ANTLR end "NOT_EQUAL"

	partial void EnterRule_RETURN();
	partial void LeaveRule_RETURN();

	// $ANTLR start "RETURN"
	[GrammarRule("RETURN")]
	private void mRETURN()
	{
		EnterRule_RETURN();
		EnterRule("RETURN", 22);
		TraceIn("RETURN", 22);
		try
		{
			int _type = RETURN;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:34:8: ( 'return' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:34:10: 'return'
			{
			DebugLocation(34, 10);
			Match("return"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RETURN", 22);
			LeaveRule("RETURN", 22);
			LeaveRule_RETURN();
		}
	}
	// $ANTLR end "RETURN"

	partial void EnterRule_SHIFT_LEFT();
	partial void LeaveRule_SHIFT_LEFT();

	// $ANTLR start "SHIFT_LEFT"
	[GrammarRule("SHIFT_LEFT")]
	private void mSHIFT_LEFT()
	{
		EnterRule_SHIFT_LEFT();
		EnterRule("SHIFT_LEFT", 23);
		TraceIn("SHIFT_LEFT", 23);
		try
		{
			int _type = SHIFT_LEFT;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:35:12: ( '<<' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:35:14: '<<'
			{
			DebugLocation(35, 14);
			Match("<<"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SHIFT_LEFT", 23);
			LeaveRule("SHIFT_LEFT", 23);
			LeaveRule_SHIFT_LEFT();
		}
	}
	// $ANTLR end "SHIFT_LEFT"

	partial void EnterRule_SHIFT_RIGHT();
	partial void LeaveRule_SHIFT_RIGHT();

	// $ANTLR start "SHIFT_RIGHT"
	[GrammarRule("SHIFT_RIGHT")]
	private void mSHIFT_RIGHT()
	{
		EnterRule_SHIFT_RIGHT();
		EnterRule("SHIFT_RIGHT", 24);
		TraceIn("SHIFT_RIGHT", 24);
		try
		{
			int _type = SHIFT_RIGHT;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:36:13: ( '>>' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:36:15: '>>'
			{
			DebugLocation(36, 15);
			Match(">>"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SHIFT_RIGHT", 24);
			LeaveRule("SHIFT_RIGHT", 24);
			LeaveRule_SHIFT_RIGHT();
		}
	}
	// $ANTLR end "SHIFT_RIGHT"

	partial void EnterRule_SUB();
	partial void LeaveRule_SUB();

	// $ANTLR start "SUB"
	[GrammarRule("SUB")]
	private void mSUB()
	{
		EnterRule_SUB();
		EnterRule("SUB", 25);
		TraceIn("SUB", 25);
		try
		{
			int _type = SUB;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:37:5: ( '-' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:37:7: '-'
			{
			DebugLocation(37, 7);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SUB", 25);
			LeaveRule("SUB", 25);
			LeaveRule_SUB();
		}
	}
	// $ANTLR end "SUB"

	partial void EnterRule_TRUE();
	partial void LeaveRule_TRUE();

	// $ANTLR start "TRUE"
	[GrammarRule("TRUE")]
	private void mTRUE()
	{
		EnterRule_TRUE();
		EnterRule("TRUE", 26);
		TraceIn("TRUE", 26);
		try
		{
			int _type = TRUE;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:38:6: ( 'true' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:38:8: 'true'
			{
			DebugLocation(38, 8);
			Match("true"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TRUE", 26);
			LeaveRule("TRUE", 26);
			LeaveRule_TRUE();
		}
	}
	// $ANTLR end "TRUE"

	partial void EnterRule_WHILE();
	partial void LeaveRule_WHILE();

	// $ANTLR start "WHILE"
	[GrammarRule("WHILE")]
	private void mWHILE()
	{
		EnterRule_WHILE();
		EnterRule("WHILE", 27);
		TraceIn("WHILE", 27);
		try
		{
			int _type = WHILE;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:39:7: ( 'while' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:39:9: 'while'
			{
			DebugLocation(39, 9);
			Match("while"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHILE", 27);
			LeaveRule("WHILE", 27);
			LeaveRule_WHILE();
		}
	}
	// $ANTLR end "WHILE"

	partial void EnterRule_T__80();
	partial void LeaveRule_T__80();

	// $ANTLR start "T__80"
	[GrammarRule("T__80")]
	private void mT__80()
	{
		EnterRule_T__80();
		EnterRule("T__80", 28);
		TraceIn("T__80", 28);
		try
		{
			int _type = T__80;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:40:7: ( '!' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:40:9: '!'
			{
			DebugLocation(40, 9);
			Match('!'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__80", 28);
			LeaveRule("T__80", 28);
			LeaveRule_T__80();
		}
	}
	// $ANTLR end "T__80"

	partial void EnterRule_T__81();
	partial void LeaveRule_T__81();

	// $ANTLR start "T__81"
	[GrammarRule("T__81")]
	private void mT__81()
	{
		EnterRule_T__81();
		EnterRule("T__81", 29);
		TraceIn("T__81", 29);
		try
		{
			int _type = T__81;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:41:7: ( '#include' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:41:9: '#include'
			{
			DebugLocation(41, 9);
			Match("#include"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__81", 29);
			LeaveRule("T__81", 29);
			LeaveRule_T__81();
		}
	}
	// $ANTLR end "T__81"

	partial void EnterRule_T__82();
	partial void LeaveRule_T__82();

	// $ANTLR start "T__82"
	[GrammarRule("T__82")]
	private void mT__82()
	{
		EnterRule_T__82();
		EnterRule("T__82", 30);
		TraceIn("T__82", 30);
		try
		{
			int _type = T__82;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:42:7: ( '(' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:42:9: '('
			{
			DebugLocation(42, 9);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__82", 30);
			LeaveRule("T__82", 30);
			LeaveRule_T__82();
		}
	}
	// $ANTLR end "T__82"

	partial void EnterRule_T__83();
	partial void LeaveRule_T__83();

	// $ANTLR start "T__83"
	[GrammarRule("T__83")]
	private void mT__83()
	{
		EnterRule_T__83();
		EnterRule("T__83", 31);
		TraceIn("T__83", 31);
		try
		{
			int _type = T__83;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:43:7: ( ')' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:43:9: ')'
			{
			DebugLocation(43, 9);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__83", 31);
			LeaveRule("T__83", 31);
			LeaveRule_T__83();
		}
	}
	// $ANTLR end "T__83"

	partial void EnterRule_T__84();
	partial void LeaveRule_T__84();

	// $ANTLR start "T__84"
	[GrammarRule("T__84")]
	private void mT__84()
	{
		EnterRule_T__84();
		EnterRule("T__84", 32);
		TraceIn("T__84", 32);
		try
		{
			int _type = T__84;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:44:7: ( '++' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:44:9: '++'
			{
			DebugLocation(44, 9);
			Match("++"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__84", 32);
			LeaveRule("T__84", 32);
			LeaveRule_T__84();
		}
	}
	// $ANTLR end "T__84"

	partial void EnterRule_T__85();
	partial void LeaveRule_T__85();

	// $ANTLR start "T__85"
	[GrammarRule("T__85")]
	private void mT__85()
	{
		EnterRule_T__85();
		EnterRule("T__85", 33);
		TraceIn("T__85", 33);
		try
		{
			int _type = T__85;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:45:7: ( ',' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:45:9: ','
			{
			DebugLocation(45, 9);
			Match(','); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__85", 33);
			LeaveRule("T__85", 33);
			LeaveRule_T__85();
		}
	}
	// $ANTLR end "T__85"

	partial void EnterRule_T__86();
	partial void LeaveRule_T__86();

	// $ANTLR start "T__86"
	[GrammarRule("T__86")]
	private void mT__86()
	{
		EnterRule_T__86();
		EnterRule("T__86", 34);
		TraceIn("T__86", 34);
		try
		{
			int _type = T__86;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:46:7: ( '--' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:46:9: '--'
			{
			DebugLocation(46, 9);
			Match("--"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__86", 34);
			LeaveRule("T__86", 34);
			LeaveRule_T__86();
		}
	}
	// $ANTLR end "T__86"

	partial void EnterRule_T__87();
	partial void LeaveRule_T__87();

	// $ANTLR start "T__87"
	[GrammarRule("T__87")]
	private void mT__87()
	{
		EnterRule_T__87();
		EnterRule("T__87", 35);
		TraceIn("T__87", 35);
		try
		{
			int _type = T__87;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:47:7: ( '->' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:47:9: '->'
			{
			DebugLocation(47, 9);
			Match("->"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__87", 35);
			LeaveRule("T__87", 35);
			LeaveRule_T__87();
		}
	}
	// $ANTLR end "T__87"

	partial void EnterRule_T__88();
	partial void LeaveRule_T__88();

	// $ANTLR start "T__88"
	[GrammarRule("T__88")]
	private void mT__88()
	{
		EnterRule_T__88();
		EnterRule("T__88", 36);
		TraceIn("T__88", 36);
		try
		{
			int _type = T__88;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:48:7: ( '.' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:48:9: '.'
			{
			DebugLocation(48, 9);
			Match('.'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__88", 36);
			LeaveRule("T__88", 36);
			LeaveRule_T__88();
		}
	}
	// $ANTLR end "T__88"

	partial void EnterRule_T__89();
	partial void LeaveRule_T__89();

	// $ANTLR start "T__89"
	[GrammarRule("T__89")]
	private void mT__89()
	{
		EnterRule_T__89();
		EnterRule("T__89", 37);
		TraceIn("T__89", 37);
		try
		{
			int _type = T__89;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:49:7: ( ';' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:49:9: ';'
			{
			DebugLocation(49, 9);
			Match(';'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__89", 37);
			LeaveRule("T__89", 37);
			LeaveRule_T__89();
		}
	}
	// $ANTLR end "T__89"

	partial void EnterRule_T__90();
	partial void LeaveRule_T__90();

	// $ANTLR start "T__90"
	[GrammarRule("T__90")]
	private void mT__90()
	{
		EnterRule_T__90();
		EnterRule("T__90", 38);
		TraceIn("T__90", 38);
		try
		{
			int _type = T__90;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:50:7: ( '[' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:50:9: '['
			{
			DebugLocation(50, 9);
			Match('['); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__90", 38);
			LeaveRule("T__90", 38);
			LeaveRule_T__90();
		}
	}
	// $ANTLR end "T__90"

	partial void EnterRule_T__91();
	partial void LeaveRule_T__91();

	// $ANTLR start "T__91"
	[GrammarRule("T__91")]
	private void mT__91()
	{
		EnterRule_T__91();
		EnterRule("T__91", 39);
		TraceIn("T__91", 39);
		try
		{
			int _type = T__91;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:51:7: ( ']' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:51:9: ']'
			{
			DebugLocation(51, 9);
			Match(']'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__91", 39);
			LeaveRule("T__91", 39);
			LeaveRule_T__91();
		}
	}
	// $ANTLR end "T__91"

	partial void EnterRule_T__92();
	partial void LeaveRule_T__92();

	// $ANTLR start "T__92"
	[GrammarRule("T__92")]
	private void mT__92()
	{
		EnterRule_T__92();
		EnterRule("T__92", 40);
		TraceIn("T__92", 40);
		try
		{
			int _type = T__92;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:52:7: ( '{' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:52:9: '{'
			{
			DebugLocation(52, 9);
			Match('{'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__92", 40);
			LeaveRule("T__92", 40);
			LeaveRule_T__92();
		}
	}
	// $ANTLR end "T__92"

	partial void EnterRule_T__93();
	partial void LeaveRule_T__93();

	// $ANTLR start "T__93"
	[GrammarRule("T__93")]
	private void mT__93()
	{
		EnterRule_T__93();
		EnterRule("T__93", 41);
		TraceIn("T__93", 41);
		try
		{
			int _type = T__93;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:53:7: ( '}' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:53:9: '}'
			{
			DebugLocation(53, 9);
			Match('}'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__93", 41);
			LeaveRule("T__93", 41);
			LeaveRule_T__93();
		}
	}
	// $ANTLR end "T__93"

	partial void EnterRule_T__94();
	partial void LeaveRule_T__94();

	// $ANTLR start "T__94"
	[GrammarRule("T__94")]
	private void mT__94()
	{
		EnterRule_T__94();
		EnterRule("T__94", 42);
		TraceIn("T__94", 42);
		try
		{
			int _type = T__94;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:54:7: ( '~' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:54:9: '~'
			{
			DebugLocation(54, 9);
			Match('~'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__94", 42);
			LeaveRule("T__94", 42);
			LeaveRule_T__94();
		}
	}
	// $ANTLR end "T__94"

	partial void EnterRule_Whitespace();
	partial void LeaveRule_Whitespace();

	// $ANTLR start "Whitespace"
	[GrammarRule("Whitespace")]
	private void mWhitespace()
	{
		EnterRule_Whitespace();
		EnterRule("Whitespace", 43);
		TraceIn("Whitespace", 43);
		try
		{
			int _type = Whitespace;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:293:11: ( ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )+ )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:294:2: ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )+
			{
			DebugLocation(294, 2);
			// Grammar\\SimpleC.g:294:2: ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>='\t' && LA1_0<='\n')||(LA1_0>='\f' && LA1_0<='\r')||LA1_0==' '))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:
					{
					DebugLocation(294, 2);
					input.Consume();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(294, 39);

					_channel=Hidden;
				

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Whitespace", 43);
			LeaveRule("Whitespace", 43);
			LeaveRule_Whitespace();
		}
	}
	// $ANTLR end "Whitespace"

	partial void EnterRule_Integer();
	partial void LeaveRule_Integer();

	// $ANTLR start "Integer"
	[GrammarRule("Integer")]
	private void mInteger()
	{
		EnterRule_Integer();
		EnterRule("Integer", 44);
		TraceIn("Integer", 44);
		try
		{
			int _type = Integer;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:299:8: ( ( '0' .. '9' )+ )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:300:2: ( '0' .. '9' )+
			{
			DebugLocation(300, 2);
			// Grammar\\SimpleC.g:300:2: ( '0' .. '9' )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if (((LA2_0>='0' && LA2_0<='9')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:
					{
					DebugLocation(300, 2);
					input.Consume();


					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Integer", 44);
			LeaveRule("Integer", 44);
			LeaveRule_Integer();
		}
	}
	// $ANTLR end "Integer"

	partial void EnterRule_SizeOf();
	partial void LeaveRule_SizeOf();

	// $ANTLR start "SizeOf"
	[GrammarRule("SizeOf")]
	private void mSizeOf()
	{
		EnterRule_SizeOf();
		EnterRule("SizeOf", 45);
		TraceIn("SizeOf", 45);
		try
		{
			int _type = SizeOf;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:303:7: ( 'sizeof' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:303:9: 'sizeof'
			{
			DebugLocation(303, 9);
			Match("sizeof"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SizeOf", 45);
			LeaveRule("SizeOf", 45);
			LeaveRule_SizeOf();
		}
	}
	// $ANTLR end "SizeOf"

	partial void EnterRule_Int();
	partial void LeaveRule_Int();

	// $ANTLR start "Int"
	[GrammarRule("Int")]
	private void mInt()
	{
		EnterRule_Int();
		EnterRule("Int", 46);
		TraceIn("Int", 46);
		try
		{
			int _type = Int;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:305:4: ( 'int' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:305:6: 'int'
			{
			DebugLocation(305, 6);
			Match("int"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Int", 46);
			LeaveRule("Int", 46);
			LeaveRule_Int();
		}
	}
	// $ANTLR end "Int"

	partial void EnterRule_Void();
	partial void LeaveRule_Void();

	// $ANTLR start "Void"
	[GrammarRule("Void")]
	private void mVoid()
	{
		EnterRule_Void();
		EnterRule("Void", 47);
		TraceIn("Void", 47);
		try
		{
			int _type = Void;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:307:5: ( 'void' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:307:7: 'void'
			{
			DebugLocation(307, 7);
			Match("void"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Void", 47);
			LeaveRule("Void", 47);
			LeaveRule_Void();
		}
	}
	// $ANTLR end "Void"

	partial void EnterRule_Char();
	partial void LeaveRule_Char();

	// $ANTLR start "Char"
	[GrammarRule("Char")]
	private void mChar()
	{
		EnterRule_Char();
		EnterRule("Char", 48);
		TraceIn("Char", 48);
		try
		{
			int _type = Char;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:309:5: ( 'char' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:309:9: 'char'
			{
			DebugLocation(309, 9);
			Match("char"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Char", 48);
			LeaveRule("Char", 48);
			LeaveRule_Char();
		}
	}
	// $ANTLR end "Char"

	partial void EnterRule_String();
	partial void LeaveRule_String();

	// $ANTLR start "String"
	[GrammarRule("String")]
	private void mString()
	{
		EnterRule_String();
		EnterRule("String", 49);
		TraceIn("String", 49);
		try
		{
			int _type = String;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:310:7: ( 'char' ( Whitespace )? '*' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:310:9: 'char' ( Whitespace )? '*'
			{
			DebugLocation(310, 9);
			Match("char"); 

			DebugLocation(310, 16);
			// Grammar\\SimpleC.g:310:16: ( Whitespace )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if (((LA3_0>='\t' && LA3_0<='\n')||(LA3_0>='\f' && LA3_0<='\r')||LA3_0==' '))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:310:16: Whitespace
				{
				DebugLocation(310, 16);
				mWhitespace(); 

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(310, 28);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("String", 49);
			LeaveRule("String", 49);
			LeaveRule_String();
		}
	}
	// $ANTLR end "String"

	partial void EnterRule_Identifier();
	partial void LeaveRule_Identifier();

	// $ANTLR start "Identifier"
	[GrammarRule("Identifier")]
	private void mIdentifier()
	{
		EnterRule_Identifier();
		EnterRule("Identifier", 50);
		TraceIn("Identifier", 50);
		try
		{
			int _type = Identifier;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:312:11: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:313:2: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
			{
			DebugLocation(313, 2);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(314, 2);
			// Grammar\\SimpleC.g:314:2: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if (((LA4_0>='0' && LA4_0<='9')||(LA4_0>='A' && LA4_0<='Z')||LA4_0=='_'||(LA4_0>='a' && LA4_0<='z')))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:
					{
					DebugLocation(314, 2);
					input.Consume();


					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Identifier", 50);
			LeaveRule("Identifier", 50);
			LeaveRule_Identifier();
		}
	}
	// $ANTLR end "Identifier"

	partial void EnterRule_ML_COMMENT();
	partial void LeaveRule_ML_COMMENT();

	// $ANTLR start "ML_COMMENT"
	[GrammarRule("ML_COMMENT")]
	private void mML_COMMENT()
	{
		EnterRule_ML_COMMENT();
		EnterRule("ML_COMMENT", 51);
		TraceIn("ML_COMMENT", 51);
		try
		{
			int _type = ML_COMMENT;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:317:11: ( '/*' ( options {greedy=false; } : . )* '*/' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:318:3: '/*' ( options {greedy=false; } : . )* '*/'
			{
			DebugLocation(318, 3);
			Match("/*"); 

			DebugLocation(318, 8);
			// Grammar\\SimpleC.g:318:8: ( options {greedy=false; } : . )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0=='*'))
				{
					int LA5_1 = input.LA(2);

					if ((LA5_1=='/'))
					{
						alt5 = 2;
					}
					else if (((LA5_1>='\u0000' && LA5_1<='.')||(LA5_1>='0' && LA5_1<='\uFFFF')))
					{
						alt5 = 1;
					}


				}
				else if (((LA5_0>='\u0000' && LA5_0<=')')||(LA5_0>='+' && LA5_0<='\uFFFF')))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:318:38: .
					{
					DebugLocation(318, 38);
					MatchAny(); 

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(318, 43);
			Match("*/"); 

			DebugLocation(318, 48);

			    _channel=Hidden;
			  

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ML_COMMENT", 51);
			LeaveRule("ML_COMMENT", 51);
			LeaveRule_ML_COMMENT();
		}
	}
	// $ANTLR end "ML_COMMENT"

	partial void EnterRule_LINE_COMMENT();
	partial void LeaveRule_LINE_COMMENT();

	// $ANTLR start "LINE_COMMENT"
	[GrammarRule("LINE_COMMENT")]
	private void mLINE_COMMENT()
	{
		EnterRule_LINE_COMMENT();
		EnterRule("LINE_COMMENT", 52);
		TraceIn("LINE_COMMENT", 52);
		try
		{
			int _type = LINE_COMMENT;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:324:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:324:7: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
			{
			DebugLocation(324, 7);
			Match("//"); 

			DebugLocation(324, 12);
			// Grammar\\SimpleC.g:324:12: (~ ( '\\n' | '\\r' ) )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if (((LA6_0>='\u0000' && LA6_0<='\t')||(LA6_0>='\u000B' && LA6_0<='\f')||(LA6_0>='\u000E' && LA6_0<='\uFFFF')))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:
					{
					DebugLocation(324, 12);
					input.Consume();


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(324, 26);
			// Grammar\\SimpleC.g:324:26: ( '\\r' )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0=='\r'))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:324:26: '\\r'
				{
				DebugLocation(324, 26);
				Match('\r'); 

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(324, 32);
			Match('\n'); 
			DebugLocation(324, 37);
			_channel=Hidden;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LINE_COMMENT", 52);
			LeaveRule("LINE_COMMENT", 52);
			LeaveRule_LINE_COMMENT();
		}
	}
	// $ANTLR end "LINE_COMMENT"

	partial void EnterRule_STRING_LITERAL();
	partial void LeaveRule_STRING_LITERAL();

	// $ANTLR start "STRING_LITERAL"
	[GrammarRule("STRING_LITERAL")]
	private void mSTRING_LITERAL()
	{
		EnterRule_STRING_LITERAL();
		EnterRule("STRING_LITERAL", 53);
		TraceIn("STRING_LITERAL", 53);
		try
		{
			int _type = STRING_LITERAL;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:328:15: ( '\"' (~ ( '\\\\' | '\"' ) )* '\"' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:328:18: '\"' (~ ( '\\\\' | '\"' ) )* '\"'
			{
			DebugLocation(328, 18);
			Match('\"'); 
			DebugLocation(328, 22);
			// Grammar\\SimpleC.g:328:22: (~ ( '\\\\' | '\"' ) )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if (((LA8_0>='\u0000' && LA8_0<='!')||(LA8_0>='#' && LA8_0<='[')||(LA8_0>=']' && LA8_0<='\uFFFF')))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:
					{
					DebugLocation(328, 22);
					input.Consume();


					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(328, 39);
			Match('\"'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING_LITERAL", 53);
			LeaveRule("STRING_LITERAL", 53);
			LeaveRule_STRING_LITERAL();
		}
	}
	// $ANTLR end "STRING_LITERAL"

	partial void EnterRule_CHARACTER_LITERAL();
	partial void LeaveRule_CHARACTER_LITERAL();

	// $ANTLR start "CHARACTER_LITERAL"
	[GrammarRule("CHARACTER_LITERAL")]
	private void mCHARACTER_LITERAL()
	{
		EnterRule_CHARACTER_LITERAL();
		EnterRule("CHARACTER_LITERAL", 54);
		TraceIn("CHARACTER_LITERAL", 54);
		try
		{
			int _type = CHARACTER_LITERAL;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:331:18: ( '\\'' (~ ( '\\'' | '\\\\' ) ) '\\'' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:332:2: '\\'' (~ ( '\\'' | '\\\\' ) ) '\\''
			{
			DebugLocation(332, 2);
			Match('\''); 
			DebugLocation(332, 7);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='&')||(input.LA(1)>='(' && input.LA(1)<='[')||(input.LA(1)>=']' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(332, 24);
			Match('\''); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CHARACTER_LITERAL", 54);
			LeaveRule("CHARACTER_LITERAL", 54);
			LeaveRule_CHARACTER_LITERAL();
		}
	}
	// $ANTLR end "CHARACTER_LITERAL"

	partial void EnterRule_INCLUDE_STRING();
	partial void LeaveRule_INCLUDE_STRING();

	// $ANTLR start "INCLUDE_STRING"
	[GrammarRule("INCLUDE_STRING")]
	private void mINCLUDE_STRING()
	{
		EnterRule_INCLUDE_STRING();
		EnterRule("INCLUDE_STRING", 55);
		TraceIn("INCLUDE_STRING", 55);
		try
		{
			int _type = INCLUDE_STRING;
			int _channel = DefaultTokenChannel;
			// Grammar\\SimpleC.g:335:15: ( '<' (~ '>' )* '>' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:336:3: '<' (~ '>' )* '>'
			{
			DebugLocation(336, 3);
			Match('<'); 
			DebugLocation(336, 7);
			// Grammar\\SimpleC.g:336:7: (~ '>' )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if (((LA9_0>='\u0000' && LA9_0<='=')||(LA9_0>='?' && LA9_0<='\uFFFF')))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:
					{
					DebugLocation(336, 7);
					input.Consume();


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(336, 13);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INCLUDE_STRING", 55);
			LeaveRule("INCLUDE_STRING", 55);
			LeaveRule_INCLUDE_STRING();
		}
	}
	// $ANTLR end "INCLUDE_STRING"

	public override void mTokens()
	{
		// Grammar\\SimpleC.g:1:8: ( ADD | ASSIGN | BIT_AND | BIT_OR | BIT_XOR | BOOL_AND | BOOL_OR | DIV | DO | ELSE | EQUAL | FALSE | FOR | GREATER | GREATER_OR_EQUAL | IF | LESS | LESS_OR_EQUAL | MOD | MUL | NOT_EQUAL | RETURN | SHIFT_LEFT | SHIFT_RIGHT | SUB | TRUE | WHILE | T__80 | T__81 | T__82 | T__83 | T__84 | T__85 | T__86 | T__87 | T__88 | T__89 | T__90 | T__91 | T__92 | T__93 | T__94 | Whitespace | Integer | SizeOf | Int | Void | Char | String | Identifier | ML_COMMENT | LINE_COMMENT | STRING_LITERAL | CHARACTER_LITERAL | INCLUDE_STRING )
		int alt10=55;
		try { DebugEnterDecision(10, false);
		try
		{
			alt10 = dfa10.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(10); }
		switch (alt10)
		{
		case 1:
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:1:10: ADD
			{
			DebugLocation(1, 10);
			mADD(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Grammar\\SimpleC.g:1:14: ASSIGN
			{
			DebugLocation(1, 14);
			mASSIGN(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Grammar\\SimpleC.g:1:21: BIT_AND
			{
			DebugLocation(1, 21);
			mBIT_AND(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// Grammar\\SimpleC.g:1:29: BIT_OR
			{
			DebugLocation(1, 29);
			mBIT_OR(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// Grammar\\SimpleC.g:1:36: BIT_XOR
			{
			DebugLocation(1, 36);
			mBIT_XOR(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// Grammar\\SimpleC.g:1:44: BOOL_AND
			{
			DebugLocation(1, 44);
			mBOOL_AND(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// Grammar\\SimpleC.g:1:53: BOOL_OR
			{
			DebugLocation(1, 53);
			mBOOL_OR(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// Grammar\\SimpleC.g:1:61: DIV
			{
			DebugLocation(1, 61);
			mDIV(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// Grammar\\SimpleC.g:1:65: DO
			{
			DebugLocation(1, 65);
			mDO(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// Grammar\\SimpleC.g:1:68: ELSE
			{
			DebugLocation(1, 68);
			mELSE(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// Grammar\\SimpleC.g:1:73: EQUAL
			{
			DebugLocation(1, 73);
			mEQUAL(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// Grammar\\SimpleC.g:1:79: FALSE
			{
			DebugLocation(1, 79);
			mFALSE(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// Grammar\\SimpleC.g:1:85: FOR
			{
			DebugLocation(1, 85);
			mFOR(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// Grammar\\SimpleC.g:1:89: GREATER
			{
			DebugLocation(1, 89);
			mGREATER(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// Grammar\\SimpleC.g:1:97: GREATER_OR_EQUAL
			{
			DebugLocation(1, 97);
			mGREATER_OR_EQUAL(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// Grammar\\SimpleC.g:1:114: IF
			{
			DebugLocation(1, 114);
			mIF(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// Grammar\\SimpleC.g:1:117: LESS
			{
			DebugLocation(1, 117);
			mLESS(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// Grammar\\SimpleC.g:1:122: LESS_OR_EQUAL
			{
			DebugLocation(1, 122);
			mLESS_OR_EQUAL(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// Grammar\\SimpleC.g:1:136: MOD
			{
			DebugLocation(1, 136);
			mMOD(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// Grammar\\SimpleC.g:1:140: MUL
			{
			DebugLocation(1, 140);
			mMUL(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// Grammar\\SimpleC.g:1:144: NOT_EQUAL
			{
			DebugLocation(1, 144);
			mNOT_EQUAL(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// Grammar\\SimpleC.g:1:154: RETURN
			{
			DebugLocation(1, 154);
			mRETURN(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// Grammar\\SimpleC.g:1:161: SHIFT_LEFT
			{
			DebugLocation(1, 161);
			mSHIFT_LEFT(); 

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// Grammar\\SimpleC.g:1:172: SHIFT_RIGHT
			{
			DebugLocation(1, 172);
			mSHIFT_RIGHT(); 

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// Grammar\\SimpleC.g:1:184: SUB
			{
			DebugLocation(1, 184);
			mSUB(); 

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// Grammar\\SimpleC.g:1:188: TRUE
			{
			DebugLocation(1, 188);
			mTRUE(); 

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// Grammar\\SimpleC.g:1:193: WHILE
			{
			DebugLocation(1, 193);
			mWHILE(); 

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// Grammar\\SimpleC.g:1:199: T__80
			{
			DebugLocation(1, 199);
			mT__80(); 

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// Grammar\\SimpleC.g:1:205: T__81
			{
			DebugLocation(1, 205);
			mT__81(); 

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// Grammar\\SimpleC.g:1:211: T__82
			{
			DebugLocation(1, 211);
			mT__82(); 

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// Grammar\\SimpleC.g:1:217: T__83
			{
			DebugLocation(1, 217);
			mT__83(); 

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// Grammar\\SimpleC.g:1:223: T__84
			{
			DebugLocation(1, 223);
			mT__84(); 

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// Grammar\\SimpleC.g:1:229: T__85
			{
			DebugLocation(1, 229);
			mT__85(); 

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// Grammar\\SimpleC.g:1:235: T__86
			{
			DebugLocation(1, 235);
			mT__86(); 

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// Grammar\\SimpleC.g:1:241: T__87
			{
			DebugLocation(1, 241);
			mT__87(); 

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// Grammar\\SimpleC.g:1:247: T__88
			{
			DebugLocation(1, 247);
			mT__88(); 

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// Grammar\\SimpleC.g:1:253: T__89
			{
			DebugLocation(1, 253);
			mT__89(); 

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// Grammar\\SimpleC.g:1:259: T__90
			{
			DebugLocation(1, 259);
			mT__90(); 

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// Grammar\\SimpleC.g:1:265: T__91
			{
			DebugLocation(1, 265);
			mT__91(); 

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// Grammar\\SimpleC.g:1:271: T__92
			{
			DebugLocation(1, 271);
			mT__92(); 

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// Grammar\\SimpleC.g:1:277: T__93
			{
			DebugLocation(1, 277);
			mT__93(); 

			}
			break;
		case 42:
			DebugEnterAlt(42);
			// Grammar\\SimpleC.g:1:283: T__94
			{
			DebugLocation(1, 283);
			mT__94(); 

			}
			break;
		case 43:
			DebugEnterAlt(43);
			// Grammar\\SimpleC.g:1:289: Whitespace
			{
			DebugLocation(1, 289);
			mWhitespace(); 

			}
			break;
		case 44:
			DebugEnterAlt(44);
			// Grammar\\SimpleC.g:1:300: Integer
			{
			DebugLocation(1, 300);
			mInteger(); 

			}
			break;
		case 45:
			DebugEnterAlt(45);
			// Grammar\\SimpleC.g:1:308: SizeOf
			{
			DebugLocation(1, 308);
			mSizeOf(); 

			}
			break;
		case 46:
			DebugEnterAlt(46);
			// Grammar\\SimpleC.g:1:315: Int
			{
			DebugLocation(1, 315);
			mInt(); 

			}
			break;
		case 47:
			DebugEnterAlt(47);
			// Grammar\\SimpleC.g:1:319: Void
			{
			DebugLocation(1, 319);
			mVoid(); 

			}
			break;
		case 48:
			DebugEnterAlt(48);
			// Grammar\\SimpleC.g:1:324: Char
			{
			DebugLocation(1, 324);
			mChar(); 

			}
			break;
		case 49:
			DebugEnterAlt(49);
			// Grammar\\SimpleC.g:1:329: String
			{
			DebugLocation(1, 329);
			mString(); 

			}
			break;
		case 50:
			DebugEnterAlt(50);
			// Grammar\\SimpleC.g:1:336: Identifier
			{
			DebugLocation(1, 336);
			mIdentifier(); 

			}
			break;
		case 51:
			DebugEnterAlt(51);
			// Grammar\\SimpleC.g:1:347: ML_COMMENT
			{
			DebugLocation(1, 347);
			mML_COMMENT(); 

			}
			break;
		case 52:
			DebugEnterAlt(52);
			// Grammar\\SimpleC.g:1:358: LINE_COMMENT
			{
			DebugLocation(1, 358);
			mLINE_COMMENT(); 

			}
			break;
		case 53:
			DebugEnterAlt(53);
			// Grammar\\SimpleC.g:1:371: STRING_LITERAL
			{
			DebugLocation(1, 371);
			mSTRING_LITERAL(); 

			}
			break;
		case 54:
			DebugEnterAlt(54);
			// Grammar\\SimpleC.g:1:386: CHARACTER_LITERAL
			{
			DebugLocation(1, 386);
			mCHARACTER_LITERAL(); 

			}
			break;
		case 55:
			DebugEnterAlt(55);
			// Grammar\\SimpleC.g:1:404: INCLUDE_STRING
			{
			DebugLocation(1, 404);
			mINCLUDE_STRING(); 

			}
			break;

		}

	}


	#region DFA
	DFA10 dfa10;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa10 = new DFA10(this, SpecialStateTransition10);
	}

	private class DFA10 : DFA
	{
		private const string DFA10_eotS =
			"\x1\xFFFF\x1\x28\x1\x2A\x1\x2C\x1\x2E\x1\xFFFF\x1\x31\x3\x24\x1\x38\x1"+
			"\x24\x1\x3D\x2\xFFFF\x1\x40\x1\x24\x1\x44\x2\x24\xD\xFFFF\x3\x24\xE\xFFFF"+
			"\x1\x4A\x3\x24\x3\xFFFF\x1\x4E\x1\x24\x1\x50\x1\x51\x4\xFFFF\x1\x24\x3"+
			"\xFFFF\x5\x24\x1\xFFFF\x2\x24\x1\x5A\x1\xFFFF\x1\x5B\x2\xFFFF\x6\x24"+
			"\x1\x62\x1\x24\x2\xFFFF\x1\x24\x1\x65\x2\x24\x1\x68\x1\x69\x1\xFFFF\x1"+
			"\x6B\x1\x24\x1\xFFFF\x1\x6D\x1\x24\x4\xFFFF\x1\x6F\x1\xFFFF\x1\x70\x2"+
			"\xFFFF";
		private const string DFA10_eofS =
			"\x71\xFFFF";
		private const string DFA10_minS =
			"\x1\x9\x1\x2B\x1\x3D\x1\x26\x1\x7C\x1\xFFFF\x1\x2A\x1\x6F\x1\x6C\x1\x61"+
			"\x1\x3D\x1\x66\x1\x0\x2\xFFFF\x1\x3D\x1\x65\x1\x2D\x1\x72\x1\x68\xD\xFFFF"+
			"\x1\x69\x1\x6F\x1\x68\xE\xFFFF\x1\x30\x1\x73\x1\x6C\x1\x72\x3\xFFFF\x1"+
			"\x30\x1\x74\x2\x0\x4\xFFFF\x1\x74\x3\xFFFF\x1\x75\x1\x69\x1\x7A\x1\x69"+
			"\x1\x61\x1\xFFFF\x1\x65\x1\x73\x1\x30\x1\xFFFF\x1\x30\x2\xFFFF\x1\x75"+
			"\x1\x65\x1\x6C\x1\x65\x1\x64\x1\x72\x1\x30\x1\x65\x2\xFFFF\x1\x72\x1"+
			"\x30\x1\x65\x1\x6F\x1\x30\x1\x9\x1\xFFFF\x1\x30\x1\x6E\x1\xFFFF\x1\x30"+
			"\x1\x66\x4\xFFFF\x1\x30\x1\xFFFF\x1\x30\x2\xFFFF";
		private const string DFA10_maxS =
			"\x1\x7E\x1\x2B\x1\x3D\x1\x26\x1\x7C\x1\xFFFF\x1\x2F\x1\x6F\x1\x6C\x1"+
			"\x6F\x1\x3E\x1\x6E\x1\xFFFF\x2\xFFFF\x1\x3D\x1\x65\x1\x3E\x1\x72\x1\x68"+
			"\xD\xFFFF\x1\x69\x1\x6F\x1\x68\xE\xFFFF\x1\x7A\x1\x73\x1\x6C\x1\x72\x3"+
			"\xFFFF\x1\x7A\x1\x74\x2\xFFFF\x4\xFFFF\x1\x74\x3\xFFFF\x1\x75\x1\x69"+
			"\x1\x7A\x1\x69\x1\x61\x1\xFFFF\x1\x65\x1\x73\x1\x7A\x1\xFFFF\x1\x7A\x2"+
			"\xFFFF\x1\x75\x1\x65\x1\x6C\x1\x65\x1\x64\x1\x72\x1\x7A\x1\x65\x2\xFFFF"+
			"\x1\x72\x1\x7A\x1\x65\x1\x6F\x2\x7A\x1\xFFFF\x1\x7A\x1\x6E\x1\xFFFF\x1"+
			"\x7A\x1\x66\x4\xFFFF\x1\x7A\x1\xFFFF\x1\x7A\x2\xFFFF";
		private const string DFA10_acceptS =
			"\x5\xFFFF\x1\x5\x7\xFFFF\x1\x13\x1\x14\x5\xFFFF\x1\x1D\x1\x1E\x1\x1F"+
			"\x1\x21\x1\x24\x1\x25\x1\x26\x1\x27\x1\x28\x1\x29\x1\x2A\x1\x2B\x1\x2C"+
			"\x3\xFFFF\x1\x32\x1\x35\x1\x36\x1\x20\x1\x1\x1\xB\x1\x2\x1\x6\x1\x3\x1"+
			"\x7\x1\x4\x1\x33\x1\x34\x1\x8\x4\xFFFF\x1\xF\x1\x18\x1\xE\x4\xFFFF\x1"+
			"\x11\x1\x37\x1\x15\x1\x1C\x1\xFFFF\x1\x22\x1\x23\x1\x19\x5\xFFFF\x1\x9"+
			"\x3\xFFFF\x1\x10\x1\xFFFF\x1\x12\x1\x17\x8\xFFFF\x1\xD\x1\x2E\x6\xFFFF"+
			"\x1\xA\x2\xFFFF\x1\x1A\x2\xFFFF\x1\x2F\x1\x30\x1\x31\x1\xC\x1\xFFFF\x1"+
			"\x1B\x1\xFFFF\x1\x16\x1\x2D";
		private const string DFA10_specialS =
			"\xC\xFFFF\x1\x2\x2E\xFFFF\x1\x1\x1\x0\x34\xFFFF}>";
		private static readonly string[] DFA10_transitionS =
			{
				"\x2\x1F\x1\xFFFF\x2\x1F\x12\xFFFF\x1\x1F\x1\xF\x1\x25\x1\x14\x1\xFFFF"+
				"\x1\xD\x1\x3\x1\x26\x1\x15\x1\x16\x1\xE\x1\x1\x1\x17\x1\x11\x1\x18\x1"+
				"\x6\xA\x20\x1\xFFFF\x1\x19\x1\xC\x1\x2\x1\xA\x2\xFFFF\x1A\x24\x1\x1A"+
				"\x1\xFFFF\x1\x1B\x1\x5\x1\x24\x1\xFFFF\x2\x24\x1\x23\x1\x7\x1\x8\x1"+
				"\x9\x2\x24\x1\xB\x8\x24\x1\x10\x1\x21\x1\x12\x1\x24\x1\x22\x1\x13\x3"+
				"\x24\x1\x1C\x1\x4\x1\x1D\x1\x1E",
				"\x1\x27",
				"\x1\x29",
				"\x1\x2B",
				"\x1\x2D",
				"",
				"\x1\x2F\x4\xFFFF\x1\x30",
				"\x1\x32",
				"\x1\x33",
				"\x1\x34\xD\xFFFF\x1\x35",
				"\x1\x36\x1\x37",
				"\x1\x39\x7\xFFFF\x1\x3A",
				"\x3C\x3E\x1\x3C\x1\x3B\xFFC2\x3E",
				"",
				"",
				"\x1\x3F",
				"\x1\x41",
				"\x1\x42\x10\xFFFF\x1\x43",
				"\x1\x45",
				"\x1\x46",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x47",
				"\x1\x48",
				"\x1\x49",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"\x1\x4B",
				"\x1\x4C",
				"\x1\x4D",
				"",
				"",
				"",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"\x1\x4F",
				"\x0\x3E",
				"\x0\x3E",
				"",
				"",
				"",
				"",
				"\x1\x52",
				"",
				"",
				"",
				"\x1\x53",
				"\x1\x54",
				"\x1\x55",
				"\x1\x56",
				"\x1\x57",
				"",
				"\x1\x58",
				"\x1\x59",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"",
				"",
				"\x1\x5C",
				"\x1\x5D",
				"\x1\x5E",
				"\x1\x5F",
				"\x1\x60",
				"\x1\x61",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"\x1\x63",
				"",
				"",
				"\x1\x64",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"\x1\x66",
				"\x1\x67",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"\x2\x6A\x1\xFFFF\x2\x6A\x12\xFFFF\x1\x6A\x9\xFFFF\x1\x6A\x5\xFFFF\xA"+
				"\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"\x1\x6C",
				"",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"\x1\x6E",
				"",
				"",
				"",
				"",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"",
				"\xA\x24\x7\xFFFF\x1A\x24\x4\xFFFF\x1\x24\x1\xFFFF\x1A\x24",
				"",
				""
			};

		private static readonly short[] DFA10_eot = DFA.UnpackEncodedString(DFA10_eotS);
		private static readonly short[] DFA10_eof = DFA.UnpackEncodedString(DFA10_eofS);
		private static readonly char[] DFA10_min = DFA.UnpackEncodedStringToUnsignedChars(DFA10_minS);
		private static readonly char[] DFA10_max = DFA.UnpackEncodedStringToUnsignedChars(DFA10_maxS);
		private static readonly short[] DFA10_accept = DFA.UnpackEncodedString(DFA10_acceptS);
		private static readonly short[] DFA10_special = DFA.UnpackEncodedString(DFA10_specialS);
		private static readonly short[][] DFA10_transition;

		static DFA10()
		{
			int numStates = DFA10_transitionS.Length;
			DFA10_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA10_transition[i] = DFA.UnpackEncodedString(DFA10_transitionS[i]);
			}
		}

		public DFA10( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 10;
			this.eot = DFA10_eot;
			this.eof = DFA10_eof;
			this.min = DFA10_min;
			this.max = DFA10_max;
			this.accept = DFA10_accept;
			this.special = DFA10_special;
			this.transition = DFA10_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( ADD | ASSIGN | BIT_AND | BIT_OR | BIT_XOR | BOOL_AND | BOOL_OR | DIV | DO | ELSE | EQUAL | FALSE | FOR | GREATER | GREATER_OR_EQUAL | IF | LESS | LESS_OR_EQUAL | MOD | MUL | NOT_EQUAL | RETURN | SHIFT_LEFT | SHIFT_RIGHT | SUB | TRUE | WHILE | T__80 | T__81 | T__82 | T__83 | T__84 | T__85 | T__86 | T__87 | T__88 | T__89 | T__90 | T__91 | T__92 | T__93 | T__94 | Whitespace | Integer | SizeOf | Int | Void | Char | String | Identifier | ML_COMMENT | LINE_COMMENT | STRING_LITERAL | CHARACTER_LITERAL | INCLUDE_STRING );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition10(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA10_60 = input.LA(1);

				s = -1;
				if (((LA10_60>='\u0000' && LA10_60<='\uFFFF'))) {s = 62;}

				else s = 81;

				if (s >= 0) return s;
				break;

			case 1:
				int LA10_59 = input.LA(1);

				s = -1;
				if (((LA10_59>='\u0000' && LA10_59<='\uFFFF'))) {s = 62;}

				else s = 80;

				if (s >= 0) return s;
				break;

			case 2:
				int LA10_12 = input.LA(1);

				s = -1;
				if ((LA10_12=='=')) {s = 59;}

				else if ((LA10_12=='<')) {s = 60;}

				else if (((LA10_12>='\u0000' && LA10_12<=';')||(LA10_12>='>' && LA10_12<='\uFFFF'))) {s = 62;}

				else s = 61;

				if (s >= 0) return s;
				break;
		}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 10, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
 
	#endregion

}

} // namespace  SimpleC.Grammar 
