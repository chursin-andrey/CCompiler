//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 Grammar\\SimpleC.g 2015-10-11 22:15:08

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


#pragma warning disable 3021


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  SimpleC.Grammar 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class SimpleCParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "ASSIGN", "BIT_AND", "BIT_NOT", "BIT_OR", "BIT_XOR", "BOOL_AND", "BOOL_NOT", "BOOL_OR", "CHAR", "CHARACTER_LITERAL", "Char", "DEC_POST", "DEC_PRE", "DEREF", "DIV", "DO", "ELSE", "EQUAL", "EXPRESSION", "FALSE", "FOR", "FUNC_BODY", "FUNC_CALL", "FUNC_DECL", "FUNC_DEF", "GREATER", "GREATER_OR_EQUAL", "IDENT", "IF", "INCLUDE", "INCLUDE_STRING", "INC_POST", "INC_PRE", "INTEGER", "Identifier", "Int", "Integer", "LESS", "LESS_OR_EQUAL", "LINE_COMMENT", "ML_COMMENT", "MOD", "MUL", "NOT_EQUAL", "PARAM_LIST", "PARAM_SPEC_LIST", "PROGRAM", "REF", "RETURN", "SHIFT_LEFT", "SHIFT_RIGHT", "SIZEOF_EXPR", "SIZEOF_TYPE", "STATEMENT", "STRING", "STRING_LITERAL", "STRUCT_DEREF", "STRUCT_MEMBER", "SUB", "SUBSCRIPT", "SizeOf", "String", "TRUE", "TYPECAST", "TYPE_SPEC", "U_MINUS", "U_PLUS", "VAR_CALL", "VAR_DECL", "VAR_DEF", "VAR_SPEC", "VOID", "Void", "WHILE", "Whitespace", "'!'", "'#include'", "'('", "')'", "'++'", "','", "'--'", "'->'", "'.'", "';'", "'['", "']'", "'{'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int ADD=4;
	public const int ASSIGN=5;
	public const int BIT_AND=6;
	public const int BIT_NOT=7;
	public const int BIT_OR=8;
	public const int BIT_XOR=9;
	public const int BOOL_AND=10;
	public const int BOOL_NOT=11;
	public const int BOOL_OR=12;
	public const int CHAR=13;
	public const int CHARACTER_LITERAL=14;
	public const int Char=15;
	public const int DEC_POST=16;
	public const int DEC_PRE=17;
	public const int DEREF=18;
	public const int DIV=19;
	public const int DO=20;
	public const int ELSE=21;
	public const int EQUAL=22;
	public const int EXPRESSION=23;
	public const int FALSE=24;
	public const int FOR=25;
	public const int FUNC_BODY=26;
	public const int FUNC_CALL=27;
	public const int FUNC_DECL=28;
	public const int FUNC_DEF=29;
	public const int GREATER=30;
	public const int GREATER_OR_EQUAL=31;
	public const int IDENT=32;
	public const int IF=33;
	public const int INCLUDE=34;
	public const int INCLUDE_STRING=35;
	public const int INC_POST=36;
	public const int INC_PRE=37;
	public const int INTEGER=38;
	public const int Identifier=39;
	public const int Int=40;
	public const int Integer=41;
	public const int LESS=42;
	public const int LESS_OR_EQUAL=43;
	public const int LINE_COMMENT=44;
	public const int ML_COMMENT=45;
	public const int MOD=46;
	public const int MUL=47;
	public const int NOT_EQUAL=48;
	public const int PARAM_LIST=49;
	public const int PARAM_SPEC_LIST=50;
	public const int PROGRAM=51;
	public const int REF=52;
	public const int RETURN=53;
	public const int SHIFT_LEFT=54;
	public const int SHIFT_RIGHT=55;
	public const int SIZEOF_EXPR=56;
	public const int SIZEOF_TYPE=57;
	public const int STATEMENT=58;
	public const int STRING=59;
	public const int STRING_LITERAL=60;
	public const int STRUCT_DEREF=61;
	public const int STRUCT_MEMBER=62;
	public const int SUB=63;
	public const int SUBSCRIPT=64;
	public const int SizeOf=65;
	public const int String=66;
	public const int TRUE=67;
	public const int TYPECAST=68;
	public const int TYPE_SPEC=69;
	public const int U_MINUS=70;
	public const int U_PLUS=71;
	public const int VAR_CALL=72;
	public const int VAR_DECL=73;
	public const int VAR_DEF=74;
	public const int VAR_SPEC=75;
	public const int VOID=76;
	public const int Void=77;
	public const int WHILE=78;
	public const int Whitespace=79;

	public SimpleCParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public SimpleCParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return SimpleCParser.tokenNames; } }
	public override string GrammarFileName { get { return "Grammar\\SimpleC.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// Grammar\\SimpleC.g:103:1: public program : ( programStatement )* EOF -> ^( PROGRAM ( programStatement )* ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken EOF2 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> programStatement1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree EOF2_tree = default(CommonTree);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_programStatement=new RewriteRuleSubtreeStream(adaptor,"rule programStatement");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(103, 0);
		try
		{
			// Grammar\\SimpleC.g:103:8: ( ( programStatement )* EOF -> ^( PROGRAM ( programStatement )* ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:104:2: ( programStatement )* EOF
			{
			DebugLocation(104, 2);
			// Grammar\\SimpleC.g:104:2: ( programStatement )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==Char||LA1_0==Int||LA1_0==String||LA1_0==Void||LA1_0==81))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:104:2: programStatement
					{
					DebugLocation(104, 2);
					PushFollow(Follow._programStatement_in_program1109);
					programStatement1=programStatement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_programStatement.Add(programStatement1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(104, 20);
			EOF2=(CommonToken)Match(input,EOF,Follow._EOF_in_program1112); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: programStatement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 105:2: -> ^( PROGRAM ( programStatement )* )
			{
				DebugLocation(105, 5);
				// Grammar\\SimpleC.g:105:5: ^( PROGRAM ( programStatement )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(105, 7);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(105, 15);
				// Grammar\\SimpleC.g:105:15: ( programStatement )*
				while ( stream_programStatement.HasNext )
				{
					DebugLocation(105, 15);
					adaptor.AddChild(root_1, stream_programStatement.NextTree());

				}
				stream_programStatement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(106, 0);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_programStatement();
	partial void LeaveRule_programStatement();

	// $ANTLR start "programStatement"
	// Grammar\\SimpleC.g:108:1: programStatement : ( varDef | funcDecl | funcDef | macroDecl );
	[GrammarRule("programStatement")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> programStatement()
	{
		EnterRule_programStatement();
		EnterRule("programStatement", 2);
		TraceIn("programStatement", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> varDef3 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> funcDecl4 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> funcDef5 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> macroDecl6 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		try { DebugEnterRule(GrammarFileName, "programStatement");
		DebugLocation(108, 0);
		try
		{
			// Grammar\\SimpleC.g:108:17: ( varDef | funcDecl | funcDef | macroDecl )
			int alt2=4;
			try { DebugEnterDecision(2, false);
			try
			{
				alt2 = dfa2.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:109:2: varDef
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(109, 2);
				PushFollow(Follow._varDef_in_programStatement1131);
				varDef3=varDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, varDef3.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:109:11: funcDecl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(109, 11);
				PushFollow(Follow._funcDecl_in_programStatement1135);
				funcDecl4=funcDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcDecl4.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleC.g:109:22: funcDef
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(109, 22);
				PushFollow(Follow._funcDef_in_programStatement1139);
				funcDef5=funcDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcDef5.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleC.g:109:32: macroDecl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(109, 32);
				PushFollow(Follow._macroDecl_in_programStatement1143);
				macroDecl6=macroDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, macroDecl6.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("programStatement", 2);
			LeaveRule("programStatement", 2);
			LeaveRule_programStatement();
		}
		DebugLocation(110, 0);
		} finally { DebugExitRule(GrammarFileName, "programStatement"); }
		return retval;

	}
	// $ANTLR end "programStatement"

	partial void EnterRule_varDef();
	partial void LeaveRule_varDef();

	// $ANTLR start "varDef"
	// Grammar\\SimpleC.g:112:1: varDef : varSpec ';' -> ^( VAR_DEF varSpec ) ;
	[GrammarRule("varDef")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> varDef()
	{
		EnterRule_varDef();
		EnterRule("varDef", 3);
		TraceIn("varDef", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal8 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> varSpec7 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal8_tree = default(CommonTree);
		RewriteRuleITokenStream stream_89=new RewriteRuleITokenStream(adaptor,"token 89");
		RewriteRuleSubtreeStream stream_varSpec=new RewriteRuleSubtreeStream(adaptor,"rule varSpec");
		try { DebugEnterRule(GrammarFileName, "varDef");
		DebugLocation(112, 0);
		try
		{
			// Grammar\\SimpleC.g:112:7: ( varSpec ';' -> ^( VAR_DEF varSpec ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:113:2: varSpec ';'
			{
			DebugLocation(113, 2);
			PushFollow(Follow._varSpec_in_varDef1152);
			varSpec7=varSpec();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_varSpec.Add(varSpec7.Tree);
			DebugLocation(113, 10);
			char_literal8=(CommonToken)Match(input,89,Follow._89_in_varDef1154); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_89.Add(char_literal8);



			{
			// AST REWRITE
			// elements: varSpec
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 114:3: -> ^( VAR_DEF varSpec )
			{
				DebugLocation(114, 6);
				// Grammar\\SimpleC.g:114:6: ^( VAR_DEF varSpec )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(114, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VAR_DEF, "VAR_DEF"), root_1);

				DebugLocation(114, 16);
				adaptor.AddChild(root_1, stream_varSpec.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("varDef", 3);
			LeaveRule("varDef", 3);
			LeaveRule_varDef();
		}
		DebugLocation(115, 0);
		} finally { DebugExitRule(GrammarFileName, "varDef"); }
		return retval;

	}
	// $ANTLR end "varDef"

	partial void EnterRule_funcDecl();
	partial void LeaveRule_funcDecl();

	// $ANTLR start "funcDecl"
	// Grammar\\SimpleC.g:117:1: funcDecl : typeSpec identifier '(' paramSpecList ')' ';' -> ^( FUNC_DECL typeSpec identifier paramSpecList ) ;
	[GrammarRule("funcDecl")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> funcDecl()
	{
		EnterRule_funcDecl();
		EnterRule("funcDecl", 4);
		TraceIn("funcDecl", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal11 = default(CommonToken);
		CommonToken char_literal13 = default(CommonToken);
		CommonToken char_literal14 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec9 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> identifier10 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> paramSpecList12 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal11_tree = default(CommonTree);
		CommonTree char_literal13_tree = default(CommonTree);
		CommonTree char_literal14_tree = default(CommonTree);
		RewriteRuleITokenStream stream_82=new RewriteRuleITokenStream(adaptor,"token 82");
		RewriteRuleITokenStream stream_83=new RewriteRuleITokenStream(adaptor,"token 83");
		RewriteRuleITokenStream stream_89=new RewriteRuleITokenStream(adaptor,"token 89");
		RewriteRuleSubtreeStream stream_paramSpecList=new RewriteRuleSubtreeStream(adaptor,"rule paramSpecList");
		RewriteRuleSubtreeStream stream_typeSpec=new RewriteRuleSubtreeStream(adaptor,"rule typeSpec");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "funcDecl");
		DebugLocation(117, 0);
		try
		{
			// Grammar\\SimpleC.g:117:9: ( typeSpec identifier '(' paramSpecList ')' ';' -> ^( FUNC_DECL typeSpec identifier paramSpecList ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:118:2: typeSpec identifier '(' paramSpecList ')' ';'
			{
			DebugLocation(118, 2);
			PushFollow(Follow._typeSpec_in_funcDecl1174);
			typeSpec9=typeSpec();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeSpec.Add(typeSpec9.Tree);
			DebugLocation(118, 11);
			PushFollow(Follow._identifier_in_funcDecl1176);
			identifier10=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier10.Tree);
			DebugLocation(118, 22);
			char_literal11=(CommonToken)Match(input,82,Follow._82_in_funcDecl1178); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_82.Add(char_literal11);

			DebugLocation(118, 26);
			PushFollow(Follow._paramSpecList_in_funcDecl1180);
			paramSpecList12=paramSpecList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_paramSpecList.Add(paramSpecList12.Tree);
			DebugLocation(118, 40);
			char_literal13=(CommonToken)Match(input,83,Follow._83_in_funcDecl1182); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_83.Add(char_literal13);

			DebugLocation(118, 43);
			char_literal14=(CommonToken)Match(input,89,Follow._89_in_funcDecl1183); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_89.Add(char_literal14);



			{
			// AST REWRITE
			// elements: identifier, paramSpecList, typeSpec
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 119:3: -> ^( FUNC_DECL typeSpec identifier paramSpecList )
			{
				DebugLocation(119, 6);
				// Grammar\\SimpleC.g:119:6: ^( FUNC_DECL typeSpec identifier paramSpecList )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(119, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC_DECL, "FUNC_DECL"), root_1);

				DebugLocation(119, 18);
				adaptor.AddChild(root_1, stream_typeSpec.NextTree());
				DebugLocation(119, 27);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(119, 38);
				adaptor.AddChild(root_1, stream_paramSpecList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcDecl", 4);
			LeaveRule("funcDecl", 4);
			LeaveRule_funcDecl();
		}
		DebugLocation(120, 0);
		} finally { DebugExitRule(GrammarFileName, "funcDecl"); }
		return retval;

	}
	// $ANTLR end "funcDecl"

	partial void EnterRule_funcDef();
	partial void LeaveRule_funcDef();

	// $ANTLR start "funcDef"
	// Grammar\\SimpleC.g:122:1: funcDef : typeSpec identifier '(' paramSpecList ')' '{' funcBody '}' -> ^( FUNC_DEF typeSpec identifier paramSpecList funcBody ) ;
	[GrammarRule("funcDef")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> funcDef()
	{
		EnterRule_funcDef();
		EnterRule("funcDef", 5);
		TraceIn("funcDef", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal17 = default(CommonToken);
		CommonToken char_literal19 = default(CommonToken);
		CommonToken char_literal20 = default(CommonToken);
		CommonToken char_literal22 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec15 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> identifier16 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> paramSpecList18 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> funcBody21 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal17_tree = default(CommonTree);
		CommonTree char_literal19_tree = default(CommonTree);
		CommonTree char_literal20_tree = default(CommonTree);
		CommonTree char_literal22_tree = default(CommonTree);
		RewriteRuleITokenStream stream_93=new RewriteRuleITokenStream(adaptor,"token 93");
		RewriteRuleITokenStream stream_92=new RewriteRuleITokenStream(adaptor,"token 92");
		RewriteRuleITokenStream stream_82=new RewriteRuleITokenStream(adaptor,"token 82");
		RewriteRuleITokenStream stream_83=new RewriteRuleITokenStream(adaptor,"token 83");
		RewriteRuleSubtreeStream stream_paramSpecList=new RewriteRuleSubtreeStream(adaptor,"rule paramSpecList");
		RewriteRuleSubtreeStream stream_typeSpec=new RewriteRuleSubtreeStream(adaptor,"rule typeSpec");
		RewriteRuleSubtreeStream stream_funcBody=new RewriteRuleSubtreeStream(adaptor,"rule funcBody");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "funcDef");
		DebugLocation(122, 0);
		try
		{
			// Grammar\\SimpleC.g:122:8: ( typeSpec identifier '(' paramSpecList ')' '{' funcBody '}' -> ^( FUNC_DEF typeSpec identifier paramSpecList funcBody ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:123:2: typeSpec identifier '(' paramSpecList ')' '{' funcBody '}'
			{
			DebugLocation(123, 2);
			PushFollow(Follow._typeSpec_in_funcDef1207);
			typeSpec15=typeSpec();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeSpec.Add(typeSpec15.Tree);
			DebugLocation(123, 11);
			PushFollow(Follow._identifier_in_funcDef1209);
			identifier16=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier16.Tree);
			DebugLocation(123, 22);
			char_literal17=(CommonToken)Match(input,82,Follow._82_in_funcDef1211); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_82.Add(char_literal17);

			DebugLocation(123, 26);
			PushFollow(Follow._paramSpecList_in_funcDef1213);
			paramSpecList18=paramSpecList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_paramSpecList.Add(paramSpecList18.Tree);
			DebugLocation(123, 40);
			char_literal19=(CommonToken)Match(input,83,Follow._83_in_funcDef1215); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_83.Add(char_literal19);

			DebugLocation(123, 43);
			char_literal20=(CommonToken)Match(input,92,Follow._92_in_funcDef1216); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_92.Add(char_literal20);

			DebugLocation(123, 47);
			PushFollow(Follow._funcBody_in_funcDef1218);
			funcBody21=funcBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_funcBody.Add(funcBody21.Tree);
			DebugLocation(123, 56);
			char_literal22=(CommonToken)Match(input,93,Follow._93_in_funcDef1220); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_93.Add(char_literal22);



			{
			// AST REWRITE
			// elements: identifier, paramSpecList, funcBody, typeSpec
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 124:3: -> ^( FUNC_DEF typeSpec identifier paramSpecList funcBody )
			{
				DebugLocation(124, 6);
				// Grammar\\SimpleC.g:124:6: ^( FUNC_DEF typeSpec identifier paramSpecList funcBody )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(124, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC_DEF, "FUNC_DEF"), root_1);

				DebugLocation(124, 17);
				adaptor.AddChild(root_1, stream_typeSpec.NextTree());
				DebugLocation(124, 26);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(124, 37);
				adaptor.AddChild(root_1, stream_paramSpecList.NextTree());
				DebugLocation(124, 51);
				adaptor.AddChild(root_1, stream_funcBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcDef", 5);
			LeaveRule("funcDef", 5);
			LeaveRule_funcDef();
		}
		DebugLocation(125, 0);
		} finally { DebugExitRule(GrammarFileName, "funcDef"); }
		return retval;

	}
	// $ANTLR end "funcDef"

	partial void EnterRule_macroDecl();
	partial void LeaveRule_macroDecl();

	// $ANTLR start "macroDecl"
	// Grammar\\SimpleC.g:127:1: macroDecl : '#include' (s1= STRING_LITERAL |s2= INCLUDE_STRING ) -> ^( INCLUDE ( $s1)? ( $s2)? ) ;
	[GrammarRule("macroDecl")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> macroDecl()
	{
		EnterRule_macroDecl();
		EnterRule("macroDecl", 6);
		TraceIn("macroDecl", 6);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken s1 = default(CommonToken);
		CommonToken s2 = default(CommonToken);
		CommonToken string_literal23 = default(CommonToken);

		CommonTree s1_tree = default(CommonTree);
		CommonTree s2_tree = default(CommonTree);
		CommonTree string_literal23_tree = default(CommonTree);
		RewriteRuleITokenStream stream_INCLUDE_STRING=new RewriteRuleITokenStream(adaptor,"token INCLUDE_STRING");
		RewriteRuleITokenStream stream_STRING_LITERAL=new RewriteRuleITokenStream(adaptor,"token STRING_LITERAL");
		RewriteRuleITokenStream stream_81=new RewriteRuleITokenStream(adaptor,"token 81");
		try { DebugEnterRule(GrammarFileName, "macroDecl");
		DebugLocation(127, 2);
		try
		{
			// Grammar\\SimpleC.g:127:10: ( '#include' (s1= STRING_LITERAL |s2= INCLUDE_STRING ) -> ^( INCLUDE ( $s1)? ( $s2)? ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:128:3: '#include' (s1= STRING_LITERAL |s2= INCLUDE_STRING )
			{
			DebugLocation(128, 3);
			string_literal23=(CommonToken)Match(input,81,Follow._81_in_macroDecl1247); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_81.Add(string_literal23);

			DebugLocation(128, 14);
			// Grammar\\SimpleC.g:128:14: (s1= STRING_LITERAL |s2= INCLUDE_STRING )
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==STRING_LITERAL))
			{
				alt3 = 1;
			}
			else if ((LA3_0==INCLUDE_STRING))
			{
				alt3 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:128:15: s1= STRING_LITERAL
				{
				DebugLocation(128, 17);
				s1=(CommonToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_macroDecl1252); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STRING_LITERAL.Add(s1);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:128:35: s2= INCLUDE_STRING
				{
				DebugLocation(128, 37);
				s2=(CommonToken)Match(input,INCLUDE_STRING,Follow._INCLUDE_STRING_in_macroDecl1258); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INCLUDE_STRING.Add(s2);


				}
				break;

			}
			} finally { DebugExitSubRule(3); }



			{
			// AST REWRITE
			// elements: s2, s1
			// token labels: s2, s1
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_s2=new RewriteRuleITokenStream(adaptor,"token s2",s2);
			RewriteRuleITokenStream stream_s1=new RewriteRuleITokenStream(adaptor,"token s1",s1);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 128:55: -> ^( INCLUDE ( $s1)? ( $s2)? )
			{
				DebugLocation(128, 59);
				// Grammar\\SimpleC.g:128:59: ^( INCLUDE ( $s1)? ( $s2)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(128, 61);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INCLUDE, "INCLUDE"), root_1);

				DebugLocation(128, 70);
				// Grammar\\SimpleC.g:128:70: ( $s1)?
				if (stream_s1.HasNext)
				{
					DebugLocation(128, 70);
					adaptor.AddChild(root_1, stream_s1.NextNode());

				}
				stream_s1.Reset();
				DebugLocation(128, 75);
				// Grammar\\SimpleC.g:128:75: ( $s2)?
				if (stream_s2.HasNext)
				{
					DebugLocation(128, 75);
					adaptor.AddChild(root_1, stream_s2.NextNode());

				}
				stream_s2.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("macroDecl", 6);
			LeaveRule("macroDecl", 6);
			LeaveRule_macroDecl();
		}
		DebugLocation(129, 2);
		} finally { DebugExitRule(GrammarFileName, "macroDecl"); }
		return retval;

	}
	// $ANTLR end "macroDecl"

	partial void EnterRule_paramSpecList();
	partial void LeaveRule_paramSpecList();

	// $ANTLR start "paramSpecList"
	// Grammar\\SimpleC.g:131:1: paramSpecList : ( varSpec ( ',' varSpec )* )? -> ^( PARAM_SPEC_LIST ( varSpec )* ) ;
	[GrammarRule("paramSpecList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> paramSpecList()
	{
		EnterRule_paramSpecList();
		EnterRule("paramSpecList", 7);
		TraceIn("paramSpecList", 7);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal25 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> varSpec24 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> varSpec26 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal25_tree = default(CommonTree);
		RewriteRuleITokenStream stream_85=new RewriteRuleITokenStream(adaptor,"token 85");
		RewriteRuleSubtreeStream stream_varSpec=new RewriteRuleSubtreeStream(adaptor,"rule varSpec");
		try { DebugEnterRule(GrammarFileName, "paramSpecList");
		DebugLocation(131, 0);
		try
		{
			// Grammar\\SimpleC.g:131:14: ( ( varSpec ( ',' varSpec )* )? -> ^( PARAM_SPEC_LIST ( varSpec )* ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:132:2: ( varSpec ( ',' varSpec )* )?
			{
			DebugLocation(132, 2);
			// Grammar\\SimpleC.g:132:2: ( varSpec ( ',' varSpec )* )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==Char||LA5_0==Int||LA5_0==String||LA5_0==Void))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:132:3: varSpec ( ',' varSpec )*
				{
				DebugLocation(132, 3);
				PushFollow(Follow._varSpec_in_paramSpecList1287);
				varSpec24=varSpec();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_varSpec.Add(varSpec24.Tree);
				DebugLocation(132, 11);
				// Grammar\\SimpleC.g:132:11: ( ',' varSpec )*
				try { DebugEnterSubRule(4);
				while (true)
				{
					int alt4=2;
					try { DebugEnterDecision(4, false);
					int LA4_0 = input.LA(1);

					if ((LA4_0==85))
					{
						alt4 = 1;
					}


					} finally { DebugExitDecision(4); }
					switch ( alt4 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleC.g:132:12: ',' varSpec
						{
						DebugLocation(132, 12);
						char_literal25=(CommonToken)Match(input,85,Follow._85_in_paramSpecList1290); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_85.Add(char_literal25);

						DebugLocation(132, 16);
						PushFollow(Follow._varSpec_in_paramSpecList1292);
						varSpec26=varSpec();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_varSpec.Add(varSpec26.Tree);

						}
						break;

					default:
						goto loop4;
					}
				}

				loop4:
					;

				} finally { DebugExitSubRule(4); }


				}
				break;

			}
			} finally { DebugExitSubRule(5); }



			{
			// AST REWRITE
			// elements: varSpec
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 132:28: -> ^( PARAM_SPEC_LIST ( varSpec )* )
			{
				DebugLocation(132, 31);
				// Grammar\\SimpleC.g:132:31: ^( PARAM_SPEC_LIST ( varSpec )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(132, 33);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PARAM_SPEC_LIST, "PARAM_SPEC_LIST"), root_1);

				DebugLocation(132, 49);
				// Grammar\\SimpleC.g:132:49: ( varSpec )*
				while ( stream_varSpec.HasNext )
				{
					DebugLocation(132, 49);
					adaptor.AddChild(root_1, stream_varSpec.NextTree());

				}
				stream_varSpec.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("paramSpecList", 7);
			LeaveRule("paramSpecList", 7);
			LeaveRule_paramSpecList();
		}
		DebugLocation(133, 0);
		} finally { DebugExitRule(GrammarFileName, "paramSpecList"); }
		return retval;

	}
	// $ANTLR end "paramSpecList"

	partial void EnterRule_funcBody();
	partial void LeaveRule_funcBody();

	// $ANTLR start "funcBody"
	// Grammar\\SimpleC.g:135:1: funcBody : statements -> ^( FUNC_BODY ( statements )? ) ;
	[GrammarRule("funcBody")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> funcBody()
	{
		EnterRule_funcBody();
		EnterRule("funcBody", 8);
		TraceIn("funcBody", 8);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> statements27 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		try { DebugEnterRule(GrammarFileName, "funcBody");
		DebugLocation(135, 0);
		try
		{
			// Grammar\\SimpleC.g:135:9: ( statements -> ^( FUNC_BODY ( statements )? ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:136:2: statements
			{
			DebugLocation(136, 2);
			PushFollow(Follow._statements_in_funcBody1314);
			statements27=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements27.Tree);


			{
			// AST REWRITE
			// elements: statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 136:13: -> ^( FUNC_BODY ( statements )? )
			{
				DebugLocation(136, 16);
				// Grammar\\SimpleC.g:136:16: ^( FUNC_BODY ( statements )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(136, 18);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC_BODY, "FUNC_BODY"), root_1);

				DebugLocation(136, 28);
				// Grammar\\SimpleC.g:136:28: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(136, 28);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcBody", 8);
			LeaveRule("funcBody", 8);
			LeaveRule_funcBody();
		}
		DebugLocation(137, 0);
		} finally { DebugExitRule(GrammarFileName, "funcBody"); }
		return retval;

	}
	// $ANTLR end "funcBody"

	partial void EnterRule_statements();
	partial void LeaveRule_statements();

	// $ANTLR start "statements"
	// Grammar\\SimpleC.g:139:1: statements : ( statement )* ;
	[GrammarRule("statements")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> statements()
	{
		EnterRule_statements();
		EnterRule("statements", 9);
		TraceIn("statements", 9);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> statement28 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		try { DebugEnterRule(GrammarFileName, "statements");
		DebugLocation(139, 0);
		try
		{
			// Grammar\\SimpleC.g:139:11: ( ( statement )* )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:140:2: ( statement )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(140, 2);
			// Grammar\\SimpleC.g:140:2: ( statement )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==ADD||LA6_0==BIT_AND||(LA6_0>=CHARACTER_LITERAL && LA6_0<=Char)||LA6_0==DO||LA6_0==IF||(LA6_0>=Identifier && LA6_0<=Integer)||LA6_0==MUL||LA6_0==RETURN||LA6_0==STRING_LITERAL||LA6_0==SUB||(LA6_0>=SizeOf && LA6_0<=String)||(LA6_0>=Void && LA6_0<=WHILE)||LA6_0==80||LA6_0==82||LA6_0==84||LA6_0==86||LA6_0==89||LA6_0==92||LA6_0==94))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:140:2: statement
					{
					DebugLocation(140, 2);
					PushFollow(Follow._statement_in_statements1332);
					statement28=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, statement28.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statements", 9);
			LeaveRule("statements", 9);
			LeaveRule_statements();
		}
		DebugLocation(141, 0);
		} finally { DebugExitRule(GrammarFileName, "statements"); }
		return retval;

	}
	// $ANTLR end "statements"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// Grammar\\SimpleC.g:143:1: statement : ( varDef | ( expr )? ';' -> ^( STATEMENT ( expr )? ) | '{' statements '}' -> ^( STATEMENT ( statements )? ) );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 10);
		TraceIn("statement", 10);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal31 = default(CommonToken);
		CommonToken char_literal32 = default(CommonToken);
		CommonToken char_literal34 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> varDef29 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr30 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> statements33 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal31_tree = default(CommonTree);
		CommonTree char_literal32_tree = default(CommonTree);
		CommonTree char_literal34_tree = default(CommonTree);
		RewriteRuleITokenStream stream_93=new RewriteRuleITokenStream(adaptor,"token 93");
		RewriteRuleITokenStream stream_92=new RewriteRuleITokenStream(adaptor,"token 92");
		RewriteRuleITokenStream stream_89=new RewriteRuleITokenStream(adaptor,"token 89");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(143, 0);
		try
		{
			// Grammar\\SimpleC.g:143:10: ( varDef | ( expr )? ';' -> ^( STATEMENT ( expr )? ) | '{' statements '}' -> ^( STATEMENT ( statements )? ) )
			int alt8=3;
			try { DebugEnterDecision(8, false);
			switch (input.LA(1))
			{
			case Char:
			case Int:
			case String:
			case Void:
				{
				alt8 = 1;
				}
				break;
			case ADD:
			case BIT_AND:
			case CHARACTER_LITERAL:
			case DO:
			case IF:
			case Identifier:
			case Integer:
			case MUL:
			case RETURN:
			case STRING_LITERAL:
			case SUB:
			case SizeOf:
			case WHILE:
			case 80:
			case 82:
			case 84:
			case 86:
			case 89:
			case 94:
				{
				alt8 = 2;
				}
				break;
			case 92:
				{
				alt8 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:144:2: varDef
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(144, 2);
				PushFollow(Follow._varDef_in_statement1342);
				varDef29=varDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, varDef29.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:145:4: ( expr )? ';'
				{
				DebugLocation(145, 4);
				// Grammar\\SimpleC.g:145:4: ( expr )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==ADD||LA7_0==BIT_AND||LA7_0==CHARACTER_LITERAL||LA7_0==DO||LA7_0==IF||LA7_0==Identifier||LA7_0==Integer||LA7_0==MUL||LA7_0==RETURN||LA7_0==STRING_LITERAL||LA7_0==SUB||LA7_0==SizeOf||LA7_0==WHILE||LA7_0==80||LA7_0==82||LA7_0==84||LA7_0==86||LA7_0==94))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:145:4: expr
					{
					DebugLocation(145, 4);
					PushFollow(Follow._expr_in_statement1347);
					expr30=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr.Add(expr30.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(7); }

				DebugLocation(145, 10);
				char_literal31=(CommonToken)Match(input,89,Follow._89_in_statement1350); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_89.Add(char_literal31);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 145:14: -> ^( STATEMENT ( expr )? )
				{
					DebugLocation(145, 17);
					// Grammar\\SimpleC.g:145:17: ^( STATEMENT ( expr )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(145, 19);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(STATEMENT, "STATEMENT"), root_1);

					DebugLocation(145, 29);
					// Grammar\\SimpleC.g:145:29: ( expr )?
					if (stream_expr.HasNext)
					{
						DebugLocation(145, 29);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleC.g:146:4: '{' statements '}'
				{
				DebugLocation(146, 4);
				char_literal32=(CommonToken)Match(input,92,Follow._92_in_statement1364); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_92.Add(char_literal32);

				DebugLocation(146, 8);
				PushFollow(Follow._statements_in_statement1366);
				statements33=statements();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statements.Add(statements33.Tree);
				DebugLocation(146, 19);
				char_literal34=(CommonToken)Match(input,93,Follow._93_in_statement1368); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_93.Add(char_literal34);



				{
				// AST REWRITE
				// elements: statements
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 146:23: -> ^( STATEMENT ( statements )? )
				{
					DebugLocation(146, 26);
					// Grammar\\SimpleC.g:146:26: ^( STATEMENT ( statements )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(146, 28);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(STATEMENT, "STATEMENT"), root_1);

					DebugLocation(146, 38);
					// Grammar\\SimpleC.g:146:38: ( statements )?
					if (stream_statements.HasNext)
					{
						DebugLocation(146, 38);
						adaptor.AddChild(root_1, stream_statements.NextTree());

					}
					stream_statements.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 10);
			LeaveRule("statement", 10);
			LeaveRule_statement();
		}
		DebugLocation(147, 0);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_varSpec();
	partial void LeaveRule_varSpec();

	// $ANTLR start "varSpec"
	// Grammar\\SimpleC.g:149:1: varSpec : typeSpec identifier -> ^( VAR_SPEC typeSpec identifier ) ;
	[GrammarRule("varSpec")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> varSpec()
	{
		EnterRule_varSpec();
		EnterRule("varSpec", 11);
		TraceIn("varSpec", 11);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec35 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> identifier36 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		RewriteRuleSubtreeStream stream_typeSpec=new RewriteRuleSubtreeStream(adaptor,"rule typeSpec");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "varSpec");
		DebugLocation(149, 0);
		try
		{
			// Grammar\\SimpleC.g:149:8: ( typeSpec identifier -> ^( VAR_SPEC typeSpec identifier ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:150:5: typeSpec identifier
			{
			DebugLocation(150, 5);
			PushFollow(Follow._typeSpec_in_varSpec1389);
			typeSpec35=typeSpec();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeSpec.Add(typeSpec35.Tree);
			DebugLocation(150, 14);
			PushFollow(Follow._identifier_in_varSpec1391);
			identifier36=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier36.Tree);


			{
			// AST REWRITE
			// elements: typeSpec, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 151:3: -> ^( VAR_SPEC typeSpec identifier )
			{
				DebugLocation(151, 6);
				// Grammar\\SimpleC.g:151:6: ^( VAR_SPEC typeSpec identifier )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(151, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VAR_SPEC, "VAR_SPEC"), root_1);

				DebugLocation(151, 17);
				adaptor.AddChild(root_1, stream_typeSpec.NextTree());
				DebugLocation(151, 26);
				adaptor.AddChild(root_1, stream_identifier.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("varSpec", 11);
			LeaveRule("varSpec", 11);
			LeaveRule_varSpec();
		}
		DebugLocation(152, 0);
		} finally { DebugExitRule(GrammarFileName, "varSpec"); }
		return retval;

	}
	// $ANTLR end "varSpec"

	partial void EnterRule_typeSpec();
	partial void LeaveRule_typeSpec();

	// $ANTLR start "typeSpec"
	// Grammar\\SimpleC.g:154:1: typeSpec : (tn= Int |tn= Void |tn= String |tn= Char ) -> ^( TYPE_SPEC ) ;
	[GrammarRule("typeSpec")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec()
	{
		EnterRule_typeSpec();
		EnterRule("typeSpec", 12);
		TraceIn("typeSpec", 12);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken tn = default(CommonToken);

		CommonTree tn_tree = default(CommonTree);
		RewriteRuleITokenStream stream_String=new RewriteRuleITokenStream(adaptor,"token String");
		RewriteRuleITokenStream stream_Void=new RewriteRuleITokenStream(adaptor,"token Void");
		RewriteRuleITokenStream stream_Char=new RewriteRuleITokenStream(adaptor,"token Char");
		RewriteRuleITokenStream stream_Int=new RewriteRuleITokenStream(adaptor,"token Int");
		try { DebugEnterRule(GrammarFileName, "typeSpec");
		DebugLocation(154, 0);
		try
		{
			// Grammar\\SimpleC.g:154:9: ( (tn= Int |tn= Void |tn= String |tn= Char ) -> ^( TYPE_SPEC ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:155:2: (tn= Int |tn= Void |tn= String |tn= Char )
			{
			DebugLocation(155, 2);
			// Grammar\\SimpleC.g:155:2: (tn= Int |tn= Void |tn= String |tn= Char )
			int alt9=4;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			switch (input.LA(1))
			{
			case Int:
				{
				alt9 = 1;
				}
				break;
			case Void:
				{
				alt9 = 2;
				}
				break;
			case String:
				{
				alt9 = 3;
				}
				break;
			case Char:
				{
				alt9 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:155:3: tn= Int
				{
				DebugLocation(155, 5);
				tn=(CommonToken)Match(input,Int,Follow._Int_in_typeSpec1415); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Int.Add(tn);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:155:12: tn= Void
				{
				DebugLocation(155, 14);
				tn=(CommonToken)Match(input,Void,Follow._Void_in_typeSpec1421); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Void.Add(tn);


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleC.g:155:22: tn= String
				{
				DebugLocation(155, 24);
				tn=(CommonToken)Match(input,String,Follow._String_in_typeSpec1427); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_String.Add(tn);


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleC.g:155:34: tn= Char
				{
				DebugLocation(155, 36);
				tn=(CommonToken)Match(input,Char,Follow._Char_in_typeSpec1433); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Char.Add(tn);


				}
				break;

			}
			} finally { DebugExitSubRule(9); }



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 155:43: -> ^( TYPE_SPEC )
			{
				DebugLocation(155, 46);
				// Grammar\\SimpleC.g:155:46: ^( TYPE_SPEC )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(155, 48);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE_SPEC, "TYPE_SPEC"), root_1);

				DebugLocation(155, 58);
				adaptor.AddChild(root_1,  adaptor.BecomeRoot(new CommonToken(IDENT, tn.Text), adaptor.Nil()) );

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeSpec", 12);
			LeaveRule("typeSpec", 12);
			LeaveRule_typeSpec();
		}
		DebugLocation(156, 0);
		} finally { DebugExitRule(GrammarFileName, "typeSpec"); }
		return retval;

	}
	// $ANTLR end "typeSpec"

	partial void EnterRule_paramList();
	partial void LeaveRule_paramList();

	// $ANTLR start "paramList"
	// Grammar\\SimpleC.g:158:1: paramList : ( expr ( ',' expr )* )? -> ^( PARAM_LIST ( expr )* ) ;
	[GrammarRule("paramList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> paramList()
	{
		EnterRule_paramList();
		EnterRule("paramList", 13);
		TraceIn("paramList", 13);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal38 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr37 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr39 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal38_tree = default(CommonTree);
		RewriteRuleITokenStream stream_85=new RewriteRuleITokenStream(adaptor,"token 85");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "paramList");
		DebugLocation(158, 0);
		try
		{
			// Grammar\\SimpleC.g:158:10: ( ( expr ( ',' expr )* )? -> ^( PARAM_LIST ( expr )* ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:159:2: ( expr ( ',' expr )* )?
			{
			DebugLocation(159, 2);
			// Grammar\\SimpleC.g:159:2: ( expr ( ',' expr )* )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==ADD||LA11_0==BIT_AND||LA11_0==CHARACTER_LITERAL||LA11_0==DO||LA11_0==IF||LA11_0==Identifier||LA11_0==Integer||LA11_0==MUL||LA11_0==RETURN||LA11_0==STRING_LITERAL||LA11_0==SUB||LA11_0==SizeOf||LA11_0==WHILE||LA11_0==80||LA11_0==82||LA11_0==84||LA11_0==86||LA11_0==94))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:159:3: expr ( ',' expr )*
				{
				DebugLocation(159, 3);
				PushFollow(Follow._expr_in_paramList1452);
				expr37=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr37.Tree);
				DebugLocation(159, 8);
				// Grammar\\SimpleC.g:159:8: ( ',' expr )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_0 = input.LA(1);

					if ((LA10_0==85))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleC.g:159:9: ',' expr
						{
						DebugLocation(159, 9);
						char_literal38=(CommonToken)Match(input,85,Follow._85_in_paramList1455); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_85.Add(char_literal38);

						DebugLocation(159, 13);
						PushFollow(Follow._expr_in_paramList1457);
						expr39=expr();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expr.Add(expr39.Tree);

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }


				}
				break;

			}
			} finally { DebugExitSubRule(11); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 159:22: -> ^( PARAM_LIST ( expr )* )
			{
				DebugLocation(159, 25);
				// Grammar\\SimpleC.g:159:25: ^( PARAM_LIST ( expr )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(159, 27);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PARAM_LIST, "PARAM_LIST"), root_1);

				DebugLocation(159, 38);
				// Grammar\\SimpleC.g:159:38: ( expr )*
				while ( stream_expr.HasNext )
				{
					DebugLocation(159, 38);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("paramList", 13);
			LeaveRule("paramList", 13);
			LeaveRule_paramList();
		}
		DebugLocation(160, 0);
		} finally { DebugExitRule(GrammarFileName, "paramList"); }
		return retval;

	}
	// $ANTLR end "paramList"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// Grammar\\SimpleC.g:162:1: expr : ( binaryExpr | IF ^ '(' ! basicExpr ')' ! expr ( ELSE ! expr )? | WHILE ^ '(' ! basicExpr ')' ! expr | DO ^ expr WHILE ! basicExpr | RETURN ^ basicExpr ';' !);
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 14);
		TraceIn("expr", 14);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken IF41 = default(CommonToken);
		CommonToken char_literal42 = default(CommonToken);
		CommonToken char_literal44 = default(CommonToken);
		CommonToken ELSE46 = default(CommonToken);
		CommonToken WHILE48 = default(CommonToken);
		CommonToken char_literal49 = default(CommonToken);
		CommonToken char_literal51 = default(CommonToken);
		CommonToken DO53 = default(CommonToken);
		CommonToken WHILE55 = default(CommonToken);
		CommonToken RETURN57 = default(CommonToken);
		CommonToken char_literal59 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> binaryExpr40 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> basicExpr43 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr45 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr47 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> basicExpr50 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr52 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr54 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> basicExpr56 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> basicExpr58 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree IF41_tree = default(CommonTree);
		CommonTree char_literal42_tree = default(CommonTree);
		CommonTree char_literal44_tree = default(CommonTree);
		CommonTree ELSE46_tree = default(CommonTree);
		CommonTree WHILE48_tree = default(CommonTree);
		CommonTree char_literal49_tree = default(CommonTree);
		CommonTree char_literal51_tree = default(CommonTree);
		CommonTree DO53_tree = default(CommonTree);
		CommonTree WHILE55_tree = default(CommonTree);
		CommonTree RETURN57_tree = default(CommonTree);
		CommonTree char_literal59_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(162, 0);
		try
		{
			// Grammar\\SimpleC.g:162:5: ( binaryExpr | IF ^ '(' ! basicExpr ')' ! expr ( ELSE ! expr )? | WHILE ^ '(' ! basicExpr ')' ! expr | DO ^ expr WHILE ! basicExpr | RETURN ^ basicExpr ';' !)
			int alt13=5;
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case ADD:
			case BIT_AND:
			case CHARACTER_LITERAL:
			case Identifier:
			case Integer:
			case MUL:
			case STRING_LITERAL:
			case SUB:
			case SizeOf:
			case 80:
			case 82:
			case 84:
			case 86:
			case 94:
				{
				alt13 = 1;
				}
				break;
			case IF:
				{
				alt13 = 2;
				}
				break;
			case WHILE:
				{
				alt13 = 3;
				}
				break;
			case DO:
				{
				alt13 = 4;
				}
				break;
			case RETURN:
				{
				alt13 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:163:2: binaryExpr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(163, 2);
				PushFollow(Follow._binaryExpr_in_expr1479);
				binaryExpr40=binaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, binaryExpr40.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:164:4: IF ^ '(' ! basicExpr ')' ! expr ( ELSE ! expr )?
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(164, 6);
				IF41=(CommonToken)Match(input,IF,Follow._IF_in_expr1484); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IF41_tree = (CommonTree)adaptor.Create(IF41);
				root_0 = (CommonTree)adaptor.BecomeRoot(IF41_tree, root_0);
				}
				DebugLocation(164, 11);
				char_literal42=(CommonToken)Match(input,82,Follow._82_in_expr1487); if (state.failed) return retval;
				DebugLocation(164, 13);
				PushFollow(Follow._basicExpr_in_expr1490);
				basicExpr43=basicExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, basicExpr43.Tree);
				DebugLocation(164, 26);
				char_literal44=(CommonToken)Match(input,83,Follow._83_in_expr1492); if (state.failed) return retval;
				DebugLocation(164, 28);
				PushFollow(Follow._expr_in_expr1495);
				expr45=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr45.Tree);
				DebugLocation(164, 33);
				// Grammar\\SimpleC.g:164:33: ( ELSE ! expr )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==ELSE))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:164:34: ELSE ! expr
					{
					DebugLocation(164, 38);
					ELSE46=(CommonToken)Match(input,ELSE,Follow._ELSE_in_expr1498); if (state.failed) return retval;
					DebugLocation(164, 40);
					PushFollow(Follow._expr_in_expr1501);
					expr47=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr47.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(12); }


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleC.g:165:4: WHILE ^ '(' ! basicExpr ')' ! expr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(165, 9);
				WHILE48=(CommonToken)Match(input,WHILE,Follow._WHILE_in_expr1508); if (state.failed) return retval;
				if (state.backtracking == 0) {
				WHILE48_tree = (CommonTree)adaptor.Create(WHILE48);
				root_0 = (CommonTree)adaptor.BecomeRoot(WHILE48_tree, root_0);
				}
				DebugLocation(165, 14);
				char_literal49=(CommonToken)Match(input,82,Follow._82_in_expr1511); if (state.failed) return retval;
				DebugLocation(165, 16);
				PushFollow(Follow._basicExpr_in_expr1514);
				basicExpr50=basicExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, basicExpr50.Tree);
				DebugLocation(165, 29);
				char_literal51=(CommonToken)Match(input,83,Follow._83_in_expr1516); if (state.failed) return retval;
				DebugLocation(165, 31);
				PushFollow(Follow._expr_in_expr1519);
				expr52=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr52.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleC.g:166:4: DO ^ expr WHILE ! basicExpr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(166, 6);
				DO53=(CommonToken)Match(input,DO,Follow._DO_in_expr1524); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DO53_tree = (CommonTree)adaptor.Create(DO53);
				root_0 = (CommonTree)adaptor.BecomeRoot(DO53_tree, root_0);
				}
				DebugLocation(166, 8);
				PushFollow(Follow._expr_in_expr1527);
				expr54=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr54.Tree);
				DebugLocation(166, 18);
				WHILE55=(CommonToken)Match(input,WHILE,Follow._WHILE_in_expr1529); if (state.failed) return retval;
				DebugLocation(166, 20);
				PushFollow(Follow._basicExpr_in_expr1532);
				basicExpr56=basicExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, basicExpr56.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammar\\SimpleC.g:167:4: RETURN ^ basicExpr ';' !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(167, 10);
				RETURN57=(CommonToken)Match(input,RETURN,Follow._RETURN_in_expr1537); if (state.failed) return retval;
				if (state.backtracking == 0) {
				RETURN57_tree = (CommonTree)adaptor.Create(RETURN57);
				root_0 = (CommonTree)adaptor.BecomeRoot(RETURN57_tree, root_0);
				}
				DebugLocation(167, 12);
				PushFollow(Follow._basicExpr_in_expr1540);
				basicExpr58=basicExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, basicExpr58.Tree);
				DebugLocation(167, 25);
				char_literal59=(CommonToken)Match(input,89,Follow._89_in_expr1542); if (state.failed) return retval;

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 14);
			LeaveRule("expr", 14);
			LeaveRule_expr();
		}
		DebugLocation(168, 0);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_binaryExpr();
	partial void LeaveRule_binaryExpr();

	// $ANTLR start "binaryExpr"
	// Grammar\\SimpleC.g:170:1: binaryExpr : left= unaryExpr (op= binaryOperator right= unaryExpr )* ;
	[GrammarRule("binaryExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> binaryExpr()
	{
		EnterRule_binaryExpr();
		EnterRule("binaryExpr", 15);
		TraceIn("binaryExpr", 15);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> left = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> op = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> right = default(AstParserRuleReturnScope<CommonTree, CommonToken>);


			List<ITree> expressions = new List<ITree>();
			List<IToken> operators = new List<IToken>();

		try { DebugEnterRule(GrammarFileName, "binaryExpr");
		DebugLocation(170, 0);
		try
		{
			// Grammar\\SimpleC.g:174:3: (left= unaryExpr (op= binaryOperator right= unaryExpr )* )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:175:2: left= unaryExpr (op= binaryOperator right= unaryExpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(175, 6);
			PushFollow(Follow._unaryExpr_in_binaryExpr1560);
			left=unaryExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, left.Tree);
			DebugLocation(175, 17);
			if (state.backtracking == 0)
			{
				 expressions.Add((ITree)left.Tree); 
			}
			DebugLocation(176, 2);
			// Grammar\\SimpleC.g:176:2: (op= binaryOperator right= unaryExpr )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if (((LA14_0>=ADD && LA14_0<=ASSIGN)||LA14_0==DIV||(LA14_0>=MOD && LA14_0<=MUL)||LA14_0==SUB))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:176:3: op= binaryOperator right= unaryExpr
					{
					DebugLocation(176, 5);
					PushFollow(Follow._binaryOperator_in_binaryExpr1568);
					op=binaryOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, op.Tree);
					DebugLocation(176, 26);
					PushFollow(Follow._unaryExpr_in_binaryExpr1572);
					right=unaryExpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, right.Tree);
					DebugLocation(176, 37);
					if (state.backtracking == 0)
					{

								operators.Add(((CommonTree)op.Tree).Token);
								expressions.Add((ITree)right.Tree);
							
					}

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("binaryExpr", 15);
			LeaveRule("binaryExpr", 15);
			LeaveRule_binaryExpr();
		}
		DebugLocation(180, 0);
		} finally { DebugExitRule(GrammarFileName, "binaryExpr"); }
		return retval;

	}
	// $ANTLR end "binaryExpr"

	partial void EnterRule_unaryExpr();
	partial void LeaveRule_unaryExpr();

	// $ANTLR start "unaryExpr"
	// Grammar\\SimpleC.g:182:1: unaryExpr options {backtrack=true; } : ( '*' unaryExpr -> ^( DEREF unaryExpr ) | '&' unaryExpr -> ^( REF unaryExpr ) | '+' unaryExpr -> ^( U_PLUS unaryExpr ) | '-' unaryExpr -> ^( U_MINUS unaryExpr ) | '!' unaryExpr -> ^( BOOL_NOT unaryExpr ) | '~' unaryExpr -> ^( BIT_NOT unaryExpr ) | '++' unaryExpr -> ^( INC_PRE unaryExpr ) | '--' unaryExpr -> ^( DEC_PRE unaryExpr ) | '(' typeSpec ')' unaryExpr -> ^( TYPECAST unaryExpr typeSpec ) | SizeOf unaryExpr -> ^( SIZEOF_EXPR unaryExpr ) | SizeOf '(' typeSpec ')' -> ^( SIZEOF_TYPE typeSpec ) | primaryExpr );
	[GrammarRule("unaryExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr()
	{
		EnterRule_unaryExpr();
		EnterRule("unaryExpr", 16);
		TraceIn("unaryExpr", 16);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal60 = default(CommonToken);
		CommonToken char_literal62 = default(CommonToken);
		CommonToken char_literal64 = default(CommonToken);
		CommonToken char_literal66 = default(CommonToken);
		CommonToken char_literal68 = default(CommonToken);
		CommonToken char_literal70 = default(CommonToken);
		CommonToken string_literal72 = default(CommonToken);
		CommonToken string_literal74 = default(CommonToken);
		CommonToken char_literal76 = default(CommonToken);
		CommonToken char_literal78 = default(CommonToken);
		CommonToken SizeOf80 = default(CommonToken);
		CommonToken SizeOf82 = default(CommonToken);
		CommonToken char_literal83 = default(CommonToken);
		CommonToken char_literal85 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr61 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr63 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr65 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr67 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr69 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr71 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr73 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr75 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec77 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr79 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr81 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec84 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> primaryExpr86 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal60_tree = default(CommonTree);
		CommonTree char_literal62_tree = default(CommonTree);
		CommonTree char_literal64_tree = default(CommonTree);
		CommonTree char_literal66_tree = default(CommonTree);
		CommonTree char_literal68_tree = default(CommonTree);
		CommonTree char_literal70_tree = default(CommonTree);
		CommonTree string_literal72_tree = default(CommonTree);
		CommonTree string_literal74_tree = default(CommonTree);
		CommonTree char_literal76_tree = default(CommonTree);
		CommonTree char_literal78_tree = default(CommonTree);
		CommonTree SizeOf80_tree = default(CommonTree);
		CommonTree SizeOf82_tree = default(CommonTree);
		CommonTree char_literal83_tree = default(CommonTree);
		CommonTree char_literal85_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SUB=new RewriteRuleITokenStream(adaptor,"token SUB");
		RewriteRuleITokenStream stream_94=new RewriteRuleITokenStream(adaptor,"token 94");
		RewriteRuleITokenStream stream_SizeOf=new RewriteRuleITokenStream(adaptor,"token SizeOf");
		RewriteRuleITokenStream stream_BIT_AND=new RewriteRuleITokenStream(adaptor,"token BIT_AND");
		RewriteRuleITokenStream stream_82=new RewriteRuleITokenStream(adaptor,"token 82");
		RewriteRuleITokenStream stream_83=new RewriteRuleITokenStream(adaptor,"token 83");
		RewriteRuleITokenStream stream_80=new RewriteRuleITokenStream(adaptor,"token 80");
		RewriteRuleITokenStream stream_MUL=new RewriteRuleITokenStream(adaptor,"token MUL");
		RewriteRuleITokenStream stream_86=new RewriteRuleITokenStream(adaptor,"token 86");
		RewriteRuleITokenStream stream_84=new RewriteRuleITokenStream(adaptor,"token 84");
		RewriteRuleITokenStream stream_ADD=new RewriteRuleITokenStream(adaptor,"token ADD");
		RewriteRuleSubtreeStream stream_unaryExpr=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpr");
		RewriteRuleSubtreeStream stream_typeSpec=new RewriteRuleSubtreeStream(adaptor,"rule typeSpec");
		try { DebugEnterRule(GrammarFileName, "unaryExpr");
		DebugLocation(182, 0);
		try
		{
			// Grammar\\SimpleC.g:184:3: ( '*' unaryExpr -> ^( DEREF unaryExpr ) | '&' unaryExpr -> ^( REF unaryExpr ) | '+' unaryExpr -> ^( U_PLUS unaryExpr ) | '-' unaryExpr -> ^( U_MINUS unaryExpr ) | '!' unaryExpr -> ^( BOOL_NOT unaryExpr ) | '~' unaryExpr -> ^( BIT_NOT unaryExpr ) | '++' unaryExpr -> ^( INC_PRE unaryExpr ) | '--' unaryExpr -> ^( DEC_PRE unaryExpr ) | '(' typeSpec ')' unaryExpr -> ^( TYPECAST unaryExpr typeSpec ) | SizeOf unaryExpr -> ^( SIZEOF_EXPR unaryExpr ) | SizeOf '(' typeSpec ')' -> ^( SIZEOF_TYPE typeSpec ) | primaryExpr )
			int alt15=12;
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case MUL:
				{
				alt15 = 1;
				}
				break;
			case BIT_AND:
				{
				alt15 = 2;
				}
				break;
			case ADD:
				{
				alt15 = 3;
				}
				break;
			case SUB:
				{
				alt15 = 4;
				}
				break;
			case 80:
				{
				alt15 = 5;
				}
				break;
			case 94:
				{
				alt15 = 6;
				}
				break;
			case 84:
				{
				alt15 = 7;
				}
				break;
			case 86:
				{
				alt15 = 8;
				}
				break;
			case 82:
				{
				int LA15_9 = input.LA(2);

				if ((EvaluatePredicate(synpred9_SimpleC_fragment)))
				{
					alt15 = 9;
				}
				else if ((true))
				{
					alt15 = 12;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 9, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case SizeOf:
				{
				int LA15_10 = input.LA(2);

				if ((EvaluatePredicate(synpred10_SimpleC_fragment)))
				{
					alt15 = 10;
				}
				else if ((EvaluatePredicate(synpred11_SimpleC_fragment)))
				{
					alt15 = 11;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 10, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CHARACTER_LITERAL:
			case Identifier:
			case Integer:
			case STRING_LITERAL:
				{
				alt15 = 12;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:185:2: '*' unaryExpr
				{
				DebugLocation(185, 2);
				char_literal60=(CommonToken)Match(input,MUL,Follow._MUL_in_unaryExpr1596); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MUL.Add(char_literal60);

				DebugLocation(185, 6);
				PushFollow(Follow._unaryExpr_in_unaryExpr1598);
				unaryExpr61=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr61.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 185:16: -> ^( DEREF unaryExpr )
				{
					DebugLocation(185, 19);
					// Grammar\\SimpleC.g:185:19: ^( DEREF unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(185, 21);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DEREF, "DEREF"), root_1);

					DebugLocation(185, 27);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:186:4: '&' unaryExpr
				{
				DebugLocation(186, 4);
				char_literal62=(CommonToken)Match(input,BIT_AND,Follow._BIT_AND_in_unaryExpr1611); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BIT_AND.Add(char_literal62);

				DebugLocation(186, 8);
				PushFollow(Follow._unaryExpr_in_unaryExpr1613);
				unaryExpr63=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr63.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 186:18: -> ^( REF unaryExpr )
				{
					DebugLocation(186, 21);
					// Grammar\\SimpleC.g:186:21: ^( REF unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(186, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REF, "REF"), root_1);

					DebugLocation(186, 27);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleC.g:187:4: '+' unaryExpr
				{
				DebugLocation(187, 4);
				char_literal64=(CommonToken)Match(input,ADD,Follow._ADD_in_unaryExpr1626); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ADD.Add(char_literal64);

				DebugLocation(187, 8);
				PushFollow(Follow._unaryExpr_in_unaryExpr1628);
				unaryExpr65=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr65.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 187:18: -> ^( U_PLUS unaryExpr )
				{
					DebugLocation(187, 21);
					// Grammar\\SimpleC.g:187:21: ^( U_PLUS unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(187, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(U_PLUS, "U_PLUS"), root_1);

					DebugLocation(187, 30);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleC.g:188:4: '-' unaryExpr
				{
				DebugLocation(188, 4);
				char_literal66=(CommonToken)Match(input,SUB,Follow._SUB_in_unaryExpr1641); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SUB.Add(char_literal66);

				DebugLocation(188, 8);
				PushFollow(Follow._unaryExpr_in_unaryExpr1643);
				unaryExpr67=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr67.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 188:18: -> ^( U_MINUS unaryExpr )
				{
					DebugLocation(188, 21);
					// Grammar\\SimpleC.g:188:21: ^( U_MINUS unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(188, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(U_MINUS, "U_MINUS"), root_1);

					DebugLocation(188, 31);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammar\\SimpleC.g:189:4: '!' unaryExpr
				{
				DebugLocation(189, 4);
				char_literal68=(CommonToken)Match(input,80,Follow._80_in_unaryExpr1656); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_80.Add(char_literal68);

				DebugLocation(189, 8);
				PushFollow(Follow._unaryExpr_in_unaryExpr1658);
				unaryExpr69=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr69.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 189:18: -> ^( BOOL_NOT unaryExpr )
				{
					DebugLocation(189, 21);
					// Grammar\\SimpleC.g:189:21: ^( BOOL_NOT unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(189, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BOOL_NOT, "BOOL_NOT"), root_1);

					DebugLocation(189, 32);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammar\\SimpleC.g:190:4: '~' unaryExpr
				{
				DebugLocation(190, 4);
				char_literal70=(CommonToken)Match(input,94,Follow._94_in_unaryExpr1671); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_94.Add(char_literal70);

				DebugLocation(190, 8);
				PushFollow(Follow._unaryExpr_in_unaryExpr1673);
				unaryExpr71=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr71.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 190:18: -> ^( BIT_NOT unaryExpr )
				{
					DebugLocation(190, 21);
					// Grammar\\SimpleC.g:190:21: ^( BIT_NOT unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(190, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BIT_NOT, "BIT_NOT"), root_1);

					DebugLocation(190, 31);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammar\\SimpleC.g:191:4: '++' unaryExpr
				{
				DebugLocation(191, 4);
				string_literal72=(CommonToken)Match(input,84,Follow._84_in_unaryExpr1686); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_84.Add(string_literal72);

				DebugLocation(191, 9);
				PushFollow(Follow._unaryExpr_in_unaryExpr1688);
				unaryExpr73=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr73.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 191:19: -> ^( INC_PRE unaryExpr )
				{
					DebugLocation(191, 22);
					// Grammar\\SimpleC.g:191:22: ^( INC_PRE unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(191, 24);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INC_PRE, "INC_PRE"), root_1);

					DebugLocation(191, 32);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammar\\SimpleC.g:192:4: '--' unaryExpr
				{
				DebugLocation(192, 4);
				string_literal74=(CommonToken)Match(input,86,Follow._86_in_unaryExpr1701); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_86.Add(string_literal74);

				DebugLocation(192, 9);
				PushFollow(Follow._unaryExpr_in_unaryExpr1703);
				unaryExpr75=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr75.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 192:19: -> ^( DEC_PRE unaryExpr )
				{
					DebugLocation(192, 22);
					// Grammar\\SimpleC.g:192:22: ^( DEC_PRE unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(192, 24);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DEC_PRE, "DEC_PRE"), root_1);

					DebugLocation(192, 32);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammar\\SimpleC.g:193:4: '(' typeSpec ')' unaryExpr
				{
				DebugLocation(193, 4);
				char_literal76=(CommonToken)Match(input,82,Follow._82_in_unaryExpr1716); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_82.Add(char_literal76);

				DebugLocation(193, 8);
				PushFollow(Follow._typeSpec_in_unaryExpr1718);
				typeSpec77=typeSpec();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeSpec.Add(typeSpec77.Tree);
				DebugLocation(193, 17);
				char_literal78=(CommonToken)Match(input,83,Follow._83_in_unaryExpr1720); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_83.Add(char_literal78);

				DebugLocation(193, 21);
				PushFollow(Follow._unaryExpr_in_unaryExpr1722);
				unaryExpr79=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr79.Tree);


				{
				// AST REWRITE
				// elements: typeSpec, unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 193:31: -> ^( TYPECAST unaryExpr typeSpec )
				{
					DebugLocation(193, 34);
					// Grammar\\SimpleC.g:193:34: ^( TYPECAST unaryExpr typeSpec )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(193, 36);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPECAST, "TYPECAST"), root_1);

					DebugLocation(193, 45);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());
					DebugLocation(193, 55);
					adaptor.AddChild(root_1, stream_typeSpec.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Grammar\\SimpleC.g:194:4: SizeOf unaryExpr
				{
				DebugLocation(194, 4);
				SizeOf80=(CommonToken)Match(input,SizeOf,Follow._SizeOf_in_unaryExpr1737); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SizeOf.Add(SizeOf80);

				DebugLocation(194, 11);
				PushFollow(Follow._unaryExpr_in_unaryExpr1739);
				unaryExpr81=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr81.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 194:21: -> ^( SIZEOF_EXPR unaryExpr )
				{
					DebugLocation(194, 24);
					// Grammar\\SimpleC.g:194:24: ^( SIZEOF_EXPR unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(194, 26);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SIZEOF_EXPR, "SIZEOF_EXPR"), root_1);

					DebugLocation(194, 38);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Grammar\\SimpleC.g:195:4: SizeOf '(' typeSpec ')'
				{
				DebugLocation(195, 4);
				SizeOf82=(CommonToken)Match(input,SizeOf,Follow._SizeOf_in_unaryExpr1752); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SizeOf.Add(SizeOf82);

				DebugLocation(195, 11);
				char_literal83=(CommonToken)Match(input,82,Follow._82_in_unaryExpr1754); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_82.Add(char_literal83);

				DebugLocation(195, 15);
				PushFollow(Follow._typeSpec_in_unaryExpr1756);
				typeSpec84=typeSpec();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeSpec.Add(typeSpec84.Tree);
				DebugLocation(195, 24);
				char_literal85=(CommonToken)Match(input,83,Follow._83_in_unaryExpr1758); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_83.Add(char_literal85);



				{
				// AST REWRITE
				// elements: typeSpec
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 195:28: -> ^( SIZEOF_TYPE typeSpec )
				{
					DebugLocation(195, 31);
					// Grammar\\SimpleC.g:195:31: ^( SIZEOF_TYPE typeSpec )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(195, 33);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SIZEOF_TYPE, "SIZEOF_TYPE"), root_1);

					DebugLocation(195, 45);
					adaptor.AddChild(root_1, stream_typeSpec.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Grammar\\SimpleC.g:196:4: primaryExpr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(196, 4);
				PushFollow(Follow._primaryExpr_in_unaryExpr1771);
				primaryExpr86=primaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, primaryExpr86.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpr", 16);
			LeaveRule("unaryExpr", 16);
			LeaveRule_unaryExpr();
		}
		DebugLocation(198, 0);
		} finally { DebugExitRule(GrammarFileName, "unaryExpr"); }
		return retval;

	}
	// $ANTLR end "unaryExpr"

	partial void EnterRule_primaryExpr();
	partial void LeaveRule_primaryExpr();

	// $ANTLR start "primaryExpr"
	// Grammar\\SimpleC.g:200:1: primaryExpr : basic= basicExpr ( '[' idx= expr ']' | '.' member= identifier | '->' member= identifier | '++' | '--' )* ;
	[GrammarRule("primaryExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> primaryExpr()
	{
		EnterRule_primaryExpr();
		EnterRule("primaryExpr", 17);
		TraceIn("primaryExpr", 17);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal87 = default(CommonToken);
		CommonToken char_literal88 = default(CommonToken);
		CommonToken char_literal89 = default(CommonToken);
		CommonToken string_literal90 = default(CommonToken);
		CommonToken string_literal91 = default(CommonToken);
		CommonToken string_literal92 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> basic = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> idx = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> member = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal87_tree = default(CommonTree);
		CommonTree char_literal88_tree = default(CommonTree);
		CommonTree char_literal89_tree = default(CommonTree);
		CommonTree string_literal90_tree = default(CommonTree);
		CommonTree string_literal91_tree = default(CommonTree);
		CommonTree string_literal92_tree = default(CommonTree);

			List<ITree> expressions = new List<ITree>();
			List<IToken> operators = new List<IToken>();

		try { DebugEnterRule(GrammarFileName, "primaryExpr");
		DebugLocation(200, 0);
		try
		{
			// Grammar\\SimpleC.g:204:3: (basic= basicExpr ( '[' idx= expr ']' | '.' member= identifier | '->' member= identifier | '++' | '--' )* )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:205:2: basic= basicExpr ( '[' idx= expr ']' | '.' member= identifier | '->' member= identifier | '++' | '--' )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(205, 7);
			PushFollow(Follow._basicExpr_in_primaryExpr1789);
			basic=basicExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, basic.Tree);
			DebugLocation(205, 18);
			if (state.backtracking == 0)
			{
				 
						expressions.Add((ITree)basic.Tree);
					
			}
			DebugLocation(208, 2);
			// Grammar\\SimpleC.g:208:2: ( '[' idx= expr ']' | '.' member= identifier | '->' member= identifier | '++' | '--' )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=6;
				try { DebugEnterDecision(16, false);
				switch (input.LA(1))
				{
				case 90:
					{
					alt16 = 1;
					}
					break;
				case 88:
					{
					alt16 = 2;
					}
					break;
				case 87:
					{
					alt16 = 3;
					}
					break;
				case 84:
					{
					alt16 = 4;
					}
					break;
				case 86:
					{
					alt16 = 5;
					}
					break;
				}

				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:209:4: '[' idx= expr ']'
					{
					DebugLocation(209, 4);
					char_literal87=(CommonToken)Match(input,90,Follow._90_in_primaryExpr1799); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal87_tree = (CommonTree)adaptor.Create(char_literal87);
					adaptor.AddChild(root_0, char_literal87_tree);
					}
					DebugLocation(209, 11);
					PushFollow(Follow._expr_in_primaryExpr1803);
					idx=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, idx.Tree);
					DebugLocation(209, 17);
					char_literal88=(CommonToken)Match(input,91,Follow._91_in_primaryExpr1805); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal88_tree = (CommonTree)adaptor.Create(char_literal88);
					adaptor.AddChild(root_0, char_literal88_tree);
					}
					DebugLocation(209, 21);
					if (state.backtracking == 0)
					{
						 
										operators.Add(new CommonToken(SUBSCRIPT, tokenNames[SUBSCRIPT]));
										expressions.Add((ITree)idx.Tree);
									
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammar\\SimpleC.g:213:5: '.' member= identifier
					{
					DebugLocation(213, 5);
					char_literal89=(CommonToken)Match(input,88,Follow._88_in_primaryExpr1814); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal89_tree = (CommonTree)adaptor.Create(char_literal89);
					adaptor.AddChild(root_0, char_literal89_tree);
					}
					DebugLocation(213, 15);
					PushFollow(Follow._identifier_in_primaryExpr1818);
					member=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, member.Tree);
					DebugLocation(213, 27);
					if (state.backtracking == 0)
					{

										operators.Add(new CommonToken(STRUCT_MEMBER, tokenNames[STRUCT_MEMBER]));
										expressions.Add((ITree)member.Tree);
									
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammar\\SimpleC.g:217:5: '->' member= identifier
					{
					DebugLocation(217, 5);
					string_literal90=(CommonToken)Match(input,87,Follow._87_in_primaryExpr1826); if (state.failed) return retval;
					if (state.backtracking == 0) {
					string_literal90_tree = (CommonTree)adaptor.Create(string_literal90);
					adaptor.AddChild(root_0, string_literal90_tree);
					}
					DebugLocation(217, 16);
					PushFollow(Follow._identifier_in_primaryExpr1830);
					member=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, member.Tree);
					DebugLocation(217, 28);
					if (state.backtracking == 0)
					{

										operators.Add(new CommonToken(STRUCT_DEREF, tokenNames[STRUCT_DEREF]));
										expressions.Add((ITree)member.Tree);
									
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Grammar\\SimpleC.g:221:5: '++'
					{
					DebugLocation(221, 5);
					string_literal91=(CommonToken)Match(input,84,Follow._84_in_primaryExpr1838); if (state.failed) return retval;
					if (state.backtracking == 0) {
					string_literal91_tree = (CommonTree)adaptor.Create(string_literal91);
					adaptor.AddChild(root_0, string_literal91_tree);
					}
					DebugLocation(221, 10);
					if (state.backtracking == 0)
					{
						 
										operators.Add(new CommonToken(INC_POST, tokenNames[INC_POST]));
										expressions.Add(null);
									
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Grammar\\SimpleC.g:225:5: '--'
					{
					DebugLocation(225, 5);
					string_literal92=(CommonToken)Match(input,86,Follow._86_in_primaryExpr1846); if (state.failed) return retval;
					if (state.backtracking == 0) {
					string_literal92_tree = (CommonTree)adaptor.Create(string_literal92);
					adaptor.AddChild(root_0, string_literal92_tree);
					}
					DebugLocation(225, 10);
					if (state.backtracking == 0)
					{

										operators.Add(new CommonToken(DEC_POST, tokenNames[DEC_POST]));
										expressions.Add(null);
									
					}

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpr", 17);
			LeaveRule("primaryExpr", 17);
			LeaveRule_primaryExpr();
		}
		DebugLocation(230, 0);
		} finally { DebugExitRule(GrammarFileName, "primaryExpr"); }
		return retval;

	}
	// $ANTLR end "primaryExpr"

	partial void EnterRule_basicExpr();
	partial void LeaveRule_basicExpr();

	// $ANTLR start "basicExpr"
	// Grammar\\SimpleC.g:232:1: basicExpr : ( '(' ! expr ')' !| identifier | integer | char | string | funcCall ';' !);
	[GrammarRule("basicExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> basicExpr()
	{
		EnterRule_basicExpr();
		EnterRule("basicExpr", 18);
		TraceIn("basicExpr", 18);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal93 = default(CommonToken);
		CommonToken char_literal95 = default(CommonToken);
		CommonToken char_literal101 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr94 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> identifier96 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> integer97 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> char98 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> string99 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> funcCall100 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal93_tree = default(CommonTree);
		CommonTree char_literal95_tree = default(CommonTree);
		CommonTree char_literal101_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "basicExpr");
		DebugLocation(232, 0);
		try
		{
			// Grammar\\SimpleC.g:232:10: ( '(' ! expr ')' !| identifier | integer | char | string | funcCall ';' !)
			int alt17=6;
			try { DebugEnterDecision(17, false);
			switch (input.LA(1))
			{
			case 82:
				{
				alt17 = 1;
				}
				break;
			case Identifier:
				{
				int LA17_2 = input.LA(2);

				if ((LA17_2==EOF||(LA17_2>=ADD && LA17_2<=ASSIGN)||LA17_2==DIV||LA17_2==ELSE||(LA17_2>=MOD && LA17_2<=MUL)||LA17_2==SUB||LA17_2==WHILE||(LA17_2>=83 && LA17_2<=91)))
				{
					alt17 = 2;
				}
				else if ((LA17_2==82))
				{
					alt17 = 6;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 17, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Integer:
				{
				alt17 = 3;
				}
				break;
			case CHARACTER_LITERAL:
				{
				alt17 = 4;
				}
				break;
			case STRING_LITERAL:
				{
				alt17 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:233:2: '(' ! expr ')' !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(233, 5);
				char_literal93=(CommonToken)Match(input,82,Follow._82_in_basicExpr1861); if (state.failed) return retval;
				DebugLocation(233, 7);
				PushFollow(Follow._expr_in_basicExpr1864);
				expr94=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr94.Tree);
				DebugLocation(233, 15);
				char_literal95=(CommonToken)Match(input,83,Follow._83_in_basicExpr1866); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:234:4: identifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(234, 4);
				PushFollow(Follow._identifier_in_basicExpr1872);
				identifier96=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier96.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleC.g:235:4: integer
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(235, 4);
				PushFollow(Follow._integer_in_basicExpr1878);
				integer97=integer();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, integer97.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleC.g:236:4: char
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(236, 4);
				PushFollow(Follow._char_in_basicExpr1884);
				char98=@char();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, char98.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammar\\SimpleC.g:237:4: string
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(237, 4);
				PushFollow(Follow._string_in_basicExpr1889);
				string99=@string();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, string99.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammar\\SimpleC.g:238:4: funcCall ';' !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(238, 4);
				PushFollow(Follow._funcCall_in_basicExpr1894);
				funcCall100=funcCall();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcCall100.Tree);
				DebugLocation(238, 16);
				char_literal101=(CommonToken)Match(input,89,Follow._89_in_basicExpr1896); if (state.failed) return retval;

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("basicExpr", 18);
			LeaveRule("basicExpr", 18);
			LeaveRule_basicExpr();
		}
		DebugLocation(239, 0);
		} finally { DebugExitRule(GrammarFileName, "basicExpr"); }
		return retval;

	}
	// $ANTLR end "basicExpr"

	partial void EnterRule_funcCall();
	partial void LeaveRule_funcCall();

	// $ANTLR start "funcCall"
	// Grammar\\SimpleC.g:241:1: funcCall : identifier '(' paramList ')' -> ^( FUNC_CALL identifier paramList ) ;
	[GrammarRule("funcCall")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> funcCall()
	{
		EnterRule_funcCall();
		EnterRule("funcCall", 19);
		TraceIn("funcCall", 19);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal103 = default(CommonToken);
		CommonToken char_literal105 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> identifier102 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> paramList104 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal103_tree = default(CommonTree);
		CommonTree char_literal105_tree = default(CommonTree);
		RewriteRuleITokenStream stream_82=new RewriteRuleITokenStream(adaptor,"token 82");
		RewriteRuleITokenStream stream_83=new RewriteRuleITokenStream(adaptor,"token 83");
		RewriteRuleSubtreeStream stream_paramList=new RewriteRuleSubtreeStream(adaptor,"rule paramList");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "funcCall");
		DebugLocation(241, 0);
		try
		{
			// Grammar\\SimpleC.g:241:9: ( identifier '(' paramList ')' -> ^( FUNC_CALL identifier paramList ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:242:2: identifier '(' paramList ')'
			{
			DebugLocation(242, 2);
			PushFollow(Follow._identifier_in_funcCall1907);
			identifier102=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier102.Tree);
			DebugLocation(242, 13);
			char_literal103=(CommonToken)Match(input,82,Follow._82_in_funcCall1909); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_82.Add(char_literal103);

			DebugLocation(242, 17);
			PushFollow(Follow._paramList_in_funcCall1911);
			paramList104=paramList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_paramList.Add(paramList104.Tree);
			DebugLocation(242, 27);
			char_literal105=(CommonToken)Match(input,83,Follow._83_in_funcCall1913); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_83.Add(char_literal105);



			{
			// AST REWRITE
			// elements: paramList, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 242:31: -> ^( FUNC_CALL identifier paramList )
			{
				DebugLocation(242, 34);
				// Grammar\\SimpleC.g:242:34: ^( FUNC_CALL identifier paramList )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(242, 36);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC_CALL, "FUNC_CALL"), root_1);

				DebugLocation(242, 46);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(242, 57);
				adaptor.AddChild(root_1, stream_paramList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcCall", 19);
			LeaveRule("funcCall", 19);
			LeaveRule_funcCall();
		}
		DebugLocation(243, 0);
		} finally { DebugExitRule(GrammarFileName, "funcCall"); }
		return retval;

	}
	// $ANTLR end "funcCall"

	partial void EnterRule_binaryOperator();
	partial void LeaveRule_binaryOperator();

	// $ANTLR start "binaryOperator"
	// Grammar\\SimpleC.g:245:1: binaryOperator : ( ADD | SUB | MUL | DIV | MOD | ASSIGN );
	[GrammarRule("binaryOperator")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> binaryOperator()
	{
		EnterRule_binaryOperator();
		EnterRule("binaryOperator", 20);
		TraceIn("binaryOperator", 20);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set106 = default(CommonToken);

		CommonTree set106_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "binaryOperator");
		DebugLocation(245, 0);
		try
		{
			// Grammar\\SimpleC.g:245:15: ( ADD | SUB | MUL | DIV | MOD | ASSIGN )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(245, 15);

			set106=(CommonToken)input.LT(1);
			if ((input.LA(1)>=ADD && input.LA(1)<=ASSIGN)||input.LA(1)==DIV||(input.LA(1)>=MOD && input.LA(1)<=MUL)||input.LA(1)==SUB)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set106));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("binaryOperator", 20);
			LeaveRule("binaryOperator", 20);
			LeaveRule_binaryOperator();
		}
		DebugLocation(265, 0);
		} finally { DebugExitRule(GrammarFileName, "binaryOperator"); }
		return retval;

	}
	// $ANTLR end "binaryOperator"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();

	// $ANTLR start "identifier"
	// Grammar\\SimpleC.g:268:1: identifier : Identifier ->;
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 21);
		TraceIn("identifier", 21);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken Identifier107 = default(CommonToken);

		CommonTree Identifier107_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(268, 0);
		try
		{
			// Grammar\\SimpleC.g:268:11: ( Identifier ->)
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:269:2: Identifier
			{
			DebugLocation(269, 2);
			Identifier107=(CommonToken)Match(input,Identifier,Follow._Identifier_in_identifier1980); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier107);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 269:13: ->
			{
				DebugLocation(269, 16);
				adaptor.AddChild(root_0,  
						adaptor.BecomeRoot(new CommonToken(IDENT, Identifier107.Text), adaptor.Nil()) 
					);

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 21);
			LeaveRule("identifier", 21);
			LeaveRule_identifier();
		}
		DebugLocation(272, 0);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_integer();
	partial void LeaveRule_integer();

	// $ANTLR start "integer"
	// Grammar\\SimpleC.g:274:1: integer : Integer ->;
	[GrammarRule("integer")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> integer()
	{
		EnterRule_integer();
		EnterRule("integer", 22);
		TraceIn("integer", 22);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken Integer108 = default(CommonToken);

		CommonTree Integer108_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Integer=new RewriteRuleITokenStream(adaptor,"token Integer");
		try { DebugEnterRule(GrammarFileName, "integer");
		DebugLocation(274, 0);
		try
		{
			// Grammar\\SimpleC.g:274:8: ( Integer ->)
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:275:2: Integer
			{
			DebugLocation(275, 2);
			Integer108=(CommonToken)Match(input,Integer,Follow._Integer_in_integer1993); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Integer.Add(Integer108);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 275:10: ->
			{
				DebugLocation(275, 13);
				adaptor.AddChild(root_0, 
						adaptor.BecomeRoot(new CommonToken(INTEGER, Integer108.Text), adaptor.Nil()) 
					);

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("integer", 22);
			LeaveRule("integer", 22);
			LeaveRule_integer();
		}
		DebugLocation(278, 0);
		} finally { DebugExitRule(GrammarFileName, "integer"); }
		return retval;

	}
	// $ANTLR end "integer"

	partial void EnterRule_string();
	partial void LeaveRule_string();

	// $ANTLR start "string"
	// Grammar\\SimpleC.g:280:1: string : STRING_LITERAL ->;
	[GrammarRule("string")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> @string()
	{
		EnterRule_string();
		EnterRule("string", 23);
		TraceIn("string", 23);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken STRING_LITERAL109 = default(CommonToken);

		CommonTree STRING_LITERAL109_tree = default(CommonTree);
		RewriteRuleITokenStream stream_STRING_LITERAL=new RewriteRuleITokenStream(adaptor,"token STRING_LITERAL");
		try { DebugEnterRule(GrammarFileName, "string");
		DebugLocation(280, 0);
		try
		{
			// Grammar\\SimpleC.g:280:7: ( STRING_LITERAL ->)
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:281:2: STRING_LITERAL
			{
			DebugLocation(281, 2);
			STRING_LITERAL109=(CommonToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_string2006); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_STRING_LITERAL.Add(STRING_LITERAL109);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 281:17: ->
			{
				DebugLocation(281, 20);
				adaptor.AddChild(root_0, 
						adaptor.BecomeRoot(new CommonToken(STRING, STRING_LITERAL109.Text), adaptor.Nil()) 
					);

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("string", 23);
			LeaveRule("string", 23);
			LeaveRule_string();
		}
		DebugLocation(284, 0);
		} finally { DebugExitRule(GrammarFileName, "string"); }
		return retval;

	}
	// $ANTLR end "string"

	partial void EnterRule_char();
	partial void LeaveRule_char();

	// $ANTLR start "char"
	// Grammar\\SimpleC.g:287:1: char : CHARACTER_LITERAL ->;
	[GrammarRule("char")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> @char()
	{
		EnterRule_char();
		EnterRule("char", 24);
		TraceIn("char", 24);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken CHARACTER_LITERAL110 = default(CommonToken);

		CommonTree CHARACTER_LITERAL110_tree = default(CommonTree);
		RewriteRuleITokenStream stream_CHARACTER_LITERAL=new RewriteRuleITokenStream(adaptor,"token CHARACTER_LITERAL");
		try { DebugEnterRule(GrammarFileName, "char");
		DebugLocation(287, 0);
		try
		{
			// Grammar\\SimpleC.g:287:5: ( CHARACTER_LITERAL ->)
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:288:3: CHARACTER_LITERAL
			{
			DebugLocation(288, 3);
			CHARACTER_LITERAL110=(CommonToken)Match(input,CHARACTER_LITERAL,Follow._CHARACTER_LITERAL_in_char2021); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CHARACTER_LITERAL.Add(CHARACTER_LITERAL110);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 288:21: ->
			{
				DebugLocation(288, 24);
				adaptor.AddChild(root_0, 
						adaptor.BecomeRoot(new CommonToken(CHAR, CHARACTER_LITERAL110.Text), adaptor.Nil()) 
					);

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("char", 24);
			LeaveRule("char", 24);
			LeaveRule_char();
		}
		DebugLocation(291, 0);
		} finally { DebugExitRule(GrammarFileName, "char"); }
		return retval;

	}
	// $ANTLR end "char"

	partial void EnterRule_synpred9_SimpleC_fragment();
	partial void LeaveRule_synpred9_SimpleC_fragment();

	// $ANTLR start synpred9_SimpleC
	public void synpred9_SimpleC_fragment()
	{
		EnterRule_synpred9_SimpleC_fragment();
		EnterRule("synpred9_SimpleC_fragment", 33);
		TraceIn("synpred9_SimpleC_fragment", 33);
		try
		{
			// Grammar\\SimpleC.g:193:4: ( '(' typeSpec ')' unaryExpr )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:193:4: '(' typeSpec ')' unaryExpr
			{
			DebugLocation(193, 4);
			Match(input,82,Follow._82_in_synpred9_SimpleC1716); if (state.failed) return;
			DebugLocation(193, 8);
			PushFollow(Follow._typeSpec_in_synpred9_SimpleC1718);
			typeSpec();
			PopFollow();
			if (state.failed) return;
			DebugLocation(193, 17);
			Match(input,83,Follow._83_in_synpred9_SimpleC1720); if (state.failed) return;
			DebugLocation(193, 21);
			PushFollow(Follow._unaryExpr_in_synpred9_SimpleC1722);
			unaryExpr();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_SimpleC_fragment", 33);
			LeaveRule("synpred9_SimpleC_fragment", 33);
			LeaveRule_synpred9_SimpleC_fragment();
		}
	}
	// $ANTLR end synpred9_SimpleC

	partial void EnterRule_synpred10_SimpleC_fragment();
	partial void LeaveRule_synpred10_SimpleC_fragment();

	// $ANTLR start synpred10_SimpleC
	public void synpred10_SimpleC_fragment()
	{
		EnterRule_synpred10_SimpleC_fragment();
		EnterRule("synpred10_SimpleC_fragment", 34);
		TraceIn("synpred10_SimpleC_fragment", 34);
		try
		{
			// Grammar\\SimpleC.g:194:4: ( SizeOf unaryExpr )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:194:4: SizeOf unaryExpr
			{
			DebugLocation(194, 4);
			Match(input,SizeOf,Follow._SizeOf_in_synpred10_SimpleC1737); if (state.failed) return;
			DebugLocation(194, 11);
			PushFollow(Follow._unaryExpr_in_synpred10_SimpleC1739);
			unaryExpr();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred10_SimpleC_fragment", 34);
			LeaveRule("synpred10_SimpleC_fragment", 34);
			LeaveRule_synpred10_SimpleC_fragment();
		}
	}
	// $ANTLR end synpred10_SimpleC

	partial void EnterRule_synpred11_SimpleC_fragment();
	partial void LeaveRule_synpred11_SimpleC_fragment();

	// $ANTLR start synpred11_SimpleC
	public void synpred11_SimpleC_fragment()
	{
		EnterRule_synpred11_SimpleC_fragment();
		EnterRule("synpred11_SimpleC_fragment", 35);
		TraceIn("synpred11_SimpleC_fragment", 35);
		try
		{
			// Grammar\\SimpleC.g:195:4: ( SizeOf '(' typeSpec ')' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:195:4: SizeOf '(' typeSpec ')'
			{
			DebugLocation(195, 4);
			Match(input,SizeOf,Follow._SizeOf_in_synpred11_SimpleC1752); if (state.failed) return;
			DebugLocation(195, 11);
			Match(input,82,Follow._82_in_synpred11_SimpleC1754); if (state.failed) return;
			DebugLocation(195, 15);
			PushFollow(Follow._typeSpec_in_synpred11_SimpleC1756);
			typeSpec();
			PopFollow();
			if (state.failed) return;
			DebugLocation(195, 24);
			Match(input,83,Follow._83_in_synpred11_SimpleC1758); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred11_SimpleC_fragment", 35);
			LeaveRule("synpred11_SimpleC_fragment", 35);
			LeaveRule_synpred11_SimpleC_fragment();
		}
	}
	// $ANTLR end synpred11_SimpleC
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA2 dfa2;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa2 = new DFA2( this );
	}

	private class DFA2 : DFA
	{
		private const string DFA2_eotS =
			"\x17\xFFFF";
		private const string DFA2_eofS =
			"\x17\xFFFF";
		private const string DFA2_minS =
			"\x1\xF\x4\x27\x1\xFFFF\x1\x52\x1\xFFFF\x1\xF\x4\x27\x1\x59\x1\x53\x2"+
			"\xFFFF\x1\xF\x4\x27\x1\x53";
		private const string DFA2_maxS =
			"\x1\x51\x4\x27\x1\xFFFF\x1\x59\x1\xFFFF\x1\x53\x4\x27\x1\x5C\x1\x55\x2"+
			"\xFFFF\x1\x4D\x4\x27\x1\x55";
		private const string DFA2_acceptS =
			"\x5\xFFFF\x1\x4\x1\xFFFF\x1\x1\x7\xFFFF\x1\x2\x1\x3\x6\xFFFF";
		private const string DFA2_specialS =
			"\x17\xFFFF}>";
		private static readonly string[] DFA2_transitionS =
			{
				"\x1\x4\x18\xFFFF\x1\x1\x19\xFFFF\x1\x3\xA\xFFFF\x1\x2\x3\xFFFF\x1\x5",
				"\x1\x6",
				"\x1\x6",
				"\x1\x6",
				"\x1\x6",
				"",
				"\x1\x8\x6\xFFFF\x1\x7",
				"",
				"\x1\xC\x18\xFFFF\x1\x9\x19\xFFFF\x1\xB\xA\xFFFF\x1\xA\x5\xFFFF\x1\xD",
				"\x1\xE",
				"\x1\xE",
				"\x1\xE",
				"\x1\xE",
				"\x1\xF\x2\xFFFF\x1\x10",
				"\x1\xD\x1\xFFFF\x1\x11",
				"",
				"",
				"\x1\x15\x18\xFFFF\x1\x12\x19\xFFFF\x1\x14\xA\xFFFF\x1\x13",
				"\x1\x16",
				"\x1\x16",
				"\x1\x16",
				"\x1\x16",
				"\x1\xD\x1\xFFFF\x1\x11"
			};

		private static readonly short[] DFA2_eot = DFA.UnpackEncodedString(DFA2_eotS);
		private static readonly short[] DFA2_eof = DFA.UnpackEncodedString(DFA2_eofS);
		private static readonly char[] DFA2_min = DFA.UnpackEncodedStringToUnsignedChars(DFA2_minS);
		private static readonly char[] DFA2_max = DFA.UnpackEncodedStringToUnsignedChars(DFA2_maxS);
		private static readonly short[] DFA2_accept = DFA.UnpackEncodedString(DFA2_acceptS);
		private static readonly short[] DFA2_special = DFA.UnpackEncodedString(DFA2_specialS);
		private static readonly short[][] DFA2_transition;

		static DFA2()
		{
			int numStates = DFA2_transitionS.Length;
			DFA2_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA2_transition[i] = DFA.UnpackEncodedString(DFA2_transitionS[i]);
			}
		}

		public DFA2( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 2;
			this.eot = DFA2_eot;
			this.eof = DFA2_eof;
			this.min = DFA2_min;
			this.max = DFA2_max;
			this.accept = DFA2_accept;
			this.special = DFA2_special;
			this.transition = DFA2_transition;
		}

		public override string Description { get { return "108:1: programStatement : ( varDef | funcDecl | funcDef | macroDecl );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _programStatement_in_program1109 = new BitSet(new ulong[]{0x10000008000UL,0x22004UL});
		public static readonly BitSet _EOF_in_program1112 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varDef_in_programStatement1131 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcDecl_in_programStatement1135 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcDef_in_programStatement1139 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _macroDecl_in_programStatement1143 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varSpec_in_varDef1152 = new BitSet(new ulong[]{0x0UL,0x2000000UL});
		public static readonly BitSet _89_in_varDef1154 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeSpec_in_funcDecl1174 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _identifier_in_funcDecl1176 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _82_in_funcDecl1178 = new BitSet(new ulong[]{0x10000008000UL,0x82004UL});
		public static readonly BitSet _paramSpecList_in_funcDecl1180 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_funcDecl1182 = new BitSet(new ulong[]{0x0UL,0x2000000UL});
		public static readonly BitSet _89_in_funcDecl1183 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeSpec_in_funcDef1207 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _identifier_in_funcDef1209 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _82_in_funcDef1211 = new BitSet(new ulong[]{0x10000008000UL,0x82004UL});
		public static readonly BitSet _paramSpecList_in_funcDef1213 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_funcDef1215 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _92_in_funcDef1216 = new BitSet(new ulong[]{0x902083820010C050UL,0x52556006UL});
		public static readonly BitSet _funcBody_in_funcDef1218 = new BitSet(new ulong[]{0x0UL,0x20000000UL});
		public static readonly BitSet _93_in_funcDef1220 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _81_in_macroDecl1247 = new BitSet(new ulong[]{0x1000000800000000UL});
		public static readonly BitSet _STRING_LITERAL_in_macroDecl1252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INCLUDE_STRING_in_macroDecl1258 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varSpec_in_paramSpecList1287 = new BitSet(new ulong[]{0x2UL,0x200000UL});
		public static readonly BitSet _85_in_paramSpecList1290 = new BitSet(new ulong[]{0x10000008000UL,0x2004UL});
		public static readonly BitSet _varSpec_in_paramSpecList1292 = new BitSet(new ulong[]{0x2UL,0x200000UL});
		public static readonly BitSet _statements_in_funcBody1314 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_statements1332 = new BitSet(new ulong[]{0x902083820010C052UL,0x52556006UL});
		public static readonly BitSet _varDef_in_statement1342 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_statement1347 = new BitSet(new ulong[]{0x0UL,0x2000000UL});
		public static readonly BitSet _89_in_statement1350 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _92_in_statement1364 = new BitSet(new ulong[]{0x902083820010C050UL,0x72556006UL});
		public static readonly BitSet _statements_in_statement1366 = new BitSet(new ulong[]{0x0UL,0x20000000UL});
		public static readonly BitSet _93_in_statement1368 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeSpec_in_varSpec1389 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _identifier_in_varSpec1391 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Int_in_typeSpec1415 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Void_in_typeSpec1421 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _String_in_typeSpec1427 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Char_in_typeSpec1433 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_paramList1452 = new BitSet(new ulong[]{0x2UL,0x200000UL});
		public static readonly BitSet _85_in_paramList1455 = new BitSet(new ulong[]{0x9020828200104050UL,0x40554002UL});
		public static readonly BitSet _expr_in_paramList1457 = new BitSet(new ulong[]{0x2UL,0x200000UL});
		public static readonly BitSet _binaryExpr_in_expr1479 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_expr1484 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _82_in_expr1487 = new BitSet(new ulong[]{0x1000028000004000UL,0x40000UL});
		public static readonly BitSet _basicExpr_in_expr1490 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_expr1492 = new BitSet(new ulong[]{0x9020828200104050UL,0x40554002UL});
		public static readonly BitSet _expr_in_expr1495 = new BitSet(new ulong[]{0x200002UL});
		public static readonly BitSet _ELSE_in_expr1498 = new BitSet(new ulong[]{0x9020828200104050UL,0x40554002UL});
		public static readonly BitSet _expr_in_expr1501 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_expr1508 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _82_in_expr1511 = new BitSet(new ulong[]{0x1000028000004000UL,0x40000UL});
		public static readonly BitSet _basicExpr_in_expr1514 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_expr1516 = new BitSet(new ulong[]{0x9020828200104050UL,0x40554002UL});
		public static readonly BitSet _expr_in_expr1519 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DO_in_expr1524 = new BitSet(new ulong[]{0x9020828200104050UL,0x40554002UL});
		public static readonly BitSet _expr_in_expr1527 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _WHILE_in_expr1529 = new BitSet(new ulong[]{0x1000028000004000UL,0x40000UL});
		public static readonly BitSet _basicExpr_in_expr1532 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_expr1537 = new BitSet(new ulong[]{0x1000028000004000UL,0x40000UL});
		public static readonly BitSet _basicExpr_in_expr1540 = new BitSet(new ulong[]{0x0UL,0x2000000UL});
		public static readonly BitSet _89_in_expr1542 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpr_in_binaryExpr1560 = new BitSet(new ulong[]{0x8000C00000080032UL});
		public static readonly BitSet _binaryOperator_in_binaryExpr1568 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_binaryExpr1572 = new BitSet(new ulong[]{0x8000C00000080032UL});
		public static readonly BitSet _MUL_in_unaryExpr1596 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1598 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BIT_AND_in_unaryExpr1611 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1613 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ADD_in_unaryExpr1626 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1628 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUB_in_unaryExpr1641 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1643 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _80_in_unaryExpr1656 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1658 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _94_in_unaryExpr1671 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _84_in_unaryExpr1686 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _86_in_unaryExpr1701 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1703 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _82_in_unaryExpr1716 = new BitSet(new ulong[]{0x10000008000UL,0x2004UL});
		public static readonly BitSet _typeSpec_in_unaryExpr1718 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_unaryExpr1720 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1722 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SizeOf_in_unaryExpr1737 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1739 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SizeOf_in_unaryExpr1752 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _82_in_unaryExpr1754 = new BitSet(new ulong[]{0x10000008000UL,0x2004UL});
		public static readonly BitSet _typeSpec_in_unaryExpr1756 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_unaryExpr1758 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpr_in_unaryExpr1771 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _basicExpr_in_primaryExpr1789 = new BitSet(new ulong[]{0x2UL,0x5D00000UL});
		public static readonly BitSet _90_in_primaryExpr1799 = new BitSet(new ulong[]{0x9020828200104050UL,0x40554002UL});
		public static readonly BitSet _expr_in_primaryExpr1803 = new BitSet(new ulong[]{0x0UL,0x8000000UL});
		public static readonly BitSet _91_in_primaryExpr1805 = new BitSet(new ulong[]{0x2UL,0x5D00000UL});
		public static readonly BitSet _88_in_primaryExpr1814 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _identifier_in_primaryExpr1818 = new BitSet(new ulong[]{0x2UL,0x5D00000UL});
		public static readonly BitSet _87_in_primaryExpr1826 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _identifier_in_primaryExpr1830 = new BitSet(new ulong[]{0x2UL,0x5D00000UL});
		public static readonly BitSet _84_in_primaryExpr1838 = new BitSet(new ulong[]{0x2UL,0x5D00000UL});
		public static readonly BitSet _86_in_primaryExpr1846 = new BitSet(new ulong[]{0x2UL,0x5D00000UL});
		public static readonly BitSet _82_in_basicExpr1861 = new BitSet(new ulong[]{0x9020828200104050UL,0x40554002UL});
		public static readonly BitSet _expr_in_basicExpr1864 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_basicExpr1866 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_basicExpr1872 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _integer_in_basicExpr1878 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _char_in_basicExpr1884 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_basicExpr1889 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcCall_in_basicExpr1894 = new BitSet(new ulong[]{0x0UL,0x2000000UL});
		public static readonly BitSet _89_in_basicExpr1896 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_funcCall1907 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _82_in_funcCall1909 = new BitSet(new ulong[]{0x9020828200104050UL,0x405D4002UL});
		public static readonly BitSet _paramList_in_funcCall1911 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_funcCall1913 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_identifier1980 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Integer_in_integer1993 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_string2006 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHARACTER_LITERAL_in_char2021 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _82_in_synpred9_SimpleC1716 = new BitSet(new ulong[]{0x10000008000UL,0x2004UL});
		public static readonly BitSet _typeSpec_in_synpred9_SimpleC1718 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_synpred9_SimpleC1720 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_synpred9_SimpleC1722 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SizeOf_in_synpred10_SimpleC1737 = new BitSet(new ulong[]{0x9000828000004050UL,0x40550002UL});
		public static readonly BitSet _unaryExpr_in_synpred10_SimpleC1739 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SizeOf_in_synpred11_SimpleC1752 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _82_in_synpred11_SimpleC1754 = new BitSet(new ulong[]{0x10000008000UL,0x2004UL});
		public static readonly BitSet _typeSpec_in_synpred11_SimpleC1756 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_synpred11_SimpleC1758 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  SimpleC.Grammar 
