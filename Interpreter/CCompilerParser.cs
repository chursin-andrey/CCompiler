//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 CCompiler.g 2015-10-06 17:56:26

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class CCompilerParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "AND", "ARGS", "ARGS_DECL", "ASSIGN", "BIT_AND", "BIT_OR", "BLOCK", "CALL", "COMMA", "CONVERT", "DEFINE", "DIGIT", "DIV", "DO", "ELSE", "EQ", "EscapeSequence", "FALSE", "FOR", "FUNCTION", "FUNC_DECL", "GE", "GT", "IDENT", "IF", "INCLUDE", "INCLUDE_STRING", "INDEX", "LE", "LETTER", "LINE_COMMENT", "LT", "ML_COMMENT", "MUL", "NE", "NOT", "NUMBER", "OR", "OctalEscape", "PROGRAM", "RETURN", "SEMI", "STRING", "SUB", "TRUE", "TYPE", "UNKNOWN", "VAR", "WHILE", "WS", "'#include'", "'('", "')'", "'['", "']'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int ADD=4;
	public const int AND=5;
	public const int ARGS=6;
	public const int ARGS_DECL=7;
	public const int ASSIGN=8;
	public const int BIT_AND=9;
	public const int BIT_OR=10;
	public const int BLOCK=11;
	public const int CALL=12;
	public const int COMMA=13;
	public const int CONVERT=14;
	public const int DEFINE=15;
	public const int DIGIT=16;
	public const int DIV=17;
	public const int DO=18;
	public const int ELSE=19;
	public const int EQ=20;
	public const int EscapeSequence=21;
	public const int FALSE=22;
	public const int FOR=23;
	public const int FUNCTION=24;
	public const int FUNC_DECL=25;
	public const int GE=26;
	public const int GT=27;
	public const int IDENT=28;
	public const int IF=29;
	public const int INCLUDE=30;
	public const int INCLUDE_STRING=31;
	public const int INDEX=32;
	public const int LE=33;
	public const int LETTER=34;
	public const int LINE_COMMENT=35;
	public const int LT=36;
	public const int ML_COMMENT=37;
	public const int MUL=38;
	public const int NE=39;
	public const int NOT=40;
	public const int NUMBER=41;
	public const int OR=42;
	public const int OctalEscape=43;
	public const int PROGRAM=44;
	public const int RETURN=45;
	public const int SEMI=46;
	public const int STRING=47;
	public const int SUB=48;
	public const int TRUE=49;
	public const int TYPE=50;
	public const int UNKNOWN=51;
	public const int VAR=52;
	public const int WHILE=53;
	public const int WS=54;

	public CCompilerParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public CCompilerParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[81+1];


		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return CCompilerParser.tokenNames; } }
	public override string GrammarFileName { get { return "CCompiler.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_ident();
	partial void LeaveRule_ident();

	// $ANTLR start "ident"
	// CCompiler.g:122:1: ident : IDENT ;
	[GrammarRule("ident")]
	private AstParserRuleReturnScope<object, IToken> ident()
	{
		EnterRule_ident();
		EnterRule("ident", 1);
		TraceIn("ident", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int ident_StartIndex = input.Index;

		object root_0 = default(object);

		IToken IDENT1 = default(IToken);

		object IDENT1_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "ident");
		DebugLocation(122, 13);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 1)) { return retval; }

			// CCompiler.g:122:6: ( IDENT )
			DebugEnterAlt(1);
			// CCompiler.g:122:8: IDENT
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(122, 8);
			IDENT1=(IToken)Match(input,IDENT,Follow._IDENT_in_ident974); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IDENT1_tree = (object)adaptor.Create(IDENT1);
			adaptor.AddChild(root_0, IDENT1_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ident", 1);
			LeaveRule("ident", 1);
			LeaveRule_ident();
			if (state.backtracking > 0) { Memoize(input, 1, ident_StartIndex); }

		}
		DebugLocation(122, 13);
		} finally { DebugExitRule(GrammarFileName, "ident"); }
		return retval;

	}
	// $ANTLR end "ident"

	partial void EnterRule_type0();
	partial void LeaveRule_type0();

	// $ANTLR start "type0"
	// CCompiler.g:132:1: type0 : IDENT ( '[' ']' )* ;
	[GrammarRule("type0")]
	private AstParserRuleReturnScope<object, IToken> type0()
	{
		EnterRule_type0();
		EnterRule("type0", 2);
		TraceIn("type0", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int type0_StartIndex = input.Index;

		object root_0 = default(object);

		IToken IDENT2 = default(IToken);
		IToken char_literal3 = default(IToken);
		IToken char_literal4 = default(IToken);

		object IDENT2_tree = default(object);
		object char_literal3_tree = default(object);
		object char_literal4_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type0");
		DebugLocation(132, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 2)) { return retval; }

			// CCompiler.g:132:6: ( IDENT ( '[' ']' )* )
			DebugEnterAlt(1);
			// CCompiler.g:133:3: IDENT ( '[' ']' )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(133, 3);
			IDENT2=(IToken)Match(input,IDENT,Follow._IDENT_in_type0988); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IDENT2_tree = (object)adaptor.Create(IDENT2);
			adaptor.AddChild(root_0, IDENT2_tree);
			}
			DebugLocation(133, 9);
			// CCompiler.g:133:9: ( '[' ']' )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==58))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// CCompiler.g:133:10: '[' ']'
					{
					DebugLocation(133, 10);
					char_literal3=(IToken)Match(input,58,Follow._58_in_type0991); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal3_tree = (object)adaptor.Create(char_literal3);
					adaptor.AddChild(root_0, char_literal3_tree);
					}
					DebugLocation(133, 14);
					char_literal4=(IToken)Match(input,59,Follow._59_in_type0993); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal4_tree = (object)adaptor.Create(char_literal4);
					adaptor.AddChild(root_0, char_literal4_tree);
					}

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type0", 2);
			LeaveRule("type0", 2);
			LeaveRule_type0();
			if (state.backtracking > 0) { Memoize(input, 2, type0_StartIndex); }

		}
		DebugLocation(134, 0);
		} finally { DebugExitRule(GrammarFileName, "type0"); }
		return retval;

	}
	// $ANTLR end "type0"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// CCompiler.g:135:1: type : type0 -> TYPE[$type0.text] ;
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 3);
		TraceIn("type", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int type_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type05 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_type0=new RewriteRuleSubtreeStream(adaptor,"rule type0");
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(135, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 3)) { return retval; }

			// CCompiler.g:135:5: ( type0 -> TYPE[$type0.text] )
			DebugEnterAlt(1);
			// CCompiler.g:136:3: type0
			{
			DebugLocation(136, 3);
			PushFollow(Follow._type0_in_type1004);
			type05=type0();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type0.Add(type05.Tree);


			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 136:10: -> TYPE[$type0.text]
			{
				DebugLocation(136, 14);
				adaptor.AddChild(root_0, (object)adaptor.Create(TYPE, (type05!=null?input.ToString(type05.Start,type05.Stop):null)));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 3);
			LeaveRule("type", 3);
			LeaveRule_type();
			if (state.backtracking > 0) { Memoize(input, 3, type_StartIndex); }

		}
		DebugLocation(137, 0);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_args();
	partial void LeaveRule_args();

	// $ANTLR start "args"
	// CCompiler.g:154:1: args : ( term ( ',' term )* )? -> ^( ARGS ( term )* ) ;
	[GrammarRule("args")]
	private AstParserRuleReturnScope<object, IToken> args()
	{
		EnterRule_args();
		EnterRule("args", 4);
		TraceIn("args", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int args_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal7 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term6 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term8 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal7_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term");
		try { DebugEnterRule(GrammarFileName, "args");
		DebugLocation(154, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 4)) { return retval; }

			// CCompiler.g:154:5: ( ( term ( ',' term )* )? -> ^( ARGS ( term )* ) )
			DebugEnterAlt(1);
			// CCompiler.g:155:3: ( term ( ',' term )* )?
			{
			DebugLocation(155, 3);
			// CCompiler.g:155:3: ( term ( ',' term )* )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==FALSE||LA3_0==IDENT||(LA3_0>=NOT && LA3_0<=NUMBER)||LA3_0==TRUE||LA3_0==56))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:155:4: term ( ',' term )*
				{
				DebugLocation(155, 4);
				PushFollow(Follow._term_in_args1027);
				term6=term();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_term.Add(term6.Tree);
				DebugLocation(155, 9);
				// CCompiler.g:155:9: ( ',' term )*
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_0 = input.LA(1);

					if ((LA2_0==COMMA))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch ( alt2 )
					{
					case 1:
						DebugEnterAlt(1);
						// CCompiler.g:155:10: ',' term
						{
						DebugLocation(155, 10);
						char_literal7=(IToken)Match(input,COMMA,Follow._COMMA_in_args1030); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(char_literal7);

						DebugLocation(155, 14);
						PushFollow(Follow._term_in_args1032);
						term8=term();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_term.Add(term8.Tree);

						}
						break;

					default:
						goto loop2;
					}
				}

				loop2:
					;

				} finally { DebugExitSubRule(2); }


				}
				break;

			}
			} finally { DebugExitSubRule(3); }



			{
			// AST REWRITE
			// elements: term
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 155:24: -> ^( ARGS ( term )* )
			{
				DebugLocation(155, 28);
				// CCompiler.g:155:28: ^( ARGS ( term )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(155, 30);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGS, "ARGS"), root_1);

				DebugLocation(155, 35);
				// CCompiler.g:155:35: ( term )*
				while ( stream_term.HasNext )
				{
					DebugLocation(155, 35);
					adaptor.AddChild(root_1, stream_term.NextTree());

				}
				stream_term.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("args", 4);
			LeaveRule("args", 4);
			LeaveRule_args();
			if (state.backtracking > 0) { Memoize(input, 4, args_StartIndex); }

		}
		DebugLocation(156, 0);
		} finally { DebugExitRule(GrammarFileName, "args"); }
		return retval;

	}
	// $ANTLR end "args"

	partial void EnterRule_funcCall();
	partial void LeaveRule_funcCall();

	// $ANTLR start "funcCall"
	// CCompiler.g:158:1: funcCall : IDENT '(' args ')' -> ^( CALL IDENT args ) ;
	[GrammarRule("funcCall")]
	private AstParserRuleReturnScope<object, IToken> funcCall()
	{
		EnterRule_funcCall();
		EnterRule("funcCall", 5);
		TraceIn("funcCall", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int funcCall_StartIndex = input.Index;

		object root_0 = default(object);

		IToken IDENT9 = default(IToken);
		IToken char_literal10 = default(IToken);
		IToken char_literal12 = default(IToken);
		AstParserRuleReturnScope<object, IToken> args11 = default(AstParserRuleReturnScope<object, IToken>);

		object IDENT9_tree = default(object);
		object char_literal10_tree = default(object);
		object char_literal12_tree = default(object);
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args");
		try { DebugEnterRule(GrammarFileName, "funcCall");
		DebugLocation(158, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 5)) { return retval; }

			// CCompiler.g:158:9: ( IDENT '(' args ')' -> ^( CALL IDENT args ) )
			DebugEnterAlt(1);
			// CCompiler.g:159:3: IDENT '(' args ')'
			{
			DebugLocation(159, 3);
			IDENT9=(IToken)Match(input,IDENT,Follow._IDENT_in_funcCall1057); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENT.Add(IDENT9);

			DebugLocation(159, 9);
			char_literal10=(IToken)Match(input,56,Follow._56_in_funcCall1059); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_56.Add(char_literal10);

			DebugLocation(159, 13);
			PushFollow(Follow._args_in_funcCall1061);
			args11=args();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_args.Add(args11.Tree);
			DebugLocation(159, 18);
			char_literal12=(IToken)Match(input,57,Follow._57_in_funcCall1063); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_57.Add(char_literal12);



			{
			// AST REWRITE
			// elements: args, IDENT
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 159:23: -> ^( CALL IDENT args )
			{
				DebugLocation(159, 27);
				// CCompiler.g:159:27: ^( CALL IDENT args )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(159, 29);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(159, 34);
				adaptor.AddChild(root_1, stream_IDENT.NextNode());
				DebugLocation(159, 40);
				adaptor.AddChild(root_1, stream_args.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcCall", 5);
			LeaveRule("funcCall", 5);
			LeaveRule_funcCall();
			if (state.backtracking > 0) { Memoize(input, 5, funcCall_StartIndex); }

		}
		DebugLocation(160, 0);
		} finally { DebugExitRule(GrammarFileName, "funcCall"); }
		return retval;

	}
	// $ANTLR end "funcCall"

	partial void EnterRule_arrayIndex0();
	partial void LeaveRule_arrayIndex0();

	// $ANTLR start "arrayIndex0"
	// CCompiler.g:162:1: arrayIndex0 : '[' -> INDEX[\"[]\"] ;
	[GrammarRule("arrayIndex0")]
	private AstParserRuleReturnScope<object, IToken> arrayIndex0()
	{
		EnterRule_arrayIndex0();
		EnterRule("arrayIndex0", 6);
		TraceIn("arrayIndex0", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int arrayIndex0_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal13 = default(IToken);

		object char_literal13_tree = default(object);
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		try { DebugEnterRule(GrammarFileName, "arrayIndex0");
		DebugLocation(162, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 6)) { return retval; }

			// CCompiler.g:162:12: ( '[' -> INDEX[\"[]\"] )
			DebugEnterAlt(1);
			// CCompiler.g:163:3: '['
			{
			DebugLocation(163, 3);
			char_literal13=(IToken)Match(input,58,Follow._58_in_arrayIndex01085); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_58.Add(char_literal13);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 163:8: -> INDEX[\"[]\"]
			{
				DebugLocation(163, 12);
				adaptor.AddChild(root_0, (object)adaptor.Create(INDEX, "[]"));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayIndex0", 6);
			LeaveRule("arrayIndex0", 6);
			LeaveRule_arrayIndex0();
			if (state.backtracking > 0) { Memoize(input, 6, arrayIndex0_StartIndex); }

		}
		DebugLocation(164, 0);
		} finally { DebugExitRule(GrammarFileName, "arrayIndex0"); }
		return retval;

	}
	// $ANTLR end "arrayIndex0"

	partial void EnterRule_params_();
	partial void LeaveRule_params_();

	// $ANTLR start "params_"
	// CCompiler.g:166:1: params_ : ( term ( ',' ! term )* )? ;
	[GrammarRule("params_")]
	private AstParserRuleReturnScope<object, IToken> params_()
	{
		EnterRule_params_();
		EnterRule("params_", 7);
		TraceIn("params_", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int params__StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal15 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term16 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal15_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "params_");
		DebugLocation(166, 33);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 7)) { return retval; }

			// CCompiler.g:166:8: ( ( term ( ',' ! term )* )? )
			DebugEnterAlt(1);
			// CCompiler.g:166:10: ( term ( ',' ! term )* )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(166, 10);
			// CCompiler.g:166:10: ( term ( ',' ! term )* )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==FALSE||LA5_0==IDENT||(LA5_0>=NOT && LA5_0<=NUMBER)||LA5_0==TRUE||LA5_0==56))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:166:12: term ( ',' ! term )*
				{
				DebugLocation(166, 12);
				PushFollow(Follow._term_in_params_1102);
				term14=term();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, term14.Tree);
				DebugLocation(166, 17);
				// CCompiler.g:166:17: ( ',' ! term )*
				try { DebugEnterSubRule(4);
				while (true)
				{
					int alt4=2;
					try { DebugEnterDecision(4, false);
					int LA4_0 = input.LA(1);

					if ((LA4_0==COMMA))
					{
						alt4 = 1;
					}


					} finally { DebugExitDecision(4); }
					switch ( alt4 )
					{
					case 1:
						DebugEnterAlt(1);
						// CCompiler.g:166:18: ',' ! term
						{
						DebugLocation(166, 21);
						char_literal15=(IToken)Match(input,COMMA,Follow._COMMA_in_params_1105); if (state.failed) return retval;
						DebugLocation(166, 23);
						PushFollow(Follow._term_in_params_1108);
						term16=term();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, term16.Tree);

						}
						break;

					default:
						goto loop4;
					}
				}

				loop4:
					;

				} finally { DebugExitSubRule(4); }


				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("params_", 7);
			LeaveRule("params_", 7);
			LeaveRule_params_();
			if (state.backtracking > 0) { Memoize(input, 7, params__StartIndex); }

		}
		DebugLocation(166, 33);
		} finally { DebugExitRule(GrammarFileName, "params_"); }
		return retval;

	}
	// $ANTLR end "params_"

	partial void EnterRule_call();
	partial void LeaveRule_call();

	// $ANTLR start "call"
	// CCompiler.g:167:1: call : ident '(' params_ ')' -> ^( CALL ident ^( ARGS ( params_ )? ) ) ;
	[GrammarRule("call")]
	private AstParserRuleReturnScope<object, IToken> call()
	{
		EnterRule_call();
		EnterRule("call", 8);
		TraceIn("call", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int call_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal18 = default(IToken);
		IToken char_literal20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ident17 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> params_19 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal18_tree = default(object);
		object char_literal20_tree = default(object);
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_params_=new RewriteRuleSubtreeStream(adaptor,"rule params_");
		try { DebugEnterRule(GrammarFileName, "call");
		DebugLocation(167, 63);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 8)) { return retval; }

			// CCompiler.g:167:5: ( ident '(' params_ ')' -> ^( CALL ident ^( ARGS ( params_ )? ) ) )
			DebugEnterAlt(1);
			// CCompiler.g:167:7: ident '(' params_ ')'
			{
			DebugLocation(167, 7);
			PushFollow(Follow._ident_in_call1121);
			ident17=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident17.Tree);
			DebugLocation(167, 13);
			char_literal18=(IToken)Match(input,56,Follow._56_in_call1123); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_56.Add(char_literal18);

			DebugLocation(167, 17);
			PushFollow(Follow._params__in_call1125);
			params_19=params_();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_params_.Add(params_19.Tree);
			DebugLocation(167, 25);
			char_literal20=(IToken)Match(input,57,Follow._57_in_call1127); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_57.Add(char_literal20);



			{
			// AST REWRITE
			// elements: params_, ident
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 167:30: -> ^( CALL ident ^( ARGS ( params_ )? ) )
			{
				DebugLocation(167, 33);
				// CCompiler.g:167:33: ^( CALL ident ^( ARGS ( params_ )? ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(167, 35);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(167, 40);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(167, 46);
				// CCompiler.g:167:46: ^( ARGS ( params_ )? )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(167, 48);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGS, "ARGS"), root_2);

				DebugLocation(167, 53);
				// CCompiler.g:167:53: ( params_ )?
				if (stream_params_.HasNext)
				{
					DebugLocation(167, 53);
					adaptor.AddChild(root_2, stream_params_.NextTree());

				}
				stream_params_.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("call", 8);
			LeaveRule("call", 8);
			LeaveRule_call();
			if (state.backtracking > 0) { Memoize(input, 8, call_StartIndex); }

		}
		DebugLocation(167, 63);
		} finally { DebugExitRule(GrammarFileName, "call"); }
		return retval;

	}
	// $ANTLR end "call"

	partial void EnterRule_group();
	partial void LeaveRule_group();

	// $ANTLR start "group"
	// CCompiler.g:170:1: group : ( '(' ! term ')' !| NUMBER | TRUE | FALSE | ident | call );
	[GrammarRule("group")]
	private AstParserRuleReturnScope<object, IToken> group()
	{
		EnterRule_group();
		EnterRule("group", 9);
		TraceIn("group", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int group_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal21 = default(IToken);
		IToken char_literal23 = default(IToken);
		IToken NUMBER24 = default(IToken);
		IToken TRUE25 = default(IToken);
		IToken FALSE26 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ident27 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> call28 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal21_tree = default(object);
		object char_literal23_tree = default(object);
		object NUMBER24_tree = default(object);
		object TRUE25_tree = default(object);
		object FALSE26_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "group");
		DebugLocation(170, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 9)) { return retval; }

			// CCompiler.g:170:6: ( '(' ! term ')' !| NUMBER | TRUE | FALSE | ident | call )
			int alt6=6;
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case 56:
				{
				alt6 = 1;
				}
				break;
			case NUMBER:
				{
				alt6 = 2;
				}
				break;
			case TRUE:
				{
				alt6 = 3;
				}
				break;
			case FALSE:
				{
				alt6 = 4;
				}
				break;
			case IDENT:
				{
				int LA6_5 = input.LA(2);

				if ((LA6_5==EOF||(LA6_5>=ADD && LA6_5<=AND)||LA6_5==BIT_OR||LA6_5==COMMA||(LA6_5>=DO && LA6_5<=EQ)||LA6_5==FOR||(LA6_5>=GE && LA6_5<=IF)||LA6_5==LE||LA6_5==LT||(LA6_5>=MUL && LA6_5<=NE)||LA6_5==OR||(LA6_5>=RETURN && LA6_5<=SEMI)||LA6_5==SUB||LA6_5==WHILE||LA6_5==57||(LA6_5>=60 && LA6_5<=61)))
				{
					alt6 = 5;
				}
				else if ((LA6_5==56))
				{
					alt6 = 6;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 6, 5, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:171:3: '(' ! term ')' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(171, 6);
				char_literal21=(IToken)Match(input,56,Follow._56_in_group1154); if (state.failed) return retval;
				DebugLocation(171, 8);
				PushFollow(Follow._term_in_group1157);
				term22=term();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, term22.Tree);
				DebugLocation(171, 16);
				char_literal23=(IToken)Match(input,57,Follow._57_in_group1159); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CCompiler.g:172:3: NUMBER
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(172, 3);
				NUMBER24=(IToken)Match(input,NUMBER,Follow._NUMBER_in_group1164); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NUMBER24_tree = (object)adaptor.Create(NUMBER24);
				adaptor.AddChild(root_0, NUMBER24_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// CCompiler.g:173:3: TRUE
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(173, 3);
				TRUE25=(IToken)Match(input,TRUE,Follow._TRUE_in_group1168); if (state.failed) return retval;
				if (state.backtracking == 0) {
				TRUE25_tree = (object)adaptor.Create(TRUE25);
				adaptor.AddChild(root_0, TRUE25_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// CCompiler.g:174:3: FALSE
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(174, 3);
				FALSE26=(IToken)Match(input,FALSE,Follow._FALSE_in_group1172); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FALSE26_tree = (object)adaptor.Create(FALSE26);
				adaptor.AddChild(root_0, FALSE26_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// CCompiler.g:175:3: ident
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(175, 3);
				PushFollow(Follow._ident_in_group1176);
				ident27=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ident27.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// CCompiler.g:176:3: call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(176, 3);
				PushFollow(Follow._call_in_group1180);
				call28=call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, call28.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("group", 9);
			LeaveRule("group", 9);
			LeaveRule_group();
			if (state.backtracking > 0) { Memoize(input, 9, group_StartIndex); }

		}
		DebugLocation(177, 0);
		} finally { DebugExitRule(GrammarFileName, "group"); }
		return retval;

	}
	// $ANTLR end "group"

	partial void EnterRule_not();
	partial void LeaveRule_not();

	// $ANTLR start "not"
	// CCompiler.g:179:1: not : ( group | NOT ^ not );
	[GrammarRule("not")]
	private AstParserRuleReturnScope<object, IToken> not()
	{
		EnterRule_not();
		EnterRule("not", 10);
		TraceIn("not", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int not_StartIndex = input.Index;

		object root_0 = default(object);

		IToken NOT30 = default(IToken);
		AstParserRuleReturnScope<object, IToken> group29 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> not31 = default(AstParserRuleReturnScope<object, IToken>);

		object NOT30_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "not");
		DebugLocation(179, 24);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 10)) { return retval; }

			// CCompiler.g:179:4: ( group | NOT ^ not )
			int alt7=2;
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==FALSE||LA7_0==IDENT||LA7_0==NUMBER||LA7_0==TRUE||LA7_0==56))
			{
				alt7 = 1;
			}
			else if ((LA7_0==NOT))
			{
				alt7 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:179:8: group
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(179, 8);
				PushFollow(Follow._group_in_not1190);
				group29=group();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group29.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CCompiler.g:179:16: NOT ^ not
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(179, 19);
				NOT30=(IToken)Match(input,NOT,Follow._NOT_in_not1194); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NOT30_tree = (object)adaptor.Create(NOT30);
				root_0 = (object)adaptor.BecomeRoot(NOT30_tree, root_0);
				}
				DebugLocation(179, 21);
				PushFollow(Follow._not_in_not1197);
				not31=not();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, not31.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("not", 10);
			LeaveRule("not", 10);
			LeaveRule_not();
			if (state.backtracking > 0) { Memoize(input, 10, not_StartIndex); }

		}
		DebugLocation(179, 24);
		} finally { DebugExitRule(GrammarFileName, "not"); }
		return retval;

	}
	// $ANTLR end "not"

	partial void EnterRule_mult();
	partial void LeaveRule_mult();

	// $ANTLR start "mult"
	// CCompiler.g:180:1: mult : not ( ( MUL ) ^ not )* ;
	[GrammarRule("mult")]
	private AstParserRuleReturnScope<object, IToken> mult()
	{
		EnterRule_mult();
		EnterRule("mult", 11);
		TraceIn("mult", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int mult_StartIndex = input.Index;

		object root_0 = default(object);

		IToken MUL33 = default(IToken);
		AstParserRuleReturnScope<object, IToken> not32 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> not34 = default(AstParserRuleReturnScope<object, IToken>);

		object MUL33_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mult");
		DebugLocation(180, 29);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 11)) { return retval; }

			// CCompiler.g:180:5: ( not ( ( MUL ) ^ not )* )
			DebugEnterAlt(1);
			// CCompiler.g:180:8: not ( ( MUL ) ^ not )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(180, 8);
			PushFollow(Follow._not_in_mult1205);
			not32=not();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, not32.Tree);
			DebugLocation(180, 12);
			// CCompiler.g:180:12: ( ( MUL ) ^ not )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==MUL))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// CCompiler.g:180:14: ( MUL ) ^ not
					{
					DebugLocation(180, 20);
					// CCompiler.g:180:14: ( MUL )
					DebugEnterAlt(1);
					// CCompiler.g:180:16: MUL
					{
					DebugLocation(180, 16);
					MUL33=(IToken)Match(input,MUL,Follow._MUL_in_mult1211); if (state.failed) return retval;
					if (state.backtracking == 0) {
					MUL33_tree = (object)adaptor.Create(MUL33);
					adaptor.AddChild(root_0, MUL33_tree);
					}

					}

					DebugLocation(180, 22);
					PushFollow(Follow._not_in_mult1215);
					not34=not();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, not34.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mult", 11);
			LeaveRule("mult", 11);
			LeaveRule_mult();
			if (state.backtracking > 0) { Memoize(input, 11, mult_StartIndex); }

		}
		DebugLocation(180, 29);
		} finally { DebugExitRule(GrammarFileName, "mult"); }
		return retval;

	}
	// $ANTLR end "mult"

	partial void EnterRule_add();
	partial void LeaveRule_add();

	// $ANTLR start "add"
	// CCompiler.g:181:1: add : mult ( ( ADD | SUB | BIT_OR ) ^ mult )* ;
	[GrammarRule("add")]
	private AstParserRuleReturnScope<object, IToken> add()
	{
		EnterRule_add();
		EnterRule("add", 12);
		TraceIn("add", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int add_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set36 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mult35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mult37 = default(AstParserRuleReturnScope<object, IToken>);

		object set36_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "add");
		DebugLocation(181, 66);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 12)) { return retval; }

			// CCompiler.g:181:4: ( mult ( ( ADD | SUB | BIT_OR ) ^ mult )* )
			DebugEnterAlt(1);
			// CCompiler.g:181:8: mult ( ( ADD | SUB | BIT_OR ) ^ mult )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(181, 8);
			PushFollow(Follow._mult_in_add1228);
			mult35=mult();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, mult35.Tree);
			DebugLocation(181, 14);
			// CCompiler.g:181:14: ( ( ADD | SUB | BIT_OR ) ^ mult )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==ADD||LA9_0==BIT_OR||LA9_0==SUB))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// CCompiler.g:181:16: ( ADD | SUB | BIT_OR ) ^ mult
					{
					DebugLocation(181, 38);

					set36=(IToken)input.LT(1);
					set36=(IToken)input.LT(1);
					if (input.LA(1)==ADD||input.LA(1)==BIT_OR||input.LA(1)==SUB)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set36), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(181, 40);
					PushFollow(Follow._mult_in_add1248);
					mult37=mult();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mult37.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("add", 12);
			LeaveRule("add", 12);
			LeaveRule_add();
			if (state.backtracking > 0) { Memoize(input, 12, add_StartIndex); }

		}
		DebugLocation(181, 66);
		} finally { DebugExitRule(GrammarFileName, "add"); }
		return retval;

	}
	// $ANTLR end "add"

	partial void EnterRule_compare();
	partial void LeaveRule_compare();

	// $ANTLR start "compare"
	// CCompiler.g:182:1: compare : add ( ( GE | LE | NE | EQ | GT | LT ) ^ add )? ;
	[GrammarRule("compare")]
	private AstParserRuleReturnScope<object, IToken> compare()
	{
		EnterRule_compare();
		EnterRule("compare", 13);
		TraceIn("compare", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int compare_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set39 = default(IToken);
		AstParserRuleReturnScope<object, IToken> add38 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> add40 = default(AstParserRuleReturnScope<object, IToken>);

		object set39_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "compare");
		DebugLocation(182, 57);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 13)) { return retval; }

			// CCompiler.g:182:8: ( add ( ( GE | LE | NE | EQ | GT | LT ) ^ add )? )
			DebugEnterAlt(1);
			// CCompiler.g:182:10: add ( ( GE | LE | NE | EQ | GT | LT ) ^ add )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(182, 10);
			PushFollow(Follow._add_in_compare1277);
			add38=add();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, add38.Tree);
			DebugLocation(182, 14);
			// CCompiler.g:182:14: ( ( GE | LE | NE | EQ | GT | LT ) ^ add )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==EQ||(LA10_0>=GE && LA10_0<=GT)||LA10_0==LE||LA10_0==LT||LA10_0==NE))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:182:16: ( GE | LE | NE | EQ | GT | LT ) ^ add
				{
				DebugLocation(182, 47);

				set39=(IToken)input.LT(1);
				set39=(IToken)input.LT(1);
				if (input.LA(1)==EQ||(input.LA(1)>=GE && input.LA(1)<=GT)||input.LA(1)==LE||input.LA(1)==LT||input.LA(1)==NE)
				{
					input.Consume();
					if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set39), root_0);
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(182, 49);
				PushFollow(Follow._add_in_compare1308);
				add40=add();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, add40.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compare", 13);
			LeaveRule("compare", 13);
			LeaveRule_compare();
			if (state.backtracking > 0) { Memoize(input, 13, compare_StartIndex); }

		}
		DebugLocation(182, 57);
		} finally { DebugExitRule(GrammarFileName, "compare"); }
		return retval;

	}
	// $ANTLR end "compare"

	partial void EnterRule_and_logic();
	partial void LeaveRule_and_logic();

	// $ANTLR start "and_logic"
	// CCompiler.g:183:1: and_logic : compare ( AND ^ compare )* ;
	[GrammarRule("and_logic")]
	private AstParserRuleReturnScope<object, IToken> and_logic()
	{
		EnterRule_and_logic();
		EnterRule("and_logic", 14);
		TraceIn("and_logic", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int and_logic_StartIndex = input.Index;

		object root_0 = default(object);

		IToken AND42 = default(IToken);
		AstParserRuleReturnScope<object, IToken> compare41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> compare43 = default(AstParserRuleReturnScope<object, IToken>);

		object AND42_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "and_logic");
		DebugLocation(183, 40);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 14)) { return retval; }

			// CCompiler.g:183:10: ( compare ( AND ^ compare )* )
			DebugEnterAlt(1);
			// CCompiler.g:183:12: compare ( AND ^ compare )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(183, 12);
			PushFollow(Follow._compare_in_and_logic1320);
			compare41=compare();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, compare41.Tree);
			DebugLocation(183, 20);
			// CCompiler.g:183:20: ( AND ^ compare )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==AND))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// CCompiler.g:183:22: AND ^ compare
					{
					DebugLocation(183, 25);
					AND42=(IToken)Match(input,AND,Follow._AND_in_and_logic1324); if (state.failed) return retval;
					if (state.backtracking == 0) {
					AND42_tree = (object)adaptor.Create(AND42);
					root_0 = (object)adaptor.BecomeRoot(AND42_tree, root_0);
					}
					DebugLocation(183, 27);
					PushFollow(Follow._compare_in_and_logic1327);
					compare43=compare();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, compare43.Tree);

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("and_logic", 14);
			LeaveRule("and_logic", 14);
			LeaveRule_and_logic();
			if (state.backtracking > 0) { Memoize(input, 14, and_logic_StartIndex); }

		}
		DebugLocation(183, 40);
		} finally { DebugExitRule(GrammarFileName, "and_logic"); }
		return retval;

	}
	// $ANTLR end "and_logic"

	partial void EnterRule_or_logic();
	partial void LeaveRule_or_logic();

	// $ANTLR start "or_logic"
	// CCompiler.g:184:1: or_logic : and_logic ( OR ^ and_logic )* ;
	[GrammarRule("or_logic")]
	private AstParserRuleReturnScope<object, IToken> or_logic()
	{
		EnterRule_or_logic();
		EnterRule("or_logic", 15);
		TraceIn("or_logic", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int or_logic_StartIndex = input.Index;

		object root_0 = default(object);

		IToken OR45 = default(IToken);
		AstParserRuleReturnScope<object, IToken> and_logic44 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> and_logic46 = default(AstParserRuleReturnScope<object, IToken>);

		object OR45_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "or_logic");
		DebugLocation(184, 40);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 15)) { return retval; }

			// CCompiler.g:184:9: ( and_logic ( OR ^ and_logic )* )
			DebugEnterAlt(1);
			// CCompiler.g:184:11: and_logic ( OR ^ and_logic )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(184, 11);
			PushFollow(Follow._and_logic_in_or_logic1340);
			and_logic44=and_logic();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, and_logic44.Tree);
			DebugLocation(184, 21);
			// CCompiler.g:184:21: ( OR ^ and_logic )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==OR))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// CCompiler.g:184:23: OR ^ and_logic
					{
					DebugLocation(184, 25);
					OR45=(IToken)Match(input,OR,Follow._OR_in_or_logic1344); if (state.failed) return retval;
					if (state.backtracking == 0) {
					OR45_tree = (object)adaptor.Create(OR45);
					root_0 = (object)adaptor.BecomeRoot(OR45_tree, root_0);
					}
					DebugLocation(184, 27);
					PushFollow(Follow._and_logic_in_or_logic1347);
					and_logic46=and_logic();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, and_logic46.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("or_logic", 15);
			LeaveRule("or_logic", 15);
			LeaveRule_or_logic();
			if (state.backtracking > 0) { Memoize(input, 15, or_logic_StartIndex); }

		}
		DebugLocation(184, 40);
		} finally { DebugExitRule(GrammarFileName, "or_logic"); }
		return retval;

	}
	// $ANTLR end "or_logic"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// CCompiler.g:185:1: term : or_logic ;
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 16);
		TraceIn("term", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int term_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> or_logic47 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(185, 16);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 16)) { return retval; }

			// CCompiler.g:185:5: ( or_logic )
			DebugEnterAlt(1);
			// CCompiler.g:185:7: or_logic
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(185, 7);
			PushFollow(Follow._or_logic_in_term1358);
			or_logic47=or_logic();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, or_logic47.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 16);
			LeaveRule("term", 16);
			LeaveRule_term();
			if (state.backtracking > 0) { Memoize(input, 16, term_StartIndex); }

		}
		DebugLocation(185, 16);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_varDecl();
	partial void LeaveRule_varDecl();

	// $ANTLR start "varDecl"
	// CCompiler.g:212:1: varDecl : ident ( ASSIGN ^ term )? ;
	[GrammarRule("varDecl")]
	private AstParserRuleReturnScope<object, IToken> varDecl()
	{
		EnterRule_varDecl();
		EnterRule("varDecl", 17);
		TraceIn("varDecl", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int varDecl_StartIndex = input.Index;

		object root_0 = default(object);

		IToken ASSIGN49 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ident48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term50 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN49_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "varDecl");
		DebugLocation(212, 30);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 17)) { return retval; }

			// CCompiler.g:212:8: ( ident ( ASSIGN ^ term )? )
			DebugEnterAlt(1);
			// CCompiler.g:212:10: ident ( ASSIGN ^ term )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(212, 10);
			PushFollow(Follow._ident_in_varDecl1372);
			ident48=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, ident48.Tree);
			DebugLocation(212, 16);
			// CCompiler.g:212:16: ( ASSIGN ^ term )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==ASSIGN))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:212:17: ASSIGN ^ term
				{
				DebugLocation(212, 23);
				ASSIGN49=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_varDecl1375); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ASSIGN49_tree = (object)adaptor.Create(ASSIGN49);
				root_0 = (object)adaptor.BecomeRoot(ASSIGN49_tree, root_0);
				}
				DebugLocation(212, 25);
				PushFollow(Follow._term_in_varDecl1378);
				term50=term();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, term50.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("varDecl", 17);
			LeaveRule("varDecl", 17);
			LeaveRule_varDecl();
			if (state.backtracking > 0) { Memoize(input, 17, varDecl_StartIndex); }

		}
		DebugLocation(212, 30);
		} finally { DebugExitRule(GrammarFileName, "varDecl"); }
		return retval;

	}
	// $ANTLR end "varDecl"

	partial void EnterRule_varsDecl();
	partial void LeaveRule_varsDecl();

	// $ANTLR start "varsDecl"
	// CCompiler.g:213:1: varsDecl : ident varDecl ( ',' varDecl )* -> ^( VAR ^( ident ( varDecl )+ ) ) ;
	[GrammarRule("varsDecl")]
	private AstParserRuleReturnScope<object, IToken> varsDecl()
	{
		EnterRule_varsDecl();
		EnterRule("varsDecl", 18);
		TraceIn("varsDecl", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int varsDecl_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal53 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ident51 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> varDecl52 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> varDecl54 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal53_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_varDecl=new RewriteRuleSubtreeStream(adaptor,"rule varDecl");
		try { DebugEnterRule(GrammarFileName, "varsDecl");
		DebugLocation(213, 69);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 18)) { return retval; }

			// CCompiler.g:213:9: ( ident varDecl ( ',' varDecl )* -> ^( VAR ^( ident ( varDecl )+ ) ) )
			DebugEnterAlt(1);
			// CCompiler.g:213:11: ident varDecl ( ',' varDecl )*
			{
			DebugLocation(213, 11);
			PushFollow(Follow._ident_in_varsDecl1386);
			ident51=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident51.Tree);
			DebugLocation(213, 17);
			PushFollow(Follow._varDecl_in_varsDecl1388);
			varDecl52=varDecl();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_varDecl.Add(varDecl52.Tree);
			DebugLocation(213, 25);
			// CCompiler.g:213:25: ( ',' varDecl )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==COMMA))
				{
					int LA14_2 = input.LA(2);

					if ((LA14_2==IDENT))
					{
						int LA14_3 = input.LA(3);

						if ((EvaluatePredicate(synpred25_CCompiler_fragment)))
						{
							alt14 = 1;
						}


					}


				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// CCompiler.g:213:27: ',' varDecl
					{
					DebugLocation(213, 27);
					char_literal53=(IToken)Match(input,COMMA,Follow._COMMA_in_varsDecl1392); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(char_literal53);

					DebugLocation(213, 31);
					PushFollow(Follow._varDecl_in_varsDecl1394);
					varDecl54=varDecl();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_varDecl.Add(varDecl54.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }



			{
			// AST REWRITE
			// elements: varDecl, ident
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 213:42: -> ^( VAR ^( ident ( varDecl )+ ) )
			{
				DebugLocation(213, 45);
				// CCompiler.g:213:45: ^( VAR ^( ident ( varDecl )+ ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(213, 47);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, "VAR"), root_1);

				DebugLocation(213, 51);
				// CCompiler.g:213:51: ^( ident ( varDecl )+ )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(213, 53);
				root_2 = (object)adaptor.BecomeRoot(stream_ident.NextNode(), root_2);

				DebugLocation(213, 59);
				if (!(stream_varDecl.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_varDecl.HasNext )
				{
					DebugLocation(213, 59);
					adaptor.AddChild(root_2, stream_varDecl.NextTree());

				}
				stream_varDecl.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("varsDecl", 18);
			LeaveRule("varsDecl", 18);
			LeaveRule_varsDecl();
			if (state.backtracking > 0) { Memoize(input, 18, varsDecl_StartIndex); }

		}
		DebugLocation(213, 69);
		} finally { DebugExitRule(GrammarFileName, "varsDecl"); }
		return retval;

	}
	// $ANTLR end "varsDecl"

	partial void EnterRule_expr0();
	partial void LeaveRule_expr0();

	// $ANTLR start "expr0"
	// CCompiler.g:216:1: expr0 : ( ident ASSIGN ^ term | ident -> ^( CALL ident ARGS ) | call | varsDecl );
	[GrammarRule("expr0")]
	private AstParserRuleReturnScope<object, IToken> expr0()
	{
		EnterRule_expr0();
		EnterRule("expr0", 19);
		TraceIn("expr0", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expr0_StartIndex = input.Index;

		object root_0 = default(object);

		IToken ASSIGN56 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ident55 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term57 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ident58 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> call59 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> varsDecl60 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN56_tree = default(object);
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		try { DebugEnterRule(GrammarFileName, "expr0");
		DebugLocation(216, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 19)) { return retval; }

			// CCompiler.g:216:6: ( ident ASSIGN ^ term | ident -> ^( CALL ident ARGS ) | call | varsDecl )
			int alt15=4;
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==IDENT))
			{
				switch (input.LA(2))
				{
				case ASSIGN:
					{
					alt15 = 1;
					}
					break;
				case EOF:
				case COMMA:
				case SEMI:
				case 57:
					{
					alt15 = 2;
					}
					break;
				case 56:
					{
					alt15 = 3;
					}
					break;
				case IDENT:
					{
					alt15 = 4;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 15, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:217:3: ident ASSIGN ^ term
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(217, 3);
				PushFollow(Follow._ident_in_expr01421);
				ident55=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ident55.Tree);
				DebugLocation(217, 15);
				ASSIGN56=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_expr01423); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ASSIGN56_tree = (object)adaptor.Create(ASSIGN56);
				root_0 = (object)adaptor.BecomeRoot(ASSIGN56_tree, root_0);
				}
				DebugLocation(217, 17);
				PushFollow(Follow._term_in_expr01426);
				term57=term();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, term57.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CCompiler.g:218:3: ident
				{
				DebugLocation(218, 3);
				PushFollow(Follow._ident_in_expr01430);
				ident58=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ident.Add(ident58.Tree);


				{
				// AST REWRITE
				// elements: ident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 218:9: -> ^( CALL ident ARGS )
				{
					DebugLocation(218, 12);
					// CCompiler.g:218:12: ^( CALL ident ARGS )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(218, 14);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

					DebugLocation(218, 19);
					adaptor.AddChild(root_1, stream_ident.NextTree());
					DebugLocation(218, 25);
					adaptor.AddChild(root_1, (object)adaptor.Create(ARGS, "ARGS"));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// CCompiler.g:219:3: call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(219, 3);
				PushFollow(Follow._call_in_expr01444);
				call59=call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, call59.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// CCompiler.g:220:3: varsDecl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(220, 3);
				PushFollow(Follow._varsDecl_in_expr01448);
				varsDecl60=varsDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, varsDecl60.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr0", 19);
			LeaveRule("expr0", 19);
			LeaveRule_expr0();
			if (state.backtracking > 0) { Memoize(input, 19, expr0_StartIndex); }

		}
		DebugLocation(221, 0);
		} finally { DebugExitRule(GrammarFileName, "expr0"); }
		return retval;

	}
	// $ANTLR end "expr0"

	partial void EnterRule_blockExpr();
	partial void LeaveRule_blockExpr();

	// $ANTLR start "blockExpr"
	// CCompiler.g:223:1: blockExpr : '{' ! exprList '}' !;
	[GrammarRule("blockExpr")]
	private AstParserRuleReturnScope<object, IToken> blockExpr()
	{
		EnterRule_blockExpr();
		EnterRule("blockExpr", 20);
		TraceIn("blockExpr", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int blockExpr_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal61 = default(IToken);
		IToken char_literal63 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exprList62 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal61_tree = default(object);
		object char_literal63_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "blockExpr");
		DebugLocation(223, 30);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 20)) { return retval; }

			// CCompiler.g:223:10: ( '{' ! exprList '}' !)
			DebugEnterAlt(1);
			// CCompiler.g:223:12: '{' ! exprList '}' !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(223, 15);
			char_literal61=(IToken)Match(input,60,Follow._60_in_blockExpr1456); if (state.failed) return retval;
			DebugLocation(223, 17);
			PushFollow(Follow._exprList_in_blockExpr1459);
			exprList62=exprList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, exprList62.Tree);
			DebugLocation(223, 29);
			char_literal63=(IToken)Match(input,61,Follow._61_in_blockExpr1461); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("blockExpr", 20);
			LeaveRule("blockExpr", 20);
			LeaveRule_blockExpr();
			if (state.backtracking > 0) { Memoize(input, 20, blockExpr_StartIndex); }

		}
		DebugLocation(223, 30);
		} finally { DebugExitRule(GrammarFileName, "blockExpr"); }
		return retval;

	}
	// $ANTLR end "blockExpr"

	partial void EnterRule_termOrTrue();
	partial void LeaveRule_termOrTrue();

	// $ANTLR start "termOrTrue"
	// CCompiler.g:224:1: termOrTrue : ( term | () -> TRUE );
	[GrammarRule("termOrTrue")]
	private AstParserRuleReturnScope<object, IToken> termOrTrue()
	{
		EnterRule_termOrTrue();
		EnterRule("termOrTrue", 21);
		TraceIn("termOrTrue", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int termOrTrue_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> term64 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "termOrTrue");
		DebugLocation(224, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 21)) { return retval; }

			// CCompiler.g:224:11: ( term | () -> TRUE )
			int alt16=2;
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==FALSE||LA16_0==IDENT||(LA16_0>=NOT && LA16_0<=NUMBER)||LA16_0==TRUE||LA16_0==56))
			{
				alt16 = 1;
			}
			else if ((LA16_0==SEMI))
			{
				alt16 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:225:3: term
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(225, 3);
				PushFollow(Follow._term_in_termOrTrue1472);
				term64=term();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, term64.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CCompiler.g:226:3: ()
				{
				DebugLocation(226, 3);
				// CCompiler.g:226:3: ()
				DebugEnterAlt(1);
				// CCompiler.g:226:5: 
				{
				}



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 226:7: -> TRUE
				{
					DebugLocation(226, 10);
					adaptor.AddChild(root_0, (object)adaptor.Create(TRUE, "TRUE"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("termOrTrue", 21);
			LeaveRule("termOrTrue", 21);
			LeaveRule_termOrTrue();
			if (state.backtracking > 0) { Memoize(input, 21, termOrTrue_StartIndex); }

		}
		DebugLocation(227, 0);
		} finally { DebugExitRule(GrammarFileName, "termOrTrue"); }
		return retval;

	}
	// $ANTLR end "termOrTrue"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// CCompiler.g:229:1: expr : ( expr0 ';' !| IF ^ '(' ! term ')' ! expr ( ELSE ! expr )? | WHILE ^ '(' ! term ')' ! expr | FOR ^ '(' ! exprList2 ';' ! termOrTrue ';' ! exprList2 ')' ! expr | DO ^ expr WHILE ! term | RETURN ^ term ';' !| call ';' !| blockExpr );
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 22);
		TraceIn("expr", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expr_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal66 = default(IToken);
		IToken IF67 = default(IToken);
		IToken char_literal68 = default(IToken);
		IToken char_literal70 = default(IToken);
		IToken ELSE72 = default(IToken);
		IToken WHILE74 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken char_literal77 = default(IToken);
		IToken FOR79 = default(IToken);
		IToken char_literal80 = default(IToken);
		IToken char_literal82 = default(IToken);
		IToken char_literal84 = default(IToken);
		IToken char_literal86 = default(IToken);
		IToken DO88 = default(IToken);
		IToken WHILE90 = default(IToken);
		IToken RETURN92 = default(IToken);
		IToken char_literal94 = default(IToken);
		IToken char_literal96 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr065 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term69 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr71 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr73 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term76 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr78 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exprList281 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> termOrTrue83 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exprList285 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr87 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr89 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term91 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term93 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> call95 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> blockExpr97 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal66_tree = default(object);
		object IF67_tree = default(object);
		object char_literal68_tree = default(object);
		object char_literal70_tree = default(object);
		object ELSE72_tree = default(object);
		object WHILE74_tree = default(object);
		object char_literal75_tree = default(object);
		object char_literal77_tree = default(object);
		object FOR79_tree = default(object);
		object char_literal80_tree = default(object);
		object char_literal82_tree = default(object);
		object char_literal84_tree = default(object);
		object char_literal86_tree = default(object);
		object DO88_tree = default(object);
		object WHILE90_tree = default(object);
		object RETURN92_tree = default(object);
		object char_literal94_tree = default(object);
		object char_literal96_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(229, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 22)) { return retval; }

			// CCompiler.g:229:5: ( expr0 ';' !| IF ^ '(' ! term ')' ! expr ( ELSE ! expr )? | WHILE ^ '(' ! term ')' ! expr | FOR ^ '(' ! exprList2 ';' ! termOrTrue ';' ! exprList2 ')' ! expr | DO ^ expr WHILE ! term | RETURN ^ term ';' !| call ';' !| blockExpr )
			int alt18=8;
			try { DebugEnterDecision(18, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				int LA18_1 = input.LA(2);

				if ((EvaluatePredicate(synpred30_CCompiler_fragment)))
				{
					alt18 = 1;
				}
				else if ((EvaluatePredicate(synpred37_CCompiler_fragment)))
				{
					alt18 = 7;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 18, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IF:
				{
				alt18 = 2;
				}
				break;
			case WHILE:
				{
				alt18 = 3;
				}
				break;
			case FOR:
				{
				alt18 = 4;
				}
				break;
			case DO:
				{
				alt18 = 5;
				}
				break;
			case RETURN:
				{
				alt18 = 6;
				}
				break;
			case 60:
				{
				alt18 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 18, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:230:3: expr0 ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(230, 3);
				PushFollow(Follow._expr0_in_expr1492);
				expr065=expr0();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr065.Tree);
				DebugLocation(230, 12);
				char_literal66=(IToken)Match(input,SEMI,Follow._SEMI_in_expr1494); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CCompiler.g:231:3: IF ^ '(' ! term ')' ! expr ( ELSE ! expr )?
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(231, 5);
				IF67=(IToken)Match(input,IF,Follow._IF_in_expr1499); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IF67_tree = (object)adaptor.Create(IF67);
				root_0 = (object)adaptor.BecomeRoot(IF67_tree, root_0);
				}
				DebugLocation(231, 10);
				char_literal68=(IToken)Match(input,56,Follow._56_in_expr1502); if (state.failed) return retval;
				DebugLocation(231, 12);
				PushFollow(Follow._term_in_expr1505);
				term69=term();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, term69.Tree);
				DebugLocation(231, 20);
				char_literal70=(IToken)Match(input,57,Follow._57_in_expr1507); if (state.failed) return retval;
				DebugLocation(231, 22);
				PushFollow(Follow._expr_in_expr1510);
				expr71=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr71.Tree);
				DebugLocation(231, 27);
				// CCompiler.g:231:27: ( ELSE ! expr )?
				int alt17=2;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==ELSE))
				{
					int LA17_1 = input.LA(2);

					if ((EvaluatePredicate(synpred31_CCompiler_fragment)))
					{
						alt17 = 1;
					}
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// CCompiler.g:231:28: ELSE ! expr
					{
					DebugLocation(231, 32);
					ELSE72=(IToken)Match(input,ELSE,Follow._ELSE_in_expr1513); if (state.failed) return retval;
					DebugLocation(231, 34);
					PushFollow(Follow._expr_in_expr1516);
					expr73=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr73.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(17); }


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// CCompiler.g:232:3: WHILE ^ '(' ! term ')' ! expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(232, 8);
				WHILE74=(IToken)Match(input,WHILE,Follow._WHILE_in_expr1522); if (state.failed) return retval;
				if (state.backtracking == 0) {
				WHILE74_tree = (object)adaptor.Create(WHILE74);
				root_0 = (object)adaptor.BecomeRoot(WHILE74_tree, root_0);
				}
				DebugLocation(232, 13);
				char_literal75=(IToken)Match(input,56,Follow._56_in_expr1525); if (state.failed) return retval;
				DebugLocation(232, 15);
				PushFollow(Follow._term_in_expr1528);
				term76=term();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, term76.Tree);
				DebugLocation(232, 23);
				char_literal77=(IToken)Match(input,57,Follow._57_in_expr1530); if (state.failed) return retval;
				DebugLocation(232, 25);
				PushFollow(Follow._expr_in_expr1533);
				expr78=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr78.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// CCompiler.g:233:3: FOR ^ '(' ! exprList2 ';' ! termOrTrue ';' ! exprList2 ')' ! expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(233, 6);
				FOR79=(IToken)Match(input,FOR,Follow._FOR_in_expr1537); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FOR79_tree = (object)adaptor.Create(FOR79);
				root_0 = (object)adaptor.BecomeRoot(FOR79_tree, root_0);
				}
				DebugLocation(233, 11);
				char_literal80=(IToken)Match(input,56,Follow._56_in_expr1540); if (state.failed) return retval;
				DebugLocation(233, 13);
				PushFollow(Follow._exprList2_in_expr1543);
				exprList281=exprList2();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, exprList281.Tree);
				DebugLocation(233, 26);
				char_literal82=(IToken)Match(input,SEMI,Follow._SEMI_in_expr1545); if (state.failed) return retval;
				DebugLocation(233, 28);
				PushFollow(Follow._termOrTrue_in_expr1548);
				termOrTrue83=termOrTrue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, termOrTrue83.Tree);
				DebugLocation(233, 42);
				char_literal84=(IToken)Match(input,SEMI,Follow._SEMI_in_expr1550); if (state.failed) return retval;
				DebugLocation(233, 44);
				PushFollow(Follow._exprList2_in_expr1553);
				exprList285=exprList2();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, exprList285.Tree);
				DebugLocation(233, 57);
				char_literal86=(IToken)Match(input,57,Follow._57_in_expr1555); if (state.failed) return retval;
				DebugLocation(233, 59);
				PushFollow(Follow._expr_in_expr1558);
				expr87=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr87.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// CCompiler.g:234:3: DO ^ expr WHILE ! term
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(234, 5);
				DO88=(IToken)Match(input,DO,Follow._DO_in_expr1562); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DO88_tree = (object)adaptor.Create(DO88);
				root_0 = (object)adaptor.BecomeRoot(DO88_tree, root_0);
				}
				DebugLocation(234, 7);
				PushFollow(Follow._expr_in_expr1565);
				expr89=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr89.Tree);
				DebugLocation(234, 17);
				WHILE90=(IToken)Match(input,WHILE,Follow._WHILE_in_expr1567); if (state.failed) return retval;
				DebugLocation(234, 19);
				PushFollow(Follow._term_in_expr1570);
				term91=term();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, term91.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// CCompiler.g:235:3: RETURN ^ term ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(235, 9);
				RETURN92=(IToken)Match(input,RETURN,Follow._RETURN_in_expr1574); if (state.failed) return retval;
				if (state.backtracking == 0) {
				RETURN92_tree = (object)adaptor.Create(RETURN92);
				root_0 = (object)adaptor.BecomeRoot(RETURN92_tree, root_0);
				}
				DebugLocation(235, 11);
				PushFollow(Follow._term_in_expr1577);
				term93=term();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, term93.Tree);
				DebugLocation(235, 19);
				char_literal94=(IToken)Match(input,SEMI,Follow._SEMI_in_expr1579); if (state.failed) return retval;

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// CCompiler.g:236:3: call ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(236, 3);
				PushFollow(Follow._call_in_expr1584);
				call95=call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, call95.Tree);
				DebugLocation(236, 11);
				char_literal96=(IToken)Match(input,SEMI,Follow._SEMI_in_expr1586); if (state.failed) return retval;

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// CCompiler.g:237:3: blockExpr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(237, 3);
				PushFollow(Follow._blockExpr_in_expr1592);
				blockExpr97=blockExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, blockExpr97.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 22);
			LeaveRule("expr", 22);
			LeaveRule_expr();
			if (state.backtracking > 0) { Memoize(input, 22, expr_StartIndex); }

		}
		DebugLocation(238, 0);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_exprList();
	partial void LeaveRule_exprList();

	// $ANTLR start "exprList"
	// CCompiler.g:255:1: exprList : ( expr ( ( ';' )* expr )* )? ( ';' )* -> ^( BLOCK ( expr )* ) ;
	[GrammarRule("exprList")]
	private AstParserRuleReturnScope<object, IToken> exprList()
	{
		EnterRule_exprList();
		EnterRule("exprList", 23);
		TraceIn("exprList", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int exprList_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal99 = default(IToken);
		IToken char_literal101 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr98 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr100 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal99_tree = default(object);
		object char_literal101_tree = default(object);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "exprList");
		DebugLocation(255, 61);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 23)) { return retval; }

			// CCompiler.g:255:9: ( ( expr ( ( ';' )* expr )* )? ( ';' )* -> ^( BLOCK ( expr )* ) )
			DebugEnterAlt(1);
			// CCompiler.g:255:11: ( expr ( ( ';' )* expr )* )? ( ';' )*
			{
			DebugLocation(255, 11);
			// CCompiler.g:255:11: ( expr ( ( ';' )* expr )* )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_0 = input.LA(1);

			if ((LA21_0==DO||LA21_0==FOR||(LA21_0>=IDENT && LA21_0<=IF)||LA21_0==RETURN||LA21_0==WHILE||LA21_0==60))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:255:13: expr ( ( ';' )* expr )*
				{
				DebugLocation(255, 13);
				PushFollow(Follow._expr_in_exprList1605);
				expr98=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr98.Tree);
				DebugLocation(255, 18);
				// CCompiler.g:255:18: ( ( ';' )* expr )*
				try { DebugEnterSubRule(20);
				while (true)
				{
					int alt20=2;
					try { DebugEnterDecision(20, false);
					try
					{
						alt20 = dfa20.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(20); }
					switch ( alt20 )
					{
					case 1:
						DebugEnterAlt(1);
						// CCompiler.g:255:20: ( ';' )* expr
						{
						DebugLocation(255, 20);
						// CCompiler.g:255:20: ( ';' )*
						try { DebugEnterSubRule(19);
						while (true)
						{
							int alt19=2;
							try { DebugEnterDecision(19, false);
							int LA19_0 = input.LA(1);

							if ((LA19_0==SEMI))
							{
								alt19 = 1;
							}


							} finally { DebugExitDecision(19); }
							switch ( alt19 )
							{
							case 1:
								DebugEnterAlt(1);
								// CCompiler.g:255:20: ';'
								{
								DebugLocation(255, 20);
								char_literal99=(IToken)Match(input,SEMI,Follow._SEMI_in_exprList1609); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_SEMI.Add(char_literal99);


								}
								break;

							default:
								goto loop19;
							}
						}

						loop19:
							;

						} finally { DebugExitSubRule(19); }

						DebugLocation(255, 25);
						PushFollow(Follow._expr_in_exprList1612);
						expr100=expr();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expr.Add(expr100.Tree);

						}
						break;

					default:
						goto loop20;
					}
				}

				loop20:
					;

				} finally { DebugExitSubRule(20); }


				}
				break;

			}
			} finally { DebugExitSubRule(21); }

			DebugLocation(255, 36);
			// CCompiler.g:255:36: ( ';' )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==SEMI))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// CCompiler.g:255:36: ';'
					{
					DebugLocation(255, 36);
					char_literal101=(IToken)Match(input,SEMI,Follow._SEMI_in_exprList1620); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SEMI.Add(char_literal101);


					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 255:42: -> ^( BLOCK ( expr )* )
			{
				DebugLocation(255, 46);
				// CCompiler.g:255:46: ^( BLOCK ( expr )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(255, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK, "BLOCK"), root_1);

				DebugLocation(255, 54);
				// CCompiler.g:255:54: ( expr )*
				while ( stream_expr.HasNext )
				{
					DebugLocation(255, 54);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprList", 23);
			LeaveRule("exprList", 23);
			LeaveRule_exprList();
			if (state.backtracking > 0) { Memoize(input, 23, exprList_StartIndex); }

		}
		DebugLocation(255, 61);
		} finally { DebugExitRule(GrammarFileName, "exprList"); }
		return retval;

	}
	// $ANTLR end "exprList"

	partial void EnterRule_exprList2();
	partial void LeaveRule_exprList2();

	// $ANTLR start "exprList2"
	// CCompiler.g:256:1: exprList2 : ( expr0 ( ',' expr0 )* )? -> ^( BLOCK ( expr0 )* ) ;
	[GrammarRule("exprList2")]
	private AstParserRuleReturnScope<object, IToken> exprList2()
	{
		EnterRule_exprList2();
		EnterRule("exprList2", 24);
		TraceIn("exprList2", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int exprList2_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal103 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr0102 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr0104 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal103_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expr0=new RewriteRuleSubtreeStream(adaptor,"rule expr0");
		try { DebugEnterRule(GrammarFileName, "exprList2");
		DebugLocation(256, 59);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 24)) { return retval; }

			// CCompiler.g:256:10: ( ( expr0 ( ',' expr0 )* )? -> ^( BLOCK ( expr0 )* ) )
			DebugEnterAlt(1);
			// CCompiler.g:256:12: ( expr0 ( ',' expr0 )* )?
			{
			DebugLocation(256, 12);
			// CCompiler.g:256:12: ( expr0 ( ',' expr0 )* )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==IDENT))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:256:14: expr0 ( ',' expr0 )*
				{
				DebugLocation(256, 14);
				PushFollow(Follow._expr0_in_exprList21642);
				expr0102=expr0();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr0.Add(expr0102.Tree);
				DebugLocation(256, 20);
				// CCompiler.g:256:20: ( ',' expr0 )*
				try { DebugEnterSubRule(23);
				while (true)
				{
					int alt23=2;
					try { DebugEnterDecision(23, false);
					int LA23_0 = input.LA(1);

					if ((LA23_0==COMMA))
					{
						alt23 = 1;
					}


					} finally { DebugExitDecision(23); }
					switch ( alt23 )
					{
					case 1:
						DebugEnterAlt(1);
						// CCompiler.g:256:22: ',' expr0
						{
						DebugLocation(256, 22);
						char_literal103=(IToken)Match(input,COMMA,Follow._COMMA_in_exprList21646); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(char_literal103);

						DebugLocation(256, 26);
						PushFollow(Follow._expr0_in_exprList21648);
						expr0104=expr0();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expr0.Add(expr0104.Tree);

						}
						break;

					default:
						goto loop23;
					}
				}

				loop23:
					;

				} finally { DebugExitSubRule(23); }


				}
				break;

			}
			} finally { DebugExitSubRule(24); }



			{
			// AST REWRITE
			// elements: expr0
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 256:39: -> ^( BLOCK ( expr0 )* )
			{
				DebugLocation(256, 43);
				// CCompiler.g:256:43: ^( BLOCK ( expr0 )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(256, 45);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK, "BLOCK"), root_1);

				DebugLocation(256, 51);
				// CCompiler.g:256:51: ( expr0 )*
				while ( stream_expr0.HasNext )
				{
					DebugLocation(256, 51);
					adaptor.AddChild(root_1, stream_expr0.NextTree());

				}
				stream_expr0.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprList2", 24);
			LeaveRule("exprList2", 24);
			LeaveRule_exprList2();
			if (state.backtracking > 0) { Memoize(input, 24, exprList2_StartIndex); }

		}
		DebugLocation(256, 59);
		} finally { DebugExitRule(GrammarFileName, "exprList2"); }
		return retval;

	}
	// $ANTLR end "exprList2"

	partial void EnterRule_argDecl();
	partial void LeaveRule_argDecl();

	// $ANTLR start "argDecl"
	// CCompiler.g:258:1: argDecl : type IDENT ^;
	[GrammarRule("argDecl")]
	private AstParserRuleReturnScope<object, IToken> argDecl()
	{
		EnterRule_argDecl();
		EnterRule("argDecl", 25);
		TraceIn("argDecl", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int argDecl_StartIndex = input.Index;

		object root_0 = default(object);

		IToken IDENT106 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type105 = default(AstParserRuleReturnScope<object, IToken>);

		object IDENT106_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "argDecl");
		DebugLocation(258, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 25)) { return retval; }

			// CCompiler.g:258:8: ( type IDENT ^)
			DebugEnterAlt(1);
			// CCompiler.g:259:3: type IDENT ^
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(259, 3);
			PushFollow(Follow._type_in_argDecl1676);
			type105=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, type105.Tree);
			DebugLocation(259, 13);
			IDENT106=(IToken)Match(input,IDENT,Follow._IDENT_in_argDecl1678); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IDENT106_tree = (object)adaptor.Create(IDENT106);
			root_0 = (object)adaptor.BecomeRoot(IDENT106_tree, root_0);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("argDecl", 25);
			LeaveRule("argDecl", 25);
			LeaveRule_argDecl();
			if (state.backtracking > 0) { Memoize(input, 25, argDecl_StartIndex); }

		}
		DebugLocation(260, 0);
		} finally { DebugExitRule(GrammarFileName, "argDecl"); }
		return retval;

	}
	// $ANTLR end "argDecl"

	partial void EnterRule_argsDecl();
	partial void LeaveRule_argsDecl();

	// $ANTLR start "argsDecl"
	// CCompiler.g:261:1: argsDecl : ( argDecl ( ',' argDecl )* )? -> ^( ARGS_DECL ( argDecl )* ) ;
	[GrammarRule("argsDecl")]
	private AstParserRuleReturnScope<object, IToken> argsDecl()
	{
		EnterRule_argsDecl();
		EnterRule("argsDecl", 26);
		TraceIn("argsDecl", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int argsDecl_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal108 = default(IToken);
		AstParserRuleReturnScope<object, IToken> argDecl107 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> argDecl109 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal108_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_argDecl=new RewriteRuleSubtreeStream(adaptor,"rule argDecl");
		try { DebugEnterRule(GrammarFileName, "argsDecl");
		DebugLocation(261, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 26)) { return retval; }

			// CCompiler.g:261:9: ( ( argDecl ( ',' argDecl )* )? -> ^( ARGS_DECL ( argDecl )* ) )
			DebugEnterAlt(1);
			// CCompiler.g:262:3: ( argDecl ( ',' argDecl )* )?
			{
			DebugLocation(262, 3);
			// CCompiler.g:262:3: ( argDecl ( ',' argDecl )* )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==IDENT))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:262:4: argDecl ( ',' argDecl )*
				{
				DebugLocation(262, 4);
				PushFollow(Follow._argDecl_in_argsDecl1689);
				argDecl107=argDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_argDecl.Add(argDecl107.Tree);
				DebugLocation(262, 12);
				// CCompiler.g:262:12: ( ',' argDecl )*
				try { DebugEnterSubRule(25);
				while (true)
				{
					int alt25=2;
					try { DebugEnterDecision(25, false);
					int LA25_0 = input.LA(1);

					if ((LA25_0==COMMA))
					{
						alt25 = 1;
					}


					} finally { DebugExitDecision(25); }
					switch ( alt25 )
					{
					case 1:
						DebugEnterAlt(1);
						// CCompiler.g:262:13: ',' argDecl
						{
						DebugLocation(262, 13);
						char_literal108=(IToken)Match(input,COMMA,Follow._COMMA_in_argsDecl1692); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(char_literal108);

						DebugLocation(262, 17);
						PushFollow(Follow._argDecl_in_argsDecl1694);
						argDecl109=argDecl();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_argDecl.Add(argDecl109.Tree);

						}
						break;

					default:
						goto loop25;
					}
				}

				loop25:
					;

				} finally { DebugExitSubRule(25); }


				}
				break;

			}
			} finally { DebugExitSubRule(26); }



			{
			// AST REWRITE
			// elements: argDecl
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 262:30: -> ^( ARGS_DECL ( argDecl )* )
			{
				DebugLocation(262, 34);
				// CCompiler.g:262:34: ^( ARGS_DECL ( argDecl )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(262, 36);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGS_DECL, "ARGS_DECL"), root_1);

				DebugLocation(262, 46);
				// CCompiler.g:262:46: ( argDecl )*
				while ( stream_argDecl.HasNext )
				{
					DebugLocation(262, 46);
					adaptor.AddChild(root_1, stream_argDecl.NextTree());

				}
				stream_argDecl.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("argsDecl", 26);
			LeaveRule("argsDecl", 26);
			LeaveRule_argsDecl();
			if (state.backtracking > 0) { Memoize(input, 26, argsDecl_StartIndex); }

		}
		DebugLocation(263, 0);
		} finally { DebugExitRule(GrammarFileName, "argsDecl"); }
		return retval;

	}
	// $ANTLR end "argsDecl"

	partial void EnterRule_funcDecl();
	partial void LeaveRule_funcDecl();

	// $ANTLR start "funcDecl"
	// CCompiler.g:265:1: funcDecl : t= type n= ident '(' ( argsDecl )? ')' '{' exprList '}' -> ^( FUNCTION $t $n ^( ARGS ( argsDecl )* ) exprList ) ;
	[GrammarRule("funcDecl")]
	private AstParserRuleReturnScope<object, IToken> funcDecl()
	{
		EnterRule_funcDecl();
		EnterRule("funcDecl", 27);
		TraceIn("funcDecl", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int funcDecl_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal110 = default(IToken);
		IToken char_literal112 = default(IToken);
		IToken char_literal113 = default(IToken);
		IToken char_literal115 = default(IToken);
		AstParserRuleReturnScope<object, IToken> t = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> n = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> argsDecl111 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exprList114 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal110_tree = default(object);
		object char_literal112_tree = default(object);
		object char_literal113_tree = default(object);
		object char_literal115_tree = default(object);
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleITokenStream stream_61=new RewriteRuleITokenStream(adaptor,"token 61");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		RewriteRuleSubtreeStream stream_argsDecl=new RewriteRuleSubtreeStream(adaptor,"rule argsDecl");
		RewriteRuleSubtreeStream stream_exprList=new RewriteRuleSubtreeStream(adaptor,"rule exprList");
		try { DebugEnterRule(GrammarFileName, "funcDecl");
		DebugLocation(265, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 27)) { return retval; }

			// CCompiler.g:265:9: (t= type n= ident '(' ( argsDecl )? ')' '{' exprList '}' -> ^( FUNCTION $t $n ^( ARGS ( argsDecl )* ) exprList ) )
			DebugEnterAlt(1);
			// CCompiler.g:266:3: t= type n= ident '(' ( argsDecl )? ')' '{' exprList '}'
			{
			DebugLocation(266, 4);
			PushFollow(Follow._type_in_funcDecl1721);
			t=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(t.Tree);
			DebugLocation(266, 11);
			PushFollow(Follow._ident_in_funcDecl1725);
			n=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(n.Tree);
			DebugLocation(266, 18);
			char_literal110=(IToken)Match(input,56,Follow._56_in_funcDecl1727); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_56.Add(char_literal110);

			DebugLocation(266, 22);
			// CCompiler.g:266:22: ( argsDecl )?
			int alt27=2;
			try { DebugEnterSubRule(27);
			try { DebugEnterDecision(27, false);
			int LA27_0 = input.LA(1);

			if ((LA27_0==IDENT))
			{
				alt27 = 1;
			}
			else if ((LA27_0==57))
			{
				int LA27_2 = input.LA(2);

				if ((EvaluatePredicate(synpred46_CCompiler_fragment)))
				{
					alt27 = 1;
				}
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:266:22: argsDecl
				{
				DebugLocation(266, 22);
				PushFollow(Follow._argsDecl_in_funcDecl1729);
				argsDecl111=argsDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_argsDecl.Add(argsDecl111.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(27); }

			DebugLocation(266, 32);
			char_literal112=(IToken)Match(input,57,Follow._57_in_funcDecl1732); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_57.Add(char_literal112);

			DebugLocation(267, 3);
			char_literal113=(IToken)Match(input,60,Follow._60_in_funcDecl1736); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_60.Add(char_literal113);

			DebugLocation(267, 7);
			PushFollow(Follow._exprList_in_funcDecl1738);
			exprList114=exprList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exprList.Add(exprList114.Tree);
			DebugLocation(267, 16);
			char_literal115=(IToken)Match(input,61,Follow._61_in_funcDecl1740); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_61.Add(char_literal115);



			{
			// AST REWRITE
			// elements: exprList, n, argsDecl, t
			// token labels: 
			// rule labels: retval, t, n
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.Tree:null);
			RewriteRuleSubtreeStream stream_n=new RewriteRuleSubtreeStream(adaptor,"rule n",n!=null?n.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 268:3: -> ^( FUNCTION $t $n ^( ARGS ( argsDecl )* ) exprList )
			{
				DebugLocation(268, 6);
				// CCompiler.g:268:6: ^( FUNCTION $t $n ^( ARGS ( argsDecl )* ) exprList )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(268, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION, "FUNCTION"), root_1);

				DebugLocation(268, 18);
				adaptor.AddChild(root_1, stream_t.NextTree());
				DebugLocation(268, 21);
				adaptor.AddChild(root_1, stream_n.NextTree());
				DebugLocation(268, 23);
				// CCompiler.g:268:23: ^( ARGS ( argsDecl )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(268, 25);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGS, "ARGS"), root_2);

				DebugLocation(268, 30);
				// CCompiler.g:268:30: ( argsDecl )*
				while ( stream_argsDecl.HasNext )
				{
					DebugLocation(268, 30);
					adaptor.AddChild(root_2, stream_argsDecl.NextTree());

				}
				stream_argsDecl.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(268, 41);
				adaptor.AddChild(root_1, stream_exprList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcDecl", 27);
			LeaveRule("funcDecl", 27);
			LeaveRule_funcDecl();
			if (state.backtracking > 0) { Memoize(input, 27, funcDecl_StartIndex); }

		}
		DebugLocation(269, 0);
		} finally { DebugExitRule(GrammarFileName, "funcDecl"); }
		return retval;

	}
	// $ANTLR end "funcDecl"

	partial void EnterRule_macroDecl();
	partial void LeaveRule_macroDecl();

	// $ANTLR start "macroDecl"
	// CCompiler.g:276:1: macroDecl : '#include' (s1= STRING |s2= INCLUDE_STRING ) -> ^( INCLUDE ( $s1)? ( $s2)? ) ;
	[GrammarRule("macroDecl")]
	private AstParserRuleReturnScope<object, IToken> macroDecl()
	{
		EnterRule_macroDecl();
		EnterRule("macroDecl", 28);
		TraceIn("macroDecl", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int macroDecl_StartIndex = input.Index;

		object root_0 = default(object);

		IToken s1 = default(IToken);
		IToken s2 = default(IToken);
		IToken string_literal116 = default(IToken);

		object s1_tree = default(object);
		object s2_tree = default(object);
		object string_literal116_tree = default(object);
		RewriteRuleITokenStream stream_INCLUDE_STRING=new RewriteRuleITokenStream(adaptor,"token INCLUDE_STRING");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
		try { DebugEnterRule(GrammarFileName, "macroDecl");
		DebugLocation(276, 2);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 28)) { return retval; }

			// CCompiler.g:276:10: ( '#include' (s1= STRING |s2= INCLUDE_STRING ) -> ^( INCLUDE ( $s1)? ( $s2)? ) )
			DebugEnterAlt(1);
			// CCompiler.g:277:3: '#include' (s1= STRING |s2= INCLUDE_STRING )
			{
			DebugLocation(277, 3);
			string_literal116=(IToken)Match(input,55,Follow._55_in_macroDecl1776); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_55.Add(string_literal116);

			DebugLocation(277, 14);
			// CCompiler.g:277:14: (s1= STRING |s2= INCLUDE_STRING )
			int alt28=2;
			try { DebugEnterSubRule(28);
			try { DebugEnterDecision(28, false);
			int LA28_0 = input.LA(1);

			if ((LA28_0==STRING))
			{
				alt28 = 1;
			}
			else if ((LA28_0==INCLUDE_STRING))
			{
				alt28 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:277:15: s1= STRING
				{
				DebugLocation(277, 17);
				s1=(IToken)Match(input,STRING,Follow._STRING_in_macroDecl1781); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STRING.Add(s1);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CCompiler.g:277:27: s2= INCLUDE_STRING
				{
				DebugLocation(277, 29);
				s2=(IToken)Match(input,INCLUDE_STRING,Follow._INCLUDE_STRING_in_macroDecl1787); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INCLUDE_STRING.Add(s2);


				}
				break;

			}
			} finally { DebugExitSubRule(28); }



			{
			// AST REWRITE
			// elements: s2, s1
			// token labels: s2, s1
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_s2=new RewriteRuleITokenStream(adaptor,"token s2",s2);
			RewriteRuleITokenStream stream_s1=new RewriteRuleITokenStream(adaptor,"token s1",s1);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 277:47: -> ^( INCLUDE ( $s1)? ( $s2)? )
			{
				DebugLocation(277, 51);
				// CCompiler.g:277:51: ^( INCLUDE ( $s1)? ( $s2)? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(277, 53);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INCLUDE, "INCLUDE"), root_1);

				DebugLocation(277, 62);
				// CCompiler.g:277:62: ( $s1)?
				if (stream_s1.HasNext)
				{
					DebugLocation(277, 62);
					adaptor.AddChild(root_1, stream_s1.NextNode());

				}
				stream_s1.Reset();
				DebugLocation(277, 67);
				// CCompiler.g:277:67: ( $s2)?
				if (stream_s2.HasNext)
				{
					DebugLocation(277, 67);
					adaptor.AddChild(root_1, stream_s2.NextNode());

				}
				stream_s2.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("macroDecl", 28);
			LeaveRule("macroDecl", 28);
			LeaveRule_macroDecl();
			if (state.backtracking > 0) { Memoize(input, 28, macroDecl_StartIndex); }

		}
		DebugLocation(278, 2);
		} finally { DebugExitRule(GrammarFileName, "macroDecl"); }
		return retval;

	}
	// $ANTLR end "macroDecl"

	partial void EnterRule_decl();
	partial void LeaveRule_decl();

	// $ANTLR start "decl"
	// CCompiler.g:280:1: decl : ( funcDecl | macroDecl ) ;
	[GrammarRule("decl")]
	private AstParserRuleReturnScope<object, IToken> decl()
	{
		EnterRule_decl();
		EnterRule("decl", 29);
		TraceIn("decl", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int decl_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> funcDecl117 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> macroDecl118 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "decl");
		DebugLocation(280, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 29)) { return retval; }

			// CCompiler.g:280:5: ( ( funcDecl | macroDecl ) )
			DebugEnterAlt(1);
			// CCompiler.g:281:3: ( funcDecl | macroDecl )
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(281, 3);
			// CCompiler.g:281:3: ( funcDecl | macroDecl )
			int alt29=2;
			try { DebugEnterSubRule(29);
			try { DebugEnterDecision(29, false);
			int LA29_0 = input.LA(1);

			if ((LA29_0==IDENT))
			{
				alt29 = 1;
			}
			else if ((LA29_0==55))
			{
				alt29 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 29, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// CCompiler.g:281:5: funcDecl
				{
				DebugLocation(281, 5);
				PushFollow(Follow._funcDecl_in_decl1818);
				funcDecl117=funcDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcDecl117.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CCompiler.g:281:16: macroDecl
				{
				DebugLocation(281, 16);
				PushFollow(Follow._macroDecl_in_decl1822);
				macroDecl118=macroDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, macroDecl118.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(29); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decl", 29);
			LeaveRule("decl", 29);
			LeaveRule_decl();
			if (state.backtracking > 0) { Memoize(input, 29, decl_StartIndex); }

		}
		DebugLocation(282, 0);
		} finally { DebugExitRule(GrammarFileName, "decl"); }
		return retval;

	}
	// $ANTLR end "decl"

	partial void EnterRule_declList();
	partial void LeaveRule_declList();

	// $ANTLR start "declList"
	// CCompiler.g:284:1: declList : ( decl )* ;
	[GrammarRule("declList")]
	private AstParserRuleReturnScope<object, IToken> declList()
	{
		EnterRule_declList();
		EnterRule("declList", 30);
		TraceIn("declList", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int declList_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> decl119 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declList");
		DebugLocation(284, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 30)) { return retval; }

			// CCompiler.g:284:9: ( ( decl )* )
			DebugEnterAlt(1);
			// CCompiler.g:285:3: ( decl )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(285, 3);
			// CCompiler.g:285:3: ( decl )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_0 = input.LA(1);

				if ((LA30_0==IDENT||LA30_0==55))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// CCompiler.g:285:3: decl
					{
					DebugLocation(285, 3);
					PushFollow(Follow._decl_in_declList1841);
					decl119=decl();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, decl119.Tree);

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declList", 30);
			LeaveRule("declList", 30);
			LeaveRule_declList();
			if (state.backtracking > 0) { Memoize(input, 30, declList_StartIndex); }

		}
		DebugLocation(286, 0);
		} finally { DebugExitRule(GrammarFileName, "declList"); }
		return retval;

	}
	// $ANTLR end "declList"

	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// CCompiler.g:288:1: program : declList ;
	[GrammarRule("program")]
	private AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 31);
		TraceIn("program", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int program_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declList120 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(288, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 31)) { return retval; }

			// CCompiler.g:288:8: ( declList )
			DebugEnterAlt(1);
			// CCompiler.g:289:3: declList
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(289, 3);
			PushFollow(Follow._declList_in_program1853);
			declList120=declList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, declList120.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 31);
			LeaveRule("program", 31);
			LeaveRule_program();
			if (state.backtracking > 0) { Memoize(input, 31, program_StartIndex); }

		}
		DebugLocation(290, 0);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_execute();
	partial void LeaveRule_execute();

	// $ANTLR start "execute"
	// CCompiler.g:292:8: public execute : program EOF -> ^( PROGRAM program ) ;
	[GrammarRule("execute")]
	public AstParserRuleReturnScope<object, IToken> execute()
	{
		EnterRule_execute();
		EnterRule("execute", 32);
		TraceIn("execute", 32);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int execute_StartIndex = input.Index;

		object root_0 = default(object);

		IToken EOF122 = default(IToken);
		AstParserRuleReturnScope<object, IToken> program121 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF122_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_program=new RewriteRuleSubtreeStream(adaptor,"rule program");
		try { DebugEnterRule(GrammarFileName, "execute");
		DebugLocation(292, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 32)) { return retval; }

			// CCompiler.g:292:15: ( program EOF -> ^( PROGRAM program ) )
			DebugEnterAlt(1);
			// CCompiler.g:293:3: program EOF
			{
			DebugLocation(293, 3);
			PushFollow(Follow._program_in_execute1866);
			program121=program();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_program.Add(program121.Tree);
			DebugLocation(294, 3);
			EOF122=(IToken)Match(input,EOF,Follow._EOF_in_execute1870); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF122);



			{
			// AST REWRITE
			// elements: program
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 295:5: -> ^( PROGRAM program )
			{
				DebugLocation(295, 9);
				// CCompiler.g:295:9: ^( PROGRAM program )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(295, 11);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(295, 19);
				adaptor.AddChild(root_1, stream_program.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("execute", 32);
			LeaveRule("execute", 32);
			LeaveRule_execute();
			if (state.backtracking > 0) { Memoize(input, 32, execute_StartIndex); }

		}
		DebugLocation(296, 0);
		} finally { DebugExitRule(GrammarFileName, "execute"); }
		return retval;

	}
	// $ANTLR end "execute"

	partial void EnterRule_synpred25_CCompiler_fragment();
	partial void LeaveRule_synpred25_CCompiler_fragment();

	// $ANTLR start synpred25_CCompiler
	public void synpred25_CCompiler_fragment()
	{
		EnterRule_synpred25_CCompiler_fragment();
		EnterRule("synpred25_CCompiler_fragment", 57);
		TraceIn("synpred25_CCompiler_fragment", 57);
		try
		{
			// CCompiler.g:213:27: ( ',' varDecl )
			DebugEnterAlt(1);
			// CCompiler.g:213:27: ',' varDecl
			{
			DebugLocation(213, 27);
			Match(input,COMMA,Follow._COMMA_in_synpred25_CCompiler1392); if (state.failed) return;
			DebugLocation(213, 31);
			PushFollow(Follow._varDecl_in_synpred25_CCompiler1394);
			varDecl();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred25_CCompiler_fragment", 57);
			LeaveRule("synpred25_CCompiler_fragment", 57);
			LeaveRule_synpred25_CCompiler_fragment();
		}
	}
	// $ANTLR end synpred25_CCompiler

	partial void EnterRule_synpred30_CCompiler_fragment();
	partial void LeaveRule_synpred30_CCompiler_fragment();

	// $ANTLR start synpred30_CCompiler
	public void synpred30_CCompiler_fragment()
	{
		EnterRule_synpred30_CCompiler_fragment();
		EnterRule("synpred30_CCompiler_fragment", 62);
		TraceIn("synpred30_CCompiler_fragment", 62);
		try
		{
			// CCompiler.g:230:3: ( expr0 ';' )
			DebugEnterAlt(1);
			// CCompiler.g:230:3: expr0 ';'
			{
			DebugLocation(230, 3);
			PushFollow(Follow._expr0_in_synpred30_CCompiler1492);
			expr0();
			PopFollow();
			if (state.failed) return;
			DebugLocation(230, 9);
			Match(input,SEMI,Follow._SEMI_in_synpred30_CCompiler1494); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred30_CCompiler_fragment", 62);
			LeaveRule("synpred30_CCompiler_fragment", 62);
			LeaveRule_synpred30_CCompiler_fragment();
		}
	}
	// $ANTLR end synpred30_CCompiler

	partial void EnterRule_synpred31_CCompiler_fragment();
	partial void LeaveRule_synpred31_CCompiler_fragment();

	// $ANTLR start synpred31_CCompiler
	public void synpred31_CCompiler_fragment()
	{
		EnterRule_synpred31_CCompiler_fragment();
		EnterRule("synpred31_CCompiler_fragment", 63);
		TraceIn("synpred31_CCompiler_fragment", 63);
		try
		{
			// CCompiler.g:231:28: ( ELSE expr )
			DebugEnterAlt(1);
			// CCompiler.g:231:28: ELSE expr
			{
			DebugLocation(231, 28);
			Match(input,ELSE,Follow._ELSE_in_synpred31_CCompiler1513); if (state.failed) return;
			DebugLocation(231, 34);
			PushFollow(Follow._expr_in_synpred31_CCompiler1516);
			expr();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred31_CCompiler_fragment", 63);
			LeaveRule("synpred31_CCompiler_fragment", 63);
			LeaveRule_synpred31_CCompiler_fragment();
		}
	}
	// $ANTLR end synpred31_CCompiler

	partial void EnterRule_synpred37_CCompiler_fragment();
	partial void LeaveRule_synpred37_CCompiler_fragment();

	// $ANTLR start synpred37_CCompiler
	public void synpred37_CCompiler_fragment()
	{
		EnterRule_synpred37_CCompiler_fragment();
		EnterRule("synpred37_CCompiler_fragment", 69);
		TraceIn("synpred37_CCompiler_fragment", 69);
		try
		{
			// CCompiler.g:236:3: ( call ';' )
			DebugEnterAlt(1);
			// CCompiler.g:236:3: call ';'
			{
			DebugLocation(236, 3);
			PushFollow(Follow._call_in_synpred37_CCompiler1584);
			call();
			PopFollow();
			if (state.failed) return;
			DebugLocation(236, 8);
			Match(input,SEMI,Follow._SEMI_in_synpred37_CCompiler1586); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred37_CCompiler_fragment", 69);
			LeaveRule("synpred37_CCompiler_fragment", 69);
			LeaveRule_synpred37_CCompiler_fragment();
		}
	}
	// $ANTLR end synpred37_CCompiler

	partial void EnterRule_synpred46_CCompiler_fragment();
	partial void LeaveRule_synpred46_CCompiler_fragment();

	// $ANTLR start synpred46_CCompiler
	public void synpred46_CCompiler_fragment()
	{
		EnterRule_synpred46_CCompiler_fragment();
		EnterRule("synpred46_CCompiler_fragment", 78);
		TraceIn("synpred46_CCompiler_fragment", 78);
		try
		{
			// CCompiler.g:266:22: ( argsDecl )
			DebugEnterAlt(1);
			// CCompiler.g:266:22: argsDecl
			{
			DebugLocation(266, 22);
			PushFollow(Follow._argsDecl_in_synpred46_CCompiler1729);
			argsDecl();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred46_CCompiler_fragment", 78);
			LeaveRule("synpred46_CCompiler_fragment", 78);
			LeaveRule_synpred46_CCompiler_fragment();
		}
	}
	// $ANTLR end synpred46_CCompiler
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA20 dfa20;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa20 = new DFA20( this );
	}

	private class DFA20 : DFA
	{
		private const string DFA20_eotS =
			"\x4\xFFFF";
		private const string DFA20_eofS =
			"\x4\xFFFF";
		private const string DFA20_minS =
			"\x2\x12\x2\xFFFF";
		private const string DFA20_maxS =
			"\x2\x3D\x2\xFFFF";
		private const string DFA20_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA20_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA20_transitionS =
			{
				"\x1\x3\x4\xFFFF\x1\x3\x4\xFFFF\x2\x3\xF\xFFFF\x1\x3\x1\x1\x6\xFFFF\x1"+
				"\x3\x6\xFFFF\x1\x3\x1\x2",
				"\x1\x3\x4\xFFFF\x1\x3\x4\xFFFF\x2\x3\xF\xFFFF\x1\x3\x1\x1\x6\xFFFF"+
				"\x1\x3\x6\xFFFF\x1\x3\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA20_eot = DFA.UnpackEncodedString(DFA20_eotS);
		private static readonly short[] DFA20_eof = DFA.UnpackEncodedString(DFA20_eofS);
		private static readonly char[] DFA20_min = DFA.UnpackEncodedStringToUnsignedChars(DFA20_minS);
		private static readonly char[] DFA20_max = DFA.UnpackEncodedStringToUnsignedChars(DFA20_maxS);
		private static readonly short[] DFA20_accept = DFA.UnpackEncodedString(DFA20_acceptS);
		private static readonly short[] DFA20_special = DFA.UnpackEncodedString(DFA20_specialS);
		private static readonly short[][] DFA20_transition;

		static DFA20()
		{
			int numStates = DFA20_transitionS.Length;
			DFA20_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA20_transition[i] = DFA.UnpackEncodedString(DFA20_transitionS[i]);
			}
		}

		public DFA20( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 20;
			this.eot = DFA20_eot;
			this.eof = DFA20_eof;
			this.min = DFA20_min;
			this.max = DFA20_max;
			this.accept = DFA20_accept;
			this.special = DFA20_special;
			this.transition = DFA20_transition;
		}

		public override string Description { get { return "()* loopback of 255:18: ( ( ';' )* expr )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _IDENT_in_ident974 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_type0988 = new BitSet(new ulong[]{0x400000000000002UL});
		public static readonly BitSet _58_in_type0991 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _59_in_type0993 = new BitSet(new ulong[]{0x400000000000002UL});
		public static readonly BitSet _type0_in_type1004 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_args1027 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _COMMA_in_args1030 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _term_in_args1032 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _IDENT_in_funcCall1057 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_funcCall1059 = new BitSet(new ulong[]{0x302030010400000UL});
		public static readonly BitSet _args_in_funcCall1061 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_funcCall1063 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _58_in_arrayIndex01085 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_params_1102 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _COMMA_in_params_1105 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _term_in_params_1108 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _ident_in_call1121 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_call1123 = new BitSet(new ulong[]{0x302030010400000UL});
		public static readonly BitSet _params__in_call1125 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_call1127 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _56_in_group1154 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _term_in_group1157 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_group1159 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_group1164 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_group1168 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_group1172 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_group1176 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _call_in_group1180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_in_not1190 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_not1194 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _not_in_not1197 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _not_in_mult1205 = new BitSet(new ulong[]{0x4000000002UL});
		public static readonly BitSet _MUL_in_mult1211 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _not_in_mult1215 = new BitSet(new ulong[]{0x4000000002UL});
		public static readonly BitSet _mult_in_add1228 = new BitSet(new ulong[]{0x1000000000412UL});
		public static readonly BitSet _set_in_add1233 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _mult_in_add1248 = new BitSet(new ulong[]{0x1000000000412UL});
		public static readonly BitSet _add_in_compare1277 = new BitSet(new ulong[]{0x920C100002UL});
		public static readonly BitSet _set_in_compare1281 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _add_in_compare1308 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _compare_in_and_logic1320 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _AND_in_and_logic1324 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _compare_in_and_logic1327 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _and_logic_in_or_logic1340 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _OR_in_or_logic1344 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _and_logic_in_or_logic1347 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _or_logic_in_term1358 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_varDecl1372 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _ASSIGN_in_varDecl1375 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _term_in_varDecl1378 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_varsDecl1386 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _varDecl_in_varsDecl1388 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _COMMA_in_varsDecl1392 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _varDecl_in_varsDecl1394 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _ident_in_expr01421 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _ASSIGN_in_expr01423 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _term_in_expr01426 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_expr01430 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _call_in_expr01444 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varsDecl_in_expr01448 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _60_in_blockExpr1456 = new BitSet(new ulong[]{0x3020600030840000UL});
		public static readonly BitSet _exprList_in_blockExpr1459 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _61_in_blockExpr1461 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_termOrTrue1472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr0_in_expr1492 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _SEMI_in_expr1494 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_expr1499 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_expr1502 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _term_in_expr1505 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_expr1507 = new BitSet(new ulong[]{0x1020200030840000UL});
		public static readonly BitSet _expr_in_expr1510 = new BitSet(new ulong[]{0x80002UL});
		public static readonly BitSet _ELSE_in_expr1513 = new BitSet(new ulong[]{0x1020200030840000UL});
		public static readonly BitSet _expr_in_expr1516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_expr1522 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_expr1525 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _term_in_expr1528 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_expr1530 = new BitSet(new ulong[]{0x1020200030840000UL});
		public static readonly BitSet _expr_in_expr1533 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_expr1537 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_expr1540 = new BitSet(new ulong[]{0x400010000000UL});
		public static readonly BitSet _exprList2_in_expr1543 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _SEMI_in_expr1545 = new BitSet(new ulong[]{0x102430010400000UL});
		public static readonly BitSet _termOrTrue_in_expr1548 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _SEMI_in_expr1550 = new BitSet(new ulong[]{0x200000010000000UL});
		public static readonly BitSet _exprList2_in_expr1553 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_expr1555 = new BitSet(new ulong[]{0x1020200030840000UL});
		public static readonly BitSet _expr_in_expr1558 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DO_in_expr1562 = new BitSet(new ulong[]{0x1020200030840000UL});
		public static readonly BitSet _expr_in_expr1565 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _WHILE_in_expr1567 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _term_in_expr1570 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_expr1574 = new BitSet(new ulong[]{0x102030010400000UL});
		public static readonly BitSet _term_in_expr1577 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _SEMI_in_expr1579 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _call_in_expr1584 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _SEMI_in_expr1586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _blockExpr_in_expr1592 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_exprList1605 = new BitSet(new ulong[]{0x1020600030840002UL});
		public static readonly BitSet _SEMI_in_exprList1609 = new BitSet(new ulong[]{0x1020600030840000UL});
		public static readonly BitSet _expr_in_exprList1612 = new BitSet(new ulong[]{0x1020600030840002UL});
		public static readonly BitSet _SEMI_in_exprList1620 = new BitSet(new ulong[]{0x400000000002UL});
		public static readonly BitSet _expr0_in_exprList21642 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _COMMA_in_exprList21646 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _expr0_in_exprList21648 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _type_in_argDecl1676 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _IDENT_in_argDecl1678 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _argDecl_in_argsDecl1689 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _COMMA_in_argsDecl1692 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _argDecl_in_argsDecl1694 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _type_in_funcDecl1721 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _ident_in_funcDecl1725 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_funcDecl1727 = new BitSet(new ulong[]{0x200000010000000UL});
		public static readonly BitSet _argsDecl_in_funcDecl1729 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_funcDecl1732 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _60_in_funcDecl1736 = new BitSet(new ulong[]{0x3020600030840000UL});
		public static readonly BitSet _exprList_in_funcDecl1738 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _61_in_funcDecl1740 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _55_in_macroDecl1776 = new BitSet(new ulong[]{0x800080000000UL});
		public static readonly BitSet _STRING_in_macroDecl1781 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INCLUDE_STRING_in_macroDecl1787 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcDecl_in_decl1818 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _macroDecl_in_decl1822 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _decl_in_declList1841 = new BitSet(new ulong[]{0x80000010000002UL});
		public static readonly BitSet _declList_in_program1853 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _program_in_execute1866 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_execute1870 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_synpred25_CCompiler1392 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _varDecl_in_synpred25_CCompiler1394 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr0_in_synpred30_CCompiler1492 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _SEMI_in_synpred30_CCompiler1494 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_synpred31_CCompiler1513 = new BitSet(new ulong[]{0x1020200030840000UL});
		public static readonly BitSet _expr_in_synpred31_CCompiler1516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _call_in_synpred37_CCompiler1584 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _SEMI_in_synpred37_CCompiler1586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _argsDecl_in_synpred46_CCompiler1729 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
