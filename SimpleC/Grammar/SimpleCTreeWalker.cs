//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 Grammar\\SimpleCTreeWalker.g 2015-10-06 22:22:17

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


#pragma warning disable 3021
using SimpleC.Tree;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  SimpleC.Grammar 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class SimpleCTreeWalker : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "ASSIGN", "BIT_AND", "BIT_NOT", "BIT_OR", "BIT_XOR", "BOOL_AND", "BOOL_NOT", "BOOL_OR", "DEC_POST", "DEC_PRE", "DEREF", "DIV", "EQUAL", "EXPRESSION", "FUNC_BODY", "FUNC_CALL", "FUNC_DECL", "FUNC_DEF", "GREATER", "GREATER_OR_EQUAL", "IDENT", "INC_POST", "INC_PRE", "INTEGER", "Identifier", "Int", "Integer", "LESS", "LESS_OR_EQUAL", "MOD", "MUL", "NOT_EQUAL", "PARAM_LIST", "PARAM_SPEC_LIST", "PROGRAM", "REF", "SHIFT_LEFT", "SHIFT_RIGHT", "SIZEOF_EXPR", "SIZEOF_TYPE", "STATEMENT", "STRUCT_DEREF", "STRUCT_MEMBER", "SUB", "SUBSCRIPT", "SizeOf", "TYPECAST", "TYPE_SPEC", "U_MINUS", "U_PLUS", "VAR_CALL", "VAR_DECL", "VAR_DEF", "VAR_SPEC", "Void", "Whitespace", "'!'", "'('", "')'", "'++'", "','", "'--'", "'->'", "'.'", "';'", "'['", "']'", "'{'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int ADD=4;
	public const int ASSIGN=5;
	public const int BIT_AND=6;
	public const int BIT_NOT=7;
	public const int BIT_OR=8;
	public const int BIT_XOR=9;
	public const int BOOL_AND=10;
	public const int BOOL_NOT=11;
	public const int BOOL_OR=12;
	public const int DEC_POST=13;
	public const int DEC_PRE=14;
	public const int DEREF=15;
	public const int DIV=16;
	public const int EQUAL=17;
	public const int EXPRESSION=18;
	public const int FUNC_BODY=19;
	public const int FUNC_CALL=20;
	public const int FUNC_DECL=21;
	public const int FUNC_DEF=22;
	public const int GREATER=23;
	public const int GREATER_OR_EQUAL=24;
	public const int IDENT=25;
	public const int INC_POST=26;
	public const int INC_PRE=27;
	public const int INTEGER=28;
	public const int Identifier=29;
	public const int Int=30;
	public const int Integer=31;
	public const int LESS=32;
	public const int LESS_OR_EQUAL=33;
	public const int MOD=34;
	public const int MUL=35;
	public const int NOT_EQUAL=36;
	public const int PARAM_LIST=37;
	public const int PARAM_SPEC_LIST=38;
	public const int PROGRAM=39;
	public const int REF=40;
	public const int SHIFT_LEFT=41;
	public const int SHIFT_RIGHT=42;
	public const int SIZEOF_EXPR=43;
	public const int SIZEOF_TYPE=44;
	public const int STATEMENT=45;
	public const int STRUCT_DEREF=46;
	public const int STRUCT_MEMBER=47;
	public const int SUB=48;
	public const int SUBSCRIPT=49;
	public const int SizeOf=50;
	public const int TYPECAST=51;
	public const int TYPE_SPEC=52;
	public const int U_MINUS=53;
	public const int U_PLUS=54;
	public const int VAR_CALL=55;
	public const int VAR_DECL=56;
	public const int VAR_DEF=57;
	public const int VAR_SPEC=58;
	public const int Void=59;
	public const int Whitespace=60;

	public SimpleCTreeWalker(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public SimpleCTreeWalker(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return SimpleCTreeWalker.tokenNames; } }
	public override string GrammarFileName { get { return "Grammar\\SimpleCTreeWalker.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_walk();
	partial void LeaveRule_walk();

	// $ANTLR start "walk"
	// Grammar\\SimpleCTreeWalker.g:17:1: public walk returns [RootNode node] : ^( PROGRAM ( programStatement )* ) ;
	[GrammarRule("walk")]
	public RootNode walk()
	{
		EnterRule_walk();
		EnterRule("walk", 1);
		TraceIn("walk", 1);
		RootNode node = default(RootNode);


		ISCNode programStatement1 = default(ISCNode);


			node = new RootNode();

		try { DebugEnterRule(GrammarFileName, "walk");
		DebugLocation(17, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:20:3: ( ^( PROGRAM ( programStatement )* ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:22:2: ^( PROGRAM ( programStatement )* )
			{
			DebugLocation(22, 2);
			DebugLocation(22, 4);
			Match(input,PROGRAM,Follow._PROGRAM_in_walk61); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(22, 12);
				// Grammar\\SimpleCTreeWalker.g:22:12: ( programStatement )*
				try { DebugEnterSubRule(1);
				while (true)
				{
					int alt1=2;
					try { DebugEnterDecision(1, false);
					int LA1_0 = input.LA(1);

					if (((LA1_0>=FUNC_DECL && LA1_0<=FUNC_DEF)||LA1_0==VAR_DEF))
					{
						alt1 = 1;
					}


					} finally { DebugExitDecision(1); }
					switch ( alt1 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:22:13: programStatement
						{
						DebugLocation(22, 13);
						PushFollow(Follow._programStatement_in_walk64);
						programStatement1=programStatement();
						PopFollow();

						DebugLocation(22, 30);
						 node.Children.Add(programStatement1); 

						}
						break;

					default:
						goto loop1;
					}
				}

				loop1:
					;

				} finally { DebugExitSubRule(1); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("walk", 1);
			LeaveRule("walk", 1);
			LeaveRule_walk();
		}
		DebugLocation(23, 0);
		} finally { DebugExitRule(GrammarFileName, "walk"); }
		return node;

	}
	// $ANTLR end "walk"

	partial void EnterRule_programStatement();
	partial void LeaveRule_programStatement();

	// $ANTLR start "programStatement"
	// Grammar\\SimpleCTreeWalker.g:25:1: programStatement returns [ISCNode node] : ( varDef | funcDecl | funcDef );
	[GrammarRule("programStatement")]
	private ISCNode programStatement()
	{
		EnterRule_programStatement();
		EnterRule("programStatement", 2);
		TraceIn("programStatement", 2);
		ISCNode node = default(ISCNode);


		VarDefNode varDef2 = default(VarDefNode);
		FuncDeclNode funcDecl3 = default(FuncDeclNode);
		FuncDefNode funcDef4 = default(FuncDefNode);

		try { DebugEnterRule(GrammarFileName, "programStatement");
		DebugLocation(25, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:26:2: ( varDef | funcDecl | funcDef )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case VAR_DEF:
				{
				alt2 = 1;
				}
				break;
			case FUNC_DECL:
				{
				alt2 = 2;
				}
				break;
			case FUNC_DEF:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleCTreeWalker.g:26:4: varDef
				{
				DebugLocation(26, 4);
				PushFollow(Follow._varDef_in_programStatement83);
				varDef2=varDef();
				PopFollow();

				DebugLocation(26, 11);
				 node = varDef2; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleCTreeWalker.g:27:4: funcDecl
				{
				DebugLocation(27, 4);
				PushFollow(Follow._funcDecl_in_programStatement90);
				funcDecl3=funcDecl();
				PopFollow();

				DebugLocation(27, 13);

						FuncDeclNode funcDeclNode = funcDecl3;
						node = funcDeclNode; 
						FuncDeclsContainer.Add(funcDeclNode);
					

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleCTreeWalker.g:32:4: funcDef
				{
				DebugLocation(32, 4);
				PushFollow(Follow._funcDef_in_programStatement97);
				funcDef4=funcDef();
				PopFollow();

				DebugLocation(32, 12);
					
						FuncDefNode funcDefNode = funcDef4;
						node = funcDefNode; 
						FuncDeclsContainer.Add(funcDefNode);
					

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("programStatement", 2);
			LeaveRule("programStatement", 2);
			LeaveRule_programStatement();
		}
		DebugLocation(37, 0);
		} finally { DebugExitRule(GrammarFileName, "programStatement"); }
		return node;

	}
	// $ANTLR end "programStatement"

	partial void EnterRule_varDef();
	partial void LeaveRule_varDef();

	// $ANTLR start "varDef"
	// Grammar\\SimpleCTreeWalker.g:39:1: varDef returns [VarDefNode node] : ^( VAR_DEF varSpec ) ;
	[GrammarRule("varDef")]
	private VarDefNode varDef()
	{
		EnterRule_varDef();
		EnterRule("varDef", 3);
		TraceIn("varDef", 3);
		VarDefNode node = default(VarDefNode);


		VarSpecNode varSpec5 = default(VarSpecNode);

		try { DebugEnterRule(GrammarFileName, "varDef");
		DebugLocation(39, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:39:33: ( ^( VAR_DEF varSpec ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:40:2: ^( VAR_DEF varSpec )
			{
			DebugLocation(40, 2);
			DebugLocation(40, 4);
			Match(input,VAR_DEF,Follow._VAR_DEF_in_varDef113); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(40, 12);
			PushFollow(Follow._varSpec_in_varDef115);
			varSpec5=varSpec();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(40, 21);
			 node = new VarDefNode(varSpec5); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("varDef", 3);
			LeaveRule("varDef", 3);
			LeaveRule_varDef();
		}
		DebugLocation(41, 0);
		} finally { DebugExitRule(GrammarFileName, "varDef"); }
		return node;

	}
	// $ANTLR end "varDef"

	partial void EnterRule_funcDecl();
	partial void LeaveRule_funcDecl();

	// $ANTLR start "funcDecl"
	// Grammar\\SimpleCTreeWalker.g:43:1: funcDecl returns [FuncDeclNode node] : ^( FUNC_DECL typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) ) ;
	[GrammarRule("funcDecl")]
	private FuncDeclNode funcDecl()
	{
		EnterRule_funcDecl();
		EnterRule("funcDecl", 4);
		TraceIn("funcDecl", 4);
		FuncDeclNode node = default(FuncDeclNode);


		CommonTree IDENT7 = default(CommonTree);
		TypeSpecNode typeSpec6 = default(TypeSpecNode);
		VarSpecNode varSpec8 = default(VarSpecNode);


			node = new FuncDeclNode();

		try { DebugEnterRule(GrammarFileName, "funcDecl");
		DebugLocation(43, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:46:3: ( ^( FUNC_DECL typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:47:2: ^( FUNC_DECL typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) )
			{
			DebugLocation(47, 2);
			DebugLocation(47, 4);
			Match(input,FUNC_DECL,Follow._FUNC_DECL_in_funcDecl138); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(48, 3);
			PushFollow(Follow._typeSpec_in_funcDecl143);
			typeSpec6=typeSpec();
			PopFollow();

			DebugLocation(48, 12);
			 node.ReturnTypeSpec = typeSpec6; 
			DebugLocation(49, 3);
			IDENT7=(CommonTree)Match(input,IDENT,Follow._IDENT_in_funcDecl150); 
			DebugLocation(49, 9);
			 node.Name = IDENT7.Text; 
			DebugLocation(50, 3);
			DebugLocation(50, 5);
			Match(input,PARAM_SPEC_LIST,Follow._PARAM_SPEC_LIST_in_funcDecl157); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(50, 21);
				// Grammar\\SimpleCTreeWalker.g:50:21: ( varSpec )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_0 = input.LA(1);

					if ((LA3_0==VAR_SPEC))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:50:22: varSpec
						{
						DebugLocation(50, 22);
						PushFollow(Follow._varSpec_in_funcDecl160);
						varSpec8=varSpec();
						PopFollow();

						DebugLocation(50, 30);
						 node.Parameters.Add(varSpec8); 

						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }


				Match(input, TokenTypes.Up, null); 
			}


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcDecl", 4);
			LeaveRule("funcDecl", 4);
			LeaveRule_funcDecl();
		}
		DebugLocation(52, 0);
		} finally { DebugExitRule(GrammarFileName, "funcDecl"); }
		return node;

	}
	// $ANTLR end "funcDecl"

	partial void EnterRule_funcDef();
	partial void LeaveRule_funcDef();

	// $ANTLR start "funcDef"
	// Grammar\\SimpleCTreeWalker.g:54:1: funcDef returns [FuncDefNode node] : ^( FUNC_DEF typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) funcBody ) ;
	[GrammarRule("funcDef")]
	private FuncDefNode funcDef()
	{
		EnterRule_funcDef();
		EnterRule("funcDef", 5);
		TraceIn("funcDef", 5);
		FuncDefNode node = default(FuncDefNode);


		CommonTree IDENT10 = default(CommonTree);
		TypeSpecNode typeSpec9 = default(TypeSpecNode);
		VarSpecNode varSpec11 = default(VarSpecNode);
		CompoundStatementNode funcBody12 = default(CompoundStatementNode);


			node = new FuncDefNode();

		try { DebugEnterRule(GrammarFileName, "funcDef");
		DebugLocation(54, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:57:3: ( ^( FUNC_DEF typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) funcBody ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:58:2: ^( FUNC_DEF typeSpec IDENT ^( PARAM_SPEC_LIST ( varSpec )* ) funcBody )
			{
			DebugLocation(58, 2);
			DebugLocation(58, 4);
			Match(input,FUNC_DEF,Follow._FUNC_DEF_in_funcDef188); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(59, 3);
			PushFollow(Follow._typeSpec_in_funcDef193);
			typeSpec9=typeSpec();
			PopFollow();

			DebugLocation(59, 12);
			 node.ReturnTypeSpec = typeSpec9; 
			DebugLocation(60, 3);
			IDENT10=(CommonTree)Match(input,IDENT,Follow._IDENT_in_funcDef199); 
			DebugLocation(60, 9);
			 node.Name = IDENT10.Text; 
			DebugLocation(61, 3);
			DebugLocation(61, 5);
			Match(input,PARAM_SPEC_LIST,Follow._PARAM_SPEC_LIST_in_funcDef206); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(61, 21);
				// Grammar\\SimpleCTreeWalker.g:61:21: ( varSpec )*
				try { DebugEnterSubRule(4);
				while (true)
				{
					int alt4=2;
					try { DebugEnterDecision(4, false);
					int LA4_0 = input.LA(1);

					if ((LA4_0==VAR_SPEC))
					{
						alt4 = 1;
					}


					} finally { DebugExitDecision(4); }
					switch ( alt4 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:61:22: varSpec
						{
						DebugLocation(61, 22);
						PushFollow(Follow._varSpec_in_funcDef209);
						varSpec11=varSpec();
						PopFollow();

						DebugLocation(61, 30);
						 node.Parameters.Add(varSpec11); 

						}
						break;

					default:
						goto loop4;
					}
				}

				loop4:
					;

				} finally { DebugExitSubRule(4); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(62, 3);
			PushFollow(Follow._funcBody_in_funcDef219);
			funcBody12=funcBody();
			PopFollow();

			DebugLocation(62, 12);
			 node.Body = funcBody12; 

			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcDef", 5);
			LeaveRule("funcDef", 5);
			LeaveRule_funcDef();
		}
		DebugLocation(63, 0);
		} finally { DebugExitRule(GrammarFileName, "funcDef"); }
		return node;

	}
	// $ANTLR end "funcDef"

	partial void EnterRule_varSpec();
	partial void LeaveRule_varSpec();

	// $ANTLR start "varSpec"
	// Grammar\\SimpleCTreeWalker.g:65:1: varSpec returns [VarSpecNode node] : ^( VAR_SPEC typeSpec IDENT ) ;
	[GrammarRule("varSpec")]
	private VarSpecNode varSpec()
	{
		EnterRule_varSpec();
		EnterRule("varSpec", 6);
		TraceIn("varSpec", 6);
		VarSpecNode node = default(VarSpecNode);


		CommonTree IDENT14 = default(CommonTree);
		TypeSpecNode typeSpec13 = default(TypeSpecNode);


			node = new VarSpecNode();

		try { DebugEnterRule(GrammarFileName, "varSpec");
		DebugLocation(65, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:68:3: ( ^( VAR_SPEC typeSpec IDENT ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:69:2: ^( VAR_SPEC typeSpec IDENT )
			{
			DebugLocation(69, 2);
			DebugLocation(69, 4);
			Match(input,VAR_SPEC,Follow._VAR_SPEC_in_varSpec242); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(69, 13);
			PushFollow(Follow._typeSpec_in_varSpec244);
			typeSpec13=typeSpec();
			PopFollow();

			DebugLocation(69, 22);
			IDENT14=(CommonTree)Match(input,IDENT,Follow._IDENT_in_varSpec246); 

			Match(input, TokenTypes.Up, null); 

			DebugLocation(69, 29);
			 
					node.TypeSpec = typeSpec13; 
					node.Name = IDENT14.Text;
				

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("varSpec", 6);
			LeaveRule("varSpec", 6);
			LeaveRule_varSpec();
		}
		DebugLocation(73, 0);
		} finally { DebugExitRule(GrammarFileName, "varSpec"); }
		return node;

	}
	// $ANTLR end "varSpec"

	partial void EnterRule_typeSpec();
	partial void LeaveRule_typeSpec();

	// $ANTLR start "typeSpec"
	// Grammar\\SimpleCTreeWalker.g:75:1: typeSpec returns [TypeSpecNode node] : ^( TYPE_SPEC IDENT ) ;
	[GrammarRule("typeSpec")]
	private TypeSpecNode typeSpec()
	{
		EnterRule_typeSpec();
		EnterRule("typeSpec", 7);
		TraceIn("typeSpec", 7);
		TypeSpecNode node = default(TypeSpecNode);


		CommonTree IDENT15 = default(CommonTree);


			node = new TypeSpecNode();

		try { DebugEnterRule(GrammarFileName, "typeSpec");
		DebugLocation(75, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:78:3: ( ^( TYPE_SPEC IDENT ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:79:2: ^( TYPE_SPEC IDENT )
			{
			DebugLocation(79, 2);
			DebugLocation(79, 4);
			Match(input,TYPE_SPEC,Follow._TYPE_SPEC_in_typeSpec269); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(79, 14);
			IDENT15=(CommonTree)Match(input,IDENT,Follow._IDENT_in_typeSpec271); 

			Match(input, TokenTypes.Up, null); 

			DebugLocation(79, 21);
			 
					node.PrimaryTypeName = IDENT15.Text; 
				

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeSpec", 7);
			LeaveRule("typeSpec", 7);
			LeaveRule_typeSpec();
		}
		DebugLocation(82, 0);
		} finally { DebugExitRule(GrammarFileName, "typeSpec"); }
		return node;

	}
	// $ANTLR end "typeSpec"

	partial void EnterRule_funcBody();
	partial void LeaveRule_funcBody();

	// $ANTLR start "funcBody"
	// Grammar\\SimpleCTreeWalker.g:84:1: funcBody returns [CompoundStatementNode node] : ^( FUNC_BODY ( statement )* ) ;
	[GrammarRule("funcBody")]
	private CompoundStatementNode funcBody()
	{
		EnterRule_funcBody();
		EnterRule("funcBody", 8);
		TraceIn("funcBody", 8);
		CompoundStatementNode node = default(CompoundStatementNode);


		ISCNode statement16 = default(ISCNode);


			node = new CompoundStatementNode();

		try { DebugEnterRule(GrammarFileName, "funcBody");
		DebugLocation(84, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:87:3: ( ^( FUNC_BODY ( statement )* ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleCTreeWalker.g:88:2: ^( FUNC_BODY ( statement )* )
			{
			DebugLocation(88, 2);
			DebugLocation(88, 4);
			Match(input,FUNC_BODY,Follow._FUNC_BODY_in_funcBody294); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(88, 14);
				// Grammar\\SimpleCTreeWalker.g:88:14: ( statement )*
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0==STATEMENT||LA5_0==VAR_DEF))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch ( alt5 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:88:15: statement
						{
						DebugLocation(88, 15);
						PushFollow(Follow._statement_in_funcBody297);
						statement16=statement();
						PopFollow();

						DebugLocation(88, 25);
						 node.Statements.Add(statement16); 

						}
						break;

					default:
						goto loop5;
					}
				}

				loop5:
					;

				} finally { DebugExitSubRule(5); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcBody", 8);
			LeaveRule("funcBody", 8);
			LeaveRule_funcBody();
		}
		DebugLocation(89, 0);
		} finally { DebugExitRule(GrammarFileName, "funcBody"); }
		return node;

	}
	// $ANTLR end "funcBody"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// Grammar\\SimpleCTreeWalker.g:91:1: statement returns [ISCNode node] : ( varDef | STATEMENT | ^( STATEMENT expression ) | ^( STATEMENT (st= statement )+ ) );
	[GrammarRule("statement")]
	private ISCNode statement()
	{
		EnterRule_statement();
		EnterRule("statement", 9);
		TraceIn("statement", 9);
		ISCNode node = default(ISCNode);


		ISCNode st = default(ISCNode);
		VarDefNode varDef17 = default(VarDefNode);
		IExprNode expression18 = default(IExprNode);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(91, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:91:33: ( varDef | STATEMENT | ^( STATEMENT expression ) | ^( STATEMENT (st= statement )+ ) )
			int alt7=4;
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==VAR_DEF))
			{
				alt7 = 1;
			}
			else if ((LA7_0==STATEMENT))
			{
				int LA7_2 = input.LA(2);

				if ((LA7_2==DOWN))
				{
					int LA7_3 = input.LA(3);

					if (((LA7_3>=ADD && LA7_3<=BIT_AND)||(LA7_3>=BIT_OR && LA7_3<=BOOL_AND)||LA7_3==BOOL_OR||(LA7_3>=DIV && LA7_3<=EQUAL)||LA7_3==FUNC_CALL||(LA7_3>=GREATER && LA7_3<=IDENT)||LA7_3==INTEGER||(LA7_3>=LESS && LA7_3<=NOT_EQUAL)||(LA7_3>=SHIFT_LEFT && LA7_3<=SHIFT_RIGHT)||LA7_3==SUB))
					{
						alt7 = 3;
					}
					else if ((LA7_3==STATEMENT||LA7_3==VAR_DEF))
					{
						alt7 = 4;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 7, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA7_2==UP||LA7_2==STATEMENT||LA7_2==VAR_DEF))
				{
					alt7 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 7, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleCTreeWalker.g:92:2: varDef
				{
				DebugLocation(92, 2);
				PushFollow(Follow._varDef_in_statement315);
				varDef17=varDef();
				PopFollow();

				DebugLocation(92, 9);
				 node = varDef17; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleCTreeWalker.g:93:4: STATEMENT
				{
				DebugLocation(93, 4);
				Match(input,STATEMENT,Follow._STATEMENT_in_statement322); 
				DebugLocation(93, 14);
				 node = new CompoundStatementNode(); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleCTreeWalker.g:94:4: ^( STATEMENT expression )
				{
				DebugLocation(94, 4);
				DebugLocation(94, 6);
				Match(input,STATEMENT,Follow._STATEMENT_in_statement331); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(94, 16);
				PushFollow(Follow._expression_in_statement333);
				expression18=expression();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(94, 28);
				 node = expression18; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleCTreeWalker.g:95:4: ^( STATEMENT (st= statement )+ )
				{
				DebugLocation(95, 4);
				DebugLocation(95, 6);
				Match(input,STATEMENT,Follow._STATEMENT_in_statement342); 

				DebugLocation(95, 16);
				 
						node = new CompoundStatementNode(); 
						CompoundStatementNode compoundNode = (CompoundStatementNode)node; 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(98, 5);
				// Grammar\\SimpleCTreeWalker.g:98:5: (st= statement )+
				int cnt6=0;
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=2;
					try { DebugEnterDecision(6, false);
					int LA6_0 = input.LA(1);

					if ((LA6_0==STATEMENT||LA6_0==VAR_DEF))
					{
						alt6 = 1;
					}


					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleCTreeWalker.g:98:6: st= statement
						{
						DebugLocation(98, 8);
						PushFollow(Follow._statement_in_statement354);
						st=statement();
						PopFollow();

						DebugLocation(98, 19);
						 compoundNode.Statements.Add(st); 

						}
						break;

					default:
						if (cnt6 >= 1)
							goto loop6;

						EarlyExitException eee6 = new EarlyExitException( 6, input );
						DebugRecognitionException(eee6);
						throw eee6;
					}
					cnt6++;
				}
				loop6:
					;

				} finally { DebugExitSubRule(6); }


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 9);
			LeaveRule("statement", 9);
			LeaveRule_statement();
		}
		DebugLocation(99, 0);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return node;

	}
	// $ANTLR end "statement"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// Grammar\\SimpleCTreeWalker.g:101:1: expression returns [IExprNode node] : ( ( ^(type= ADD left= expression right= expression ) | ^(type= SUB left= expression right= expression ) | ^(type= MUL left= expression right= expression ) | ^(type= DIV left= expression right= expression ) | ^(type= MOD left= expression right= expression ) | ^(type= SHIFT_LEFT left= expression right= expression ) | ^(type= SHIFT_RIGHT left= expression right= expression ) | ^(type= ASSIGN left= expression right= expression ) | ^(type= GREATER left= expression right= expression ) | ^(type= GREATER_OR_EQUAL left= expression right= expression ) | ^(type= LESS left= expression right= expression ) | ^(type= LESS_OR_EQUAL left= expression right= expression ) | ^(type= EQUAL left= expression right= expression ) | ^(type= NOT_EQUAL left= expression right= expression ) | ^(type= BOOL_AND left= expression right= expression ) | ^(type= BOOL_OR left= expression right= expression ) | ^(type= BIT_AND left= expression right= expression ) | ^(type= BIT_OR left= expression right= expression ) | ^(type= BIT_XOR left= expression right= expression ) ) | IDENT | INTEGER | ^( FUNC_CALL IDENT ^( PARAM_LIST (parameter= expression )* ) ) );
	[GrammarRule("expression")]
	private IExprNode expression()
	{
		EnterRule_expression();
		EnterRule("expression", 10);
		TraceIn("expression", 10);
		IExprNode node = default(IExprNode);


		CommonTree type = default(CommonTree);
		CommonTree IDENT19 = default(CommonTree);
		CommonTree INTEGER20 = default(CommonTree);
		CommonTree IDENT21 = default(CommonTree);
		IExprNode left = default(IExprNode);
		IExprNode right = default(IExprNode);
		IExprNode parameter = default(IExprNode);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(101, 0);
		try
		{
			// Grammar\\SimpleCTreeWalker.g:101:36: ( ( ^(type= ADD left= expression right= expression ) | ^(type= SUB left= expression right= expression ) | ^(type= MUL left= expression right= expression ) | ^(type= DIV left= expression right= expression ) | ^(type= MOD left= expression right= expression ) | ^(type= SHIFT_LEFT left= expression right= expression ) | ^(type= SHIFT_RIGHT left= expression right= expression ) | ^(type= ASSIGN left= expression right= expression ) | ^(type= GREATER left= expression right= expression ) | ^(type= GREATER_OR_EQUAL left= expression right= expression ) | ^(type= LESS left= expression right= expression ) | ^(type= LESS_OR_EQUAL left= expression right= expression ) | ^(type= EQUAL left= expression right= expression ) | ^(type= NOT_EQUAL left= expression right= expression ) | ^(type= BOOL_AND left= expression right= expression ) | ^(type= BOOL_OR left= expression right= expression ) | ^(type= BIT_AND left= expression right= expression ) | ^(type= BIT_OR left= expression right= expression ) | ^(type= BIT_XOR left= expression right= expression ) ) | IDENT | INTEGER | ^( FUNC_CALL IDENT ^( PARAM_LIST (parameter= expression )* ) ) )
			int alt10=4;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case ADD:
			case ASSIGN:
			case BIT_AND:
			case BIT_OR:
			case BIT_XOR:
			case BOOL_AND:
			case BOOL_OR:
			case DIV:
			case EQUAL:
			case GREATER:
			case GREATER_OR_EQUAL:
			case LESS:
			case LESS_OR_EQUAL:
			case MOD:
			case MUL:
			case NOT_EQUAL:
			case SHIFT_LEFT:
			case SHIFT_RIGHT:
			case SUB:
				{
				alt10 = 1;
				}
				break;
			case IDENT:
				{
				alt10 = 2;
				}
				break;
			case INTEGER:
				{
				alt10 = 3;
				}
				break;
			case FUNC_CALL:
				{
				alt10 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleCTreeWalker.g:103:2: ( ^(type= ADD left= expression right= expression ) | ^(type= SUB left= expression right= expression ) | ^(type= MUL left= expression right= expression ) | ^(type= DIV left= expression right= expression ) | ^(type= MOD left= expression right= expression ) | ^(type= SHIFT_LEFT left= expression right= expression ) | ^(type= SHIFT_RIGHT left= expression right= expression ) | ^(type= ASSIGN left= expression right= expression ) | ^(type= GREATER left= expression right= expression ) | ^(type= GREATER_OR_EQUAL left= expression right= expression ) | ^(type= LESS left= expression right= expression ) | ^(type= LESS_OR_EQUAL left= expression right= expression ) | ^(type= EQUAL left= expression right= expression ) | ^(type= NOT_EQUAL left= expression right= expression ) | ^(type= BOOL_AND left= expression right= expression ) | ^(type= BOOL_OR left= expression right= expression ) | ^(type= BIT_AND left= expression right= expression ) | ^(type= BIT_OR left= expression right= expression ) | ^(type= BIT_XOR left= expression right= expression ) )
				{
				DebugLocation(103, 2);
				// Grammar\\SimpleCTreeWalker.g:103:2: ( ^(type= ADD left= expression right= expression ) | ^(type= SUB left= expression right= expression ) | ^(type= MUL left= expression right= expression ) | ^(type= DIV left= expression right= expression ) | ^(type= MOD left= expression right= expression ) | ^(type= SHIFT_LEFT left= expression right= expression ) | ^(type= SHIFT_RIGHT left= expression right= expression ) | ^(type= ASSIGN left= expression right= expression ) | ^(type= GREATER left= expression right= expression ) | ^(type= GREATER_OR_EQUAL left= expression right= expression ) | ^(type= LESS left= expression right= expression ) | ^(type= LESS_OR_EQUAL left= expression right= expression ) | ^(type= EQUAL left= expression right= expression ) | ^(type= NOT_EQUAL left= expression right= expression ) | ^(type= BOOL_AND left= expression right= expression ) | ^(type= BOOL_OR left= expression right= expression ) | ^(type= BIT_AND left= expression right= expression ) | ^(type= BIT_OR left= expression right= expression ) | ^(type= BIT_XOR left= expression right= expression ) )
				int alt8=19;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				switch (input.LA(1))
				{
				case ADD:
					{
					alt8 = 1;
					}
					break;
				case SUB:
					{
					alt8 = 2;
					}
					break;
				case MUL:
					{
					alt8 = 3;
					}
					break;
				case DIV:
					{
					alt8 = 4;
					}
					break;
				case MOD:
					{
					alt8 = 5;
					}
					break;
				case SHIFT_LEFT:
					{
					alt8 = 6;
					}
					break;
				case SHIFT_RIGHT:
					{
					alt8 = 7;
					}
					break;
				case ASSIGN:
					{
					alt8 = 8;
					}
					break;
				case GREATER:
					{
					alt8 = 9;
					}
					break;
				case GREATER_OR_EQUAL:
					{
					alt8 = 10;
					}
					break;
				case LESS:
					{
					alt8 = 11;
					}
					break;
				case LESS_OR_EQUAL:
					{
					alt8 = 12;
					}
					break;
				case EQUAL:
					{
					alt8 = 13;
					}
					break;
				case NOT_EQUAL:
					{
					alt8 = 14;
					}
					break;
				case BOOL_AND:
					{
					alt8 = 15;
					}
					break;
				case BOOL_OR:
					{
					alt8 = 16;
					}
					break;
				case BIT_AND:
					{
					alt8 = 17;
					}
					break;
				case BIT_OR:
					{
					alt8 = 18;
					}
					break;
				case BIT_XOR:
					{
					alt8 = 19;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleCTreeWalker.g:104:3: ^(type= ADD left= expression right= expression )
					{
					DebugLocation(104, 3);
					DebugLocation(104, 9);
					type=(CommonTree)Match(input,ADD,Follow._ADD_in_expression382); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(104, 18);
					PushFollow(Follow._expression_in_expression386);
					left=expression();
					PopFollow();

					DebugLocation(104, 35);
					PushFollow(Follow._expression_in_expression390);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammar\\SimpleCTreeWalker.g:105:5: ^(type= SUB left= expression right= expression )
					{
					DebugLocation(105, 5);
					DebugLocation(105, 11);
					type=(CommonTree)Match(input,SUB,Follow._SUB_in_expression400); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(105, 20);
					PushFollow(Follow._expression_in_expression404);
					left=expression();
					PopFollow();

					DebugLocation(105, 37);
					PushFollow(Follow._expression_in_expression408);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammar\\SimpleCTreeWalker.g:106:5: ^(type= MUL left= expression right= expression )
					{
					DebugLocation(106, 5);
					DebugLocation(106, 11);
					type=(CommonTree)Match(input,MUL,Follow._MUL_in_expression418); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(106, 20);
					PushFollow(Follow._expression_in_expression422);
					left=expression();
					PopFollow();

					DebugLocation(106, 37);
					PushFollow(Follow._expression_in_expression426);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Grammar\\SimpleCTreeWalker.g:107:5: ^(type= DIV left= expression right= expression )
					{
					DebugLocation(107, 5);
					DebugLocation(107, 11);
					type=(CommonTree)Match(input,DIV,Follow._DIV_in_expression436); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(107, 20);
					PushFollow(Follow._expression_in_expression440);
					left=expression();
					PopFollow();

					DebugLocation(107, 37);
					PushFollow(Follow._expression_in_expression444);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Grammar\\SimpleCTreeWalker.g:108:5: ^(type= MOD left= expression right= expression )
					{
					DebugLocation(108, 5);
					DebugLocation(108, 11);
					type=(CommonTree)Match(input,MOD,Follow._MOD_in_expression454); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(108, 20);
					PushFollow(Follow._expression_in_expression458);
					left=expression();
					PopFollow();

					DebugLocation(108, 37);
					PushFollow(Follow._expression_in_expression462);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 6:
					DebugEnterAlt(6);
					// Grammar\\SimpleCTreeWalker.g:109:5: ^(type= SHIFT_LEFT left= expression right= expression )
					{
					DebugLocation(109, 5);
					DebugLocation(109, 11);
					type=(CommonTree)Match(input,SHIFT_LEFT,Follow._SHIFT_LEFT_in_expression472); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(109, 27);
					PushFollow(Follow._expression_in_expression476);
					left=expression();
					PopFollow();

					DebugLocation(109, 44);
					PushFollow(Follow._expression_in_expression480);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 7:
					DebugEnterAlt(7);
					// Grammar\\SimpleCTreeWalker.g:110:5: ^(type= SHIFT_RIGHT left= expression right= expression )
					{
					DebugLocation(110, 5);
					DebugLocation(110, 11);
					type=(CommonTree)Match(input,SHIFT_RIGHT,Follow._SHIFT_RIGHT_in_expression490); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(110, 28);
					PushFollow(Follow._expression_in_expression494);
					left=expression();
					PopFollow();

					DebugLocation(110, 45);
					PushFollow(Follow._expression_in_expression498);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 8:
					DebugEnterAlt(8);
					// Grammar\\SimpleCTreeWalker.g:111:5: ^(type= ASSIGN left= expression right= expression )
					{
					DebugLocation(111, 5);
					DebugLocation(111, 11);
					type=(CommonTree)Match(input,ASSIGN,Follow._ASSIGN_in_expression508); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(111, 23);
					PushFollow(Follow._expression_in_expression512);
					left=expression();
					PopFollow();

					DebugLocation(111, 40);
					PushFollow(Follow._expression_in_expression516);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 9:
					DebugEnterAlt(9);
					// Grammar\\SimpleCTreeWalker.g:112:5: ^(type= GREATER left= expression right= expression )
					{
					DebugLocation(112, 5);
					DebugLocation(112, 11);
					type=(CommonTree)Match(input,GREATER,Follow._GREATER_in_expression526); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(112, 24);
					PushFollow(Follow._expression_in_expression530);
					left=expression();
					PopFollow();

					DebugLocation(112, 41);
					PushFollow(Follow._expression_in_expression534);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 10:
					DebugEnterAlt(10);
					// Grammar\\SimpleCTreeWalker.g:113:5: ^(type= GREATER_OR_EQUAL left= expression right= expression )
					{
					DebugLocation(113, 5);
					DebugLocation(113, 11);
					type=(CommonTree)Match(input,GREATER_OR_EQUAL,Follow._GREATER_OR_EQUAL_in_expression544); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(113, 33);
					PushFollow(Follow._expression_in_expression548);
					left=expression();
					PopFollow();

					DebugLocation(113, 50);
					PushFollow(Follow._expression_in_expression552);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 11:
					DebugEnterAlt(11);
					// Grammar\\SimpleCTreeWalker.g:114:5: ^(type= LESS left= expression right= expression )
					{
					DebugLocation(114, 5);
					DebugLocation(114, 11);
					type=(CommonTree)Match(input,LESS,Follow._LESS_in_expression562); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(114, 21);
					PushFollow(Follow._expression_in_expression566);
					left=expression();
					PopFollow();

					DebugLocation(114, 38);
					PushFollow(Follow._expression_in_expression570);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 12:
					DebugEnterAlt(12);
					// Grammar\\SimpleCTreeWalker.g:115:5: ^(type= LESS_OR_EQUAL left= expression right= expression )
					{
					DebugLocation(115, 5);
					DebugLocation(115, 11);
					type=(CommonTree)Match(input,LESS_OR_EQUAL,Follow._LESS_OR_EQUAL_in_expression580); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(115, 30);
					PushFollow(Follow._expression_in_expression584);
					left=expression();
					PopFollow();

					DebugLocation(115, 47);
					PushFollow(Follow._expression_in_expression588);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 13:
					DebugEnterAlt(13);
					// Grammar\\SimpleCTreeWalker.g:116:5: ^(type= EQUAL left= expression right= expression )
					{
					DebugLocation(116, 5);
					DebugLocation(116, 11);
					type=(CommonTree)Match(input,EQUAL,Follow._EQUAL_in_expression598); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(116, 22);
					PushFollow(Follow._expression_in_expression602);
					left=expression();
					PopFollow();

					DebugLocation(116, 39);
					PushFollow(Follow._expression_in_expression606);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 14:
					DebugEnterAlt(14);
					// Grammar\\SimpleCTreeWalker.g:117:5: ^(type= NOT_EQUAL left= expression right= expression )
					{
					DebugLocation(117, 5);
					DebugLocation(117, 11);
					type=(CommonTree)Match(input,NOT_EQUAL,Follow._NOT_EQUAL_in_expression616); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(117, 26);
					PushFollow(Follow._expression_in_expression620);
					left=expression();
					PopFollow();

					DebugLocation(117, 43);
					PushFollow(Follow._expression_in_expression624);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 15:
					DebugEnterAlt(15);
					// Grammar\\SimpleCTreeWalker.g:118:5: ^(type= BOOL_AND left= expression right= expression )
					{
					DebugLocation(118, 5);
					DebugLocation(118, 11);
					type=(CommonTree)Match(input,BOOL_AND,Follow._BOOL_AND_in_expression634); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(118, 25);
					PushFollow(Follow._expression_in_expression638);
					left=expression();
					PopFollow();

					DebugLocation(118, 42);
					PushFollow(Follow._expression_in_expression642);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 16:
					DebugEnterAlt(16);
					// Grammar\\SimpleCTreeWalker.g:119:5: ^(type= BOOL_OR left= expression right= expression )
					{
					DebugLocation(119, 5);
					DebugLocation(119, 11);
					type=(CommonTree)Match(input,BOOL_OR,Follow._BOOL_OR_in_expression652); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(119, 24);
					PushFollow(Follow._expression_in_expression656);
					left=expression();
					PopFollow();

					DebugLocation(119, 41);
					PushFollow(Follow._expression_in_expression660);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 17:
					DebugEnterAlt(17);
					// Grammar\\SimpleCTreeWalker.g:120:5: ^(type= BIT_AND left= expression right= expression )
					{
					DebugLocation(120, 5);
					DebugLocation(120, 11);
					type=(CommonTree)Match(input,BIT_AND,Follow._BIT_AND_in_expression670); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(120, 24);
					PushFollow(Follow._expression_in_expression674);
					left=expression();
					PopFollow();

					DebugLocation(120, 41);
					PushFollow(Follow._expression_in_expression678);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 18:
					DebugEnterAlt(18);
					// Grammar\\SimpleCTreeWalker.g:121:5: ^(type= BIT_OR left= expression right= expression )
					{
					DebugLocation(121, 5);
					DebugLocation(121, 11);
					type=(CommonTree)Match(input,BIT_OR,Follow._BIT_OR_in_expression688); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(121, 23);
					PushFollow(Follow._expression_in_expression692);
					left=expression();
					PopFollow();

					DebugLocation(121, 40);
					PushFollow(Follow._expression_in_expression696);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 19:
					DebugEnterAlt(19);
					// Grammar\\SimpleCTreeWalker.g:122:5: ^(type= BIT_XOR left= expression right= expression )
					{
					DebugLocation(122, 5);
					DebugLocation(122, 11);
					type=(CommonTree)Match(input,BIT_XOR,Follow._BIT_XOR_in_expression706); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(122, 24);
					PushFollow(Follow._expression_in_expression710);
					left=expression();
					PopFollow();

					DebugLocation(122, 41);
					PushFollow(Follow._expression_in_expression714);
					right=expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;

				}
				} finally { DebugExitSubRule(8); }

				DebugLocation(123, 4);
				 node = new BinaryExprNode(type.Type, left, right); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleCTreeWalker.g:148:4: IDENT
				{
				DebugLocation(148, 4);
				IDENT19=(CommonTree)Match(input,IDENT,Follow._IDENT_in_expression728); 
				DebugLocation(148, 10);
				 
						node = new IdentNode();
						(node as IdentNode).Name = IDENT19.Text;
					

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleCTreeWalker.g:152:4: INTEGER
				{
				DebugLocation(152, 4);
				INTEGER20=(CommonTree)Match(input,INTEGER,Follow._INTEGER_in_expression735); 
				DebugLocation(152, 12);

						node = new IntegerNode(INTEGER20.Text);
					

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleCTreeWalker.g:155:4: ^( FUNC_CALL IDENT ^( PARAM_LIST (parameter= expression )* ) )
				{
				DebugLocation(155, 4);
				DebugLocation(155, 6);
				Match(input,FUNC_CALL,Follow._FUNC_CALL_in_expression743); 

				DebugLocation(155, 16);

							List<IExprNode> parameters = new List<IExprNode>();
						

				Match(input, TokenTypes.Down, null); 
				DebugLocation(158, 4);
				IDENT21=(CommonTree)Match(input,IDENT,Follow._IDENT_in_expression751); 
				DebugLocation(158, 10);

								if (!FuncDeclsContainer.Contains(new FuncDeclEquatable(IDENT21.Text)))
							
				DebugLocation(161, 4);
				DebugLocation(161, 6);
				Match(input,PARAM_LIST,Follow._PARAM_LIST_in_expression760); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(161, 17);
					// Grammar\\SimpleCTreeWalker.g:161:17: (parameter= expression )*
					try { DebugEnterSubRule(9);
					while (true)
					{
						int alt9=2;
						try { DebugEnterDecision(9, false);
						int LA9_0 = input.LA(1);

						if (((LA9_0>=ADD && LA9_0<=BIT_AND)||(LA9_0>=BIT_OR && LA9_0<=BOOL_AND)||LA9_0==BOOL_OR||(LA9_0>=DIV && LA9_0<=EQUAL)||LA9_0==FUNC_CALL||(LA9_0>=GREATER && LA9_0<=IDENT)||LA9_0==INTEGER||(LA9_0>=LESS && LA9_0<=NOT_EQUAL)||(LA9_0>=SHIFT_LEFT && LA9_0<=SHIFT_RIGHT)||LA9_0==SUB))
						{
							alt9 = 1;
						}


						} finally { DebugExitDecision(9); }
						switch ( alt9 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammar\\SimpleCTreeWalker.g:161:18: parameter= expression
							{
							DebugLocation(161, 27);
							PushFollow(Follow._expression_in_expression765);
							parameter=expression();
							PopFollow();

							DebugLocation(161, 39);
							 parameters.Add(parameter); 

							}
							break;

						default:
							goto loop9;
						}
					}

					loop9:
						;

					} finally { DebugExitSubRule(9); }


					Match(input, TokenTypes.Up, null); 
				}


				Match(input, TokenTypes.Up, null); 

				DebugLocation(161, 80);


						FuncCallNode funcCallNode = new FuncCallNode();
						node = funcCallNode;
						funcCallNode.Function = FuncDeclsContainer.Get(new FuncDeclEquatable(IDENT21.Text));

						// Check parameters
						switch(FuncCallNode.ParameterListMatches(funcCallNode.Function.Parameters, parameters))
						{
							case FuncCallNode.ParameterMatching.ParameterCountMismatch:
								break;
							case FuncCallNode.ParameterMatching.ParameterTypeMismatch:
								break;
							default:
								// There is no error so do nothing
								break;
						}

						funcCallNode.Parameters = parameters;
					

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 10);
			LeaveRule("expression", 10);
			LeaveRule_expression();
		}
		DebugLocation(181, 0);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return node;

	}
	// $ANTLR end "expression"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _PROGRAM_in_walk61 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _programStatement_in_walk64 = new BitSet(new ulong[]{0x200000000600008UL});
		public static readonly BitSet _varDef_in_programStatement83 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcDecl_in_programStatement90 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcDef_in_programStatement97 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_DEF_in_varDef113 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _varSpec_in_varDef115 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FUNC_DECL_in_funcDecl138 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeSpec_in_funcDecl143 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENT_in_funcDecl150 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _PARAM_SPEC_LIST_in_funcDecl157 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _varSpec_in_funcDecl160 = new BitSet(new ulong[]{0x400000000000008UL});
		public static readonly BitSet _FUNC_DEF_in_funcDef188 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeSpec_in_funcDef193 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENT_in_funcDef199 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _PARAM_SPEC_LIST_in_funcDef206 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _varSpec_in_funcDef209 = new BitSet(new ulong[]{0x400000000000008UL});
		public static readonly BitSet _funcBody_in_funcDef219 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VAR_SPEC_in_varSpec242 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _typeSpec_in_varSpec244 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENT_in_varSpec246 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_SPEC_in_typeSpec269 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENT_in_typeSpec271 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FUNC_BODY_in_funcBody294 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_funcBody297 = new BitSet(new ulong[]{0x200200000000008UL});
		public static readonly BitSet _varDef_in_statement315 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STATEMENT_in_statement322 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STATEMENT_in_statement331 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_statement333 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STATEMENT_in_statement342 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_statement354 = new BitSet(new ulong[]{0x200200000000008UL});
		public static readonly BitSet _ADD_in_expression382 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression386 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression390 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SUB_in_expression400 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression404 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression408 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MUL_in_expression418 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression422 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression426 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DIV_in_expression436 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression440 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression444 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MOD_in_expression454 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression458 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression462 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SHIFT_LEFT_in_expression472 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression476 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression480 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SHIFT_RIGHT_in_expression490 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression494 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression498 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASSIGN_in_expression508 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression512 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression516 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GREATER_in_expression526 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression530 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression534 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GREATER_OR_EQUAL_in_expression544 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression548 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression552 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LESS_in_expression562 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression566 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression570 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LESS_OR_EQUAL_in_expression580 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression584 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression588 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EQUAL_in_expression598 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression602 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression606 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NOT_EQUAL_in_expression616 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression620 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression624 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BOOL_AND_in_expression634 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression638 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression642 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BOOL_OR_in_expression652 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression656 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression660 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BIT_AND_in_expression670 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression674 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression678 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BIT_OR_in_expression688 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression692 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression696 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BIT_XOR_in_expression706 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression710 = new BitSet(new ulong[]{0x1061F13931770UL});
		public static readonly BitSet _expression_in_expression714 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IDENT_in_expression728 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_expression735 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNC_CALL_in_expression743 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENT_in_expression751 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _PARAM_LIST_in_expression760 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression765 = new BitSet(new ulong[]{0x1061F13931778UL});
	}
	#endregion Follow sets
}

} // namespace  SimpleC.Grammar 
