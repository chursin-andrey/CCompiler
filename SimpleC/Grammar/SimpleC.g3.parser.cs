//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 Grammar\\SimpleC.g 2015-10-06 18:13:40

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


#pragma warning disable 3021


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  SimpleC.Grammar 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class SimpleCParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "ASSIGN", "BIT_AND", "BIT_NOT", "BIT_OR", "BIT_XOR", "BOOL_AND", "BOOL_NOT", "BOOL_OR", "DEC_POST", "DEC_PRE", "DEREF", "DIV", "EQUAL", "EXPRESSION", "FUNC_BODY", "FUNC_CALL", "FUNC_DECL", "FUNC_DEF", "GREATER", "GREATER_OR_EQUAL", "IDENT", "INC_POST", "INC_PRE", "INTEGER", "Identifier", "Int", "Integer", "LESS", "LESS_OR_EQUAL", "MOD", "MUL", "NOT_EQUAL", "PARAM_LIST", "PARAM_SPEC_LIST", "PROGRAM", "REF", "SHIFT_LEFT", "SHIFT_RIGHT", "SIZEOF_EXPR", "SIZEOF_TYPE", "STATEMENT", "STRUCT_DEREF", "STRUCT_MEMBER", "SUB", "SUBSCRIPT", "SizeOf", "TYPECAST", "TYPE_SPEC", "U_MINUS", "U_PLUS", "VAR_CALL", "VAR_DECL", "VAR_DEF", "VAR_SPEC", "Void", "Whitespace", "'!'", "'('", "')'", "'++'", "','", "'--'", "'->'", "'.'", "';'", "'['", "']'", "'{'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int ADD=4;
	public const int ASSIGN=5;
	public const int BIT_AND=6;
	public const int BIT_NOT=7;
	public const int BIT_OR=8;
	public const int BIT_XOR=9;
	public const int BOOL_AND=10;
	public const int BOOL_NOT=11;
	public const int BOOL_OR=12;
	public const int DEC_POST=13;
	public const int DEC_PRE=14;
	public const int DEREF=15;
	public const int DIV=16;
	public const int EQUAL=17;
	public const int EXPRESSION=18;
	public const int FUNC_BODY=19;
	public const int FUNC_CALL=20;
	public const int FUNC_DECL=21;
	public const int FUNC_DEF=22;
	public const int GREATER=23;
	public const int GREATER_OR_EQUAL=24;
	public const int IDENT=25;
	public const int INC_POST=26;
	public const int INC_PRE=27;
	public const int INTEGER=28;
	public const int Identifier=29;
	public const int Int=30;
	public const int Integer=31;
	public const int LESS=32;
	public const int LESS_OR_EQUAL=33;
	public const int MOD=34;
	public const int MUL=35;
	public const int NOT_EQUAL=36;
	public const int PARAM_LIST=37;
	public const int PARAM_SPEC_LIST=38;
	public const int PROGRAM=39;
	public const int REF=40;
	public const int SHIFT_LEFT=41;
	public const int SHIFT_RIGHT=42;
	public const int SIZEOF_EXPR=43;
	public const int SIZEOF_TYPE=44;
	public const int STATEMENT=45;
	public const int STRUCT_DEREF=46;
	public const int STRUCT_MEMBER=47;
	public const int SUB=48;
	public const int SUBSCRIPT=49;
	public const int SizeOf=50;
	public const int TYPECAST=51;
	public const int TYPE_SPEC=52;
	public const int U_MINUS=53;
	public const int U_PLUS=54;
	public const int VAR_CALL=55;
	public const int VAR_DECL=56;
	public const int VAR_DEF=57;
	public const int VAR_SPEC=58;
	public const int Void=59;
	public const int Whitespace=60;

	public SimpleCParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public SimpleCParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return SimpleCParser.tokenNames; } }
	public override string GrammarFileName { get { return "Grammar\\SimpleC.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// Grammar\\SimpleC.g:92:1: public program : ( programStatement )* EOF -> ^( PROGRAM ( programStatement )* ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken EOF2 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> programStatement1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree EOF2_tree = default(CommonTree);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_programStatement=new RewriteRuleSubtreeStream(adaptor,"rule programStatement");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(92, 0);
		try
		{
			// Grammar\\SimpleC.g:92:8: ( ( programStatement )* EOF -> ^( PROGRAM ( programStatement )* ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:93:2: ( programStatement )* EOF
			{
			DebugLocation(93, 2);
			// Grammar\\SimpleC.g:93:2: ( programStatement )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==Int||LA1_0==Void))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:93:2: programStatement
					{
					DebugLocation(93, 2);
					PushFollow(Follow._programStatement_in_program987);
					programStatement1=programStatement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_programStatement.Add(programStatement1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(93, 20);
			EOF2=(CommonToken)Match(input,EOF,Follow._EOF_in_program990); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: programStatement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 94:2: -> ^( PROGRAM ( programStatement )* )
			{
				DebugLocation(94, 5);
				// Grammar\\SimpleC.g:94:5: ^( PROGRAM ( programStatement )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(94, 7);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(94, 15);
				// Grammar\\SimpleC.g:94:15: ( programStatement )*
				while ( stream_programStatement.HasNext )
				{
					DebugLocation(94, 15);
					adaptor.AddChild(root_1, stream_programStatement.NextTree());

				}
				stream_programStatement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(95, 0);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_programStatement();
	partial void LeaveRule_programStatement();

	// $ANTLR start "programStatement"
	// Grammar\\SimpleC.g:97:1: programStatement : ( varDef | funcDecl | funcDef );
	[GrammarRule("programStatement")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> programStatement()
	{
		EnterRule_programStatement();
		EnterRule("programStatement", 2);
		TraceIn("programStatement", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> varDef3 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> funcDecl4 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> funcDef5 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		try { DebugEnterRule(GrammarFileName, "programStatement");
		DebugLocation(97, 0);
		try
		{
			// Grammar\\SimpleC.g:97:17: ( varDef | funcDecl | funcDef )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			try
			{
				alt2 = dfa2.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:98:2: varDef
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(98, 2);
				PushFollow(Follow._varDef_in_programStatement1009);
				varDef3=varDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, varDef3.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:98:11: funcDecl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(98, 11);
				PushFollow(Follow._funcDecl_in_programStatement1013);
				funcDecl4=funcDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcDecl4.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleC.g:98:22: funcDef
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(98, 22);
				PushFollow(Follow._funcDef_in_programStatement1017);
				funcDef5=funcDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcDef5.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("programStatement", 2);
			LeaveRule("programStatement", 2);
			LeaveRule_programStatement();
		}
		DebugLocation(99, 0);
		} finally { DebugExitRule(GrammarFileName, "programStatement"); }
		return retval;

	}
	// $ANTLR end "programStatement"

	partial void EnterRule_varDef();
	partial void LeaveRule_varDef();

	// $ANTLR start "varDef"
	// Grammar\\SimpleC.g:101:1: varDef : varSpec ';' -> ^( VAR_DEF varSpec ) ;
	[GrammarRule("varDef")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> varDef()
	{
		EnterRule_varDef();
		EnterRule("varDef", 3);
		TraceIn("varDef", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal7 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> varSpec6 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal7_tree = default(CommonTree);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleSubtreeStream stream_varSpec=new RewriteRuleSubtreeStream(adaptor,"rule varSpec");
		try { DebugEnterRule(GrammarFileName, "varDef");
		DebugLocation(101, 0);
		try
		{
			// Grammar\\SimpleC.g:101:7: ( varSpec ';' -> ^( VAR_DEF varSpec ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:102:2: varSpec ';'
			{
			DebugLocation(102, 2);
			PushFollow(Follow._varSpec_in_varDef1026);
			varSpec6=varSpec();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_varSpec.Add(varSpec6.Tree);
			DebugLocation(102, 10);
			char_literal7=(CommonToken)Match(input,69,Follow._69_in_varDef1028); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(char_literal7);



			{
			// AST REWRITE
			// elements: varSpec
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 103:3: -> ^( VAR_DEF varSpec )
			{
				DebugLocation(103, 6);
				// Grammar\\SimpleC.g:103:6: ^( VAR_DEF varSpec )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(103, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VAR_DEF, "VAR_DEF"), root_1);

				DebugLocation(103, 16);
				adaptor.AddChild(root_1, stream_varSpec.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("varDef", 3);
			LeaveRule("varDef", 3);
			LeaveRule_varDef();
		}
		DebugLocation(104, 0);
		} finally { DebugExitRule(GrammarFileName, "varDef"); }
		return retval;

	}
	// $ANTLR end "varDef"

	partial void EnterRule_funcDecl();
	partial void LeaveRule_funcDecl();

	// $ANTLR start "funcDecl"
	// Grammar\\SimpleC.g:106:1: funcDecl : typeSpec identifier '(' paramSpecList ')' ';' -> ^( FUNC_DECL typeSpec identifier paramSpecList ) ;
	[GrammarRule("funcDecl")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> funcDecl()
	{
		EnterRule_funcDecl();
		EnterRule("funcDecl", 4);
		TraceIn("funcDecl", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal10 = default(CommonToken);
		CommonToken char_literal12 = default(CommonToken);
		CommonToken char_literal13 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec8 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> identifier9 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> paramSpecList11 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal10_tree = default(CommonTree);
		CommonTree char_literal12_tree = default(CommonTree);
		CommonTree char_literal13_tree = default(CommonTree);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_paramSpecList=new RewriteRuleSubtreeStream(adaptor,"rule paramSpecList");
		RewriteRuleSubtreeStream stream_typeSpec=new RewriteRuleSubtreeStream(adaptor,"rule typeSpec");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "funcDecl");
		DebugLocation(106, 0);
		try
		{
			// Grammar\\SimpleC.g:106:9: ( typeSpec identifier '(' paramSpecList ')' ';' -> ^( FUNC_DECL typeSpec identifier paramSpecList ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:107:2: typeSpec identifier '(' paramSpecList ')' ';'
			{
			DebugLocation(107, 2);
			PushFollow(Follow._typeSpec_in_funcDecl1048);
			typeSpec8=typeSpec();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeSpec.Add(typeSpec8.Tree);
			DebugLocation(107, 11);
			PushFollow(Follow._identifier_in_funcDecl1050);
			identifier9=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier9.Tree);
			DebugLocation(107, 22);
			char_literal10=(CommonToken)Match(input,62,Follow._62_in_funcDecl1052); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal10);

			DebugLocation(107, 26);
			PushFollow(Follow._paramSpecList_in_funcDecl1054);
			paramSpecList11=paramSpecList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_paramSpecList.Add(paramSpecList11.Tree);
			DebugLocation(107, 40);
			char_literal12=(CommonToken)Match(input,63,Follow._63_in_funcDecl1056); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal12);

			DebugLocation(107, 43);
			char_literal13=(CommonToken)Match(input,69,Follow._69_in_funcDecl1057); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(char_literal13);



			{
			// AST REWRITE
			// elements: paramSpecList, typeSpec, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 108:3: -> ^( FUNC_DECL typeSpec identifier paramSpecList )
			{
				DebugLocation(108, 6);
				// Grammar\\SimpleC.g:108:6: ^( FUNC_DECL typeSpec identifier paramSpecList )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(108, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC_DECL, "FUNC_DECL"), root_1);

				DebugLocation(108, 18);
				adaptor.AddChild(root_1, stream_typeSpec.NextTree());
				DebugLocation(108, 27);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(108, 38);
				adaptor.AddChild(root_1, stream_paramSpecList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcDecl", 4);
			LeaveRule("funcDecl", 4);
			LeaveRule_funcDecl();
		}
		DebugLocation(109, 0);
		} finally { DebugExitRule(GrammarFileName, "funcDecl"); }
		return retval;

	}
	// $ANTLR end "funcDecl"

	partial void EnterRule_funcDef();
	partial void LeaveRule_funcDef();

	// $ANTLR start "funcDef"
	// Grammar\\SimpleC.g:111:1: funcDef : typeSpec identifier '(' paramSpecList ')' '{' funcBody '}' -> ^( FUNC_DEF typeSpec identifier paramSpecList funcBody ) ;
	[GrammarRule("funcDef")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> funcDef()
	{
		EnterRule_funcDef();
		EnterRule("funcDef", 5);
		TraceIn("funcDef", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal16 = default(CommonToken);
		CommonToken char_literal18 = default(CommonToken);
		CommonToken char_literal19 = default(CommonToken);
		CommonToken char_literal21 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec14 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> identifier15 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> paramSpecList17 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> funcBody20 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal16_tree = default(CommonTree);
		CommonTree char_literal18_tree = default(CommonTree);
		CommonTree char_literal19_tree = default(CommonTree);
		CommonTree char_literal21_tree = default(CommonTree);
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleSubtreeStream stream_paramSpecList=new RewriteRuleSubtreeStream(adaptor,"rule paramSpecList");
		RewriteRuleSubtreeStream stream_typeSpec=new RewriteRuleSubtreeStream(adaptor,"rule typeSpec");
		RewriteRuleSubtreeStream stream_funcBody=new RewriteRuleSubtreeStream(adaptor,"rule funcBody");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "funcDef");
		DebugLocation(111, 0);
		try
		{
			// Grammar\\SimpleC.g:111:8: ( typeSpec identifier '(' paramSpecList ')' '{' funcBody '}' -> ^( FUNC_DEF typeSpec identifier paramSpecList funcBody ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:112:2: typeSpec identifier '(' paramSpecList ')' '{' funcBody '}'
			{
			DebugLocation(112, 2);
			PushFollow(Follow._typeSpec_in_funcDef1081);
			typeSpec14=typeSpec();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeSpec.Add(typeSpec14.Tree);
			DebugLocation(112, 11);
			PushFollow(Follow._identifier_in_funcDef1083);
			identifier15=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier15.Tree);
			DebugLocation(112, 22);
			char_literal16=(CommonToken)Match(input,62,Follow._62_in_funcDef1085); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal16);

			DebugLocation(112, 26);
			PushFollow(Follow._paramSpecList_in_funcDef1087);
			paramSpecList17=paramSpecList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_paramSpecList.Add(paramSpecList17.Tree);
			DebugLocation(112, 40);
			char_literal18=(CommonToken)Match(input,63,Follow._63_in_funcDef1089); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal18);

			DebugLocation(112, 43);
			char_literal19=(CommonToken)Match(input,72,Follow._72_in_funcDef1090); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_72.Add(char_literal19);

			DebugLocation(112, 47);
			PushFollow(Follow._funcBody_in_funcDef1092);
			funcBody20=funcBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_funcBody.Add(funcBody20.Tree);
			DebugLocation(112, 56);
			char_literal21=(CommonToken)Match(input,73,Follow._73_in_funcDef1094); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_73.Add(char_literal21);



			{
			// AST REWRITE
			// elements: identifier, funcBody, typeSpec, paramSpecList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 113:3: -> ^( FUNC_DEF typeSpec identifier paramSpecList funcBody )
			{
				DebugLocation(113, 6);
				// Grammar\\SimpleC.g:113:6: ^( FUNC_DEF typeSpec identifier paramSpecList funcBody )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(113, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC_DEF, "FUNC_DEF"), root_1);

				DebugLocation(113, 17);
				adaptor.AddChild(root_1, stream_typeSpec.NextTree());
				DebugLocation(113, 26);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(113, 37);
				adaptor.AddChild(root_1, stream_paramSpecList.NextTree());
				DebugLocation(113, 51);
				adaptor.AddChild(root_1, stream_funcBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcDef", 5);
			LeaveRule("funcDef", 5);
			LeaveRule_funcDef();
		}
		DebugLocation(114, 0);
		} finally { DebugExitRule(GrammarFileName, "funcDef"); }
		return retval;

	}
	// $ANTLR end "funcDef"

	partial void EnterRule_paramSpecList();
	partial void LeaveRule_paramSpecList();

	// $ANTLR start "paramSpecList"
	// Grammar\\SimpleC.g:116:1: paramSpecList : ( varSpec ( ',' varSpec )* )? -> ^( PARAM_SPEC_LIST ( varSpec )* ) ;
	[GrammarRule("paramSpecList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> paramSpecList()
	{
		EnterRule_paramSpecList();
		EnterRule("paramSpecList", 6);
		TraceIn("paramSpecList", 6);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal23 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> varSpec22 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> varSpec24 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal23_tree = default(CommonTree);
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleSubtreeStream stream_varSpec=new RewriteRuleSubtreeStream(adaptor,"rule varSpec");
		try { DebugEnterRule(GrammarFileName, "paramSpecList");
		DebugLocation(116, 0);
		try
		{
			// Grammar\\SimpleC.g:116:14: ( ( varSpec ( ',' varSpec )* )? -> ^( PARAM_SPEC_LIST ( varSpec )* ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:117:2: ( varSpec ( ',' varSpec )* )?
			{
			DebugLocation(117, 2);
			// Grammar\\SimpleC.g:117:2: ( varSpec ( ',' varSpec )* )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==Int||LA4_0==Void))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:117:3: varSpec ( ',' varSpec )*
				{
				DebugLocation(117, 3);
				PushFollow(Follow._varSpec_in_paramSpecList1121);
				varSpec22=varSpec();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_varSpec.Add(varSpec22.Tree);
				DebugLocation(117, 11);
				// Grammar\\SimpleC.g:117:11: ( ',' varSpec )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_0 = input.LA(1);

					if ((LA3_0==65))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleC.g:117:12: ',' varSpec
						{
						DebugLocation(117, 12);
						char_literal23=(CommonToken)Match(input,65,Follow._65_in_paramSpecList1124); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_65.Add(char_literal23);

						DebugLocation(117, 16);
						PushFollow(Follow._varSpec_in_paramSpecList1126);
						varSpec24=varSpec();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_varSpec.Add(varSpec24.Tree);

						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }


				}
				break;

			}
			} finally { DebugExitSubRule(4); }



			{
			// AST REWRITE
			// elements: varSpec
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 117:28: -> ^( PARAM_SPEC_LIST ( varSpec )* )
			{
				DebugLocation(117, 31);
				// Grammar\\SimpleC.g:117:31: ^( PARAM_SPEC_LIST ( varSpec )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(117, 33);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PARAM_SPEC_LIST, "PARAM_SPEC_LIST"), root_1);

				DebugLocation(117, 49);
				// Grammar\\SimpleC.g:117:49: ( varSpec )*
				while ( stream_varSpec.HasNext )
				{
					DebugLocation(117, 49);
					adaptor.AddChild(root_1, stream_varSpec.NextTree());

				}
				stream_varSpec.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("paramSpecList", 6);
			LeaveRule("paramSpecList", 6);
			LeaveRule_paramSpecList();
		}
		DebugLocation(118, 0);
		} finally { DebugExitRule(GrammarFileName, "paramSpecList"); }
		return retval;

	}
	// $ANTLR end "paramSpecList"

	partial void EnterRule_funcBody();
	partial void LeaveRule_funcBody();

	// $ANTLR start "funcBody"
	// Grammar\\SimpleC.g:120:1: funcBody : statements -> ^( FUNC_BODY ( statements )? ) ;
	[GrammarRule("funcBody")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> funcBody()
	{
		EnterRule_funcBody();
		EnterRule("funcBody", 7);
		TraceIn("funcBody", 7);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> statements25 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		try { DebugEnterRule(GrammarFileName, "funcBody");
		DebugLocation(120, 0);
		try
		{
			// Grammar\\SimpleC.g:120:9: ( statements -> ^( FUNC_BODY ( statements )? ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:121:2: statements
			{
			DebugLocation(121, 2);
			PushFollow(Follow._statements_in_funcBody1148);
			statements25=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements25.Tree);


			{
			// AST REWRITE
			// elements: statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 121:13: -> ^( FUNC_BODY ( statements )? )
			{
				DebugLocation(121, 16);
				// Grammar\\SimpleC.g:121:16: ^( FUNC_BODY ( statements )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(121, 18);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC_BODY, "FUNC_BODY"), root_1);

				DebugLocation(121, 28);
				// Grammar\\SimpleC.g:121:28: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(121, 28);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcBody", 7);
			LeaveRule("funcBody", 7);
			LeaveRule_funcBody();
		}
		DebugLocation(122, 0);
		} finally { DebugExitRule(GrammarFileName, "funcBody"); }
		return retval;

	}
	// $ANTLR end "funcBody"

	partial void EnterRule_statements();
	partial void LeaveRule_statements();

	// $ANTLR start "statements"
	// Grammar\\SimpleC.g:124:1: statements : ( statement )* ;
	[GrammarRule("statements")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> statements()
	{
		EnterRule_statements();
		EnterRule("statements", 8);
		TraceIn("statements", 8);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> statement26 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		try { DebugEnterRule(GrammarFileName, "statements");
		DebugLocation(124, 0);
		try
		{
			// Grammar\\SimpleC.g:124:11: ( ( statement )* )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:125:2: ( statement )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(125, 2);
			// Grammar\\SimpleC.g:125:2: ( statement )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==ADD||LA5_0==BIT_AND||(LA5_0>=Identifier && LA5_0<=Integer)||LA5_0==MUL||LA5_0==SUB||LA5_0==SizeOf||LA5_0==Void||(LA5_0>=61 && LA5_0<=62)||LA5_0==64||LA5_0==66||LA5_0==69||LA5_0==72||LA5_0==74))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:125:2: statement
					{
					DebugLocation(125, 2);
					PushFollow(Follow._statement_in_statements1166);
					statement26=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, statement26.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statements", 8);
			LeaveRule("statements", 8);
			LeaveRule_statements();
		}
		DebugLocation(126, 0);
		} finally { DebugExitRule(GrammarFileName, "statements"); }
		return retval;

	}
	// $ANTLR end "statements"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// Grammar\\SimpleC.g:128:1: statement : ( varDef | ( expr )? ';' -> ^( STATEMENT ( expr )? ) | '{' statements '}' -> ^( STATEMENT ( statements )? ) );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 9);
		TraceIn("statement", 9);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal29 = default(CommonToken);
		CommonToken char_literal30 = default(CommonToken);
		CommonToken char_literal32 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> varDef27 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr28 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> statements31 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal29_tree = default(CommonTree);
		CommonTree char_literal30_tree = default(CommonTree);
		CommonTree char_literal32_tree = default(CommonTree);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(128, 0);
		try
		{
			// Grammar\\SimpleC.g:128:10: ( varDef | ( expr )? ';' -> ^( STATEMENT ( expr )? ) | '{' statements '}' -> ^( STATEMENT ( statements )? ) )
			int alt7=3;
			try { DebugEnterDecision(7, false);
			switch (input.LA(1))
			{
			case Int:
			case Void:
				{
				alt7 = 1;
				}
				break;
			case ADD:
			case BIT_AND:
			case Identifier:
			case Integer:
			case MUL:
			case SUB:
			case SizeOf:
			case 61:
			case 62:
			case 64:
			case 66:
			case 69:
			case 74:
				{
				alt7 = 2;
				}
				break;
			case 72:
				{
				alt7 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:129:2: varDef
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(129, 2);
				PushFollow(Follow._varDef_in_statement1176);
				varDef27=varDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, varDef27.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:130:4: ( expr )? ';'
				{
				DebugLocation(130, 4);
				// Grammar\\SimpleC.g:130:4: ( expr )?
				int alt6=2;
				try { DebugEnterSubRule(6);
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==ADD||LA6_0==BIT_AND||LA6_0==Identifier||LA6_0==Integer||LA6_0==MUL||LA6_0==SUB||LA6_0==SizeOf||(LA6_0>=61 && LA6_0<=62)||LA6_0==64||LA6_0==66||LA6_0==74))
				{
					alt6 = 1;
				}
				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:130:4: expr
					{
					DebugLocation(130, 4);
					PushFollow(Follow._expr_in_statement1181);
					expr28=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr.Add(expr28.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(6); }

				DebugLocation(130, 10);
				char_literal29=(CommonToken)Match(input,69,Follow._69_in_statement1184); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_69.Add(char_literal29);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 130:14: -> ^( STATEMENT ( expr )? )
				{
					DebugLocation(130, 17);
					// Grammar\\SimpleC.g:130:17: ^( STATEMENT ( expr )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(130, 19);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(STATEMENT, "STATEMENT"), root_1);

					DebugLocation(130, 29);
					// Grammar\\SimpleC.g:130:29: ( expr )?
					if (stream_expr.HasNext)
					{
						DebugLocation(130, 29);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleC.g:131:4: '{' statements '}'
				{
				DebugLocation(131, 4);
				char_literal30=(CommonToken)Match(input,72,Follow._72_in_statement1198); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_72.Add(char_literal30);

				DebugLocation(131, 8);
				PushFollow(Follow._statements_in_statement1200);
				statements31=statements();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statements.Add(statements31.Tree);
				DebugLocation(131, 19);
				char_literal32=(CommonToken)Match(input,73,Follow._73_in_statement1202); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_73.Add(char_literal32);



				{
				// AST REWRITE
				// elements: statements
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 131:23: -> ^( STATEMENT ( statements )? )
				{
					DebugLocation(131, 26);
					// Grammar\\SimpleC.g:131:26: ^( STATEMENT ( statements )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(131, 28);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(STATEMENT, "STATEMENT"), root_1);

					DebugLocation(131, 38);
					// Grammar\\SimpleC.g:131:38: ( statements )?
					if (stream_statements.HasNext)
					{
						DebugLocation(131, 38);
						adaptor.AddChild(root_1, stream_statements.NextTree());

					}
					stream_statements.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 9);
			LeaveRule("statement", 9);
			LeaveRule_statement();
		}
		DebugLocation(132, 0);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_varSpec();
	partial void LeaveRule_varSpec();

	// $ANTLR start "varSpec"
	// Grammar\\SimpleC.g:134:1: varSpec : typeSpec identifier -> ^( VAR_SPEC typeSpec identifier ) ;
	[GrammarRule("varSpec")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> varSpec()
	{
		EnterRule_varSpec();
		EnterRule("varSpec", 10);
		TraceIn("varSpec", 10);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec33 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> identifier34 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		RewriteRuleSubtreeStream stream_typeSpec=new RewriteRuleSubtreeStream(adaptor,"rule typeSpec");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "varSpec");
		DebugLocation(134, 0);
		try
		{
			// Grammar\\SimpleC.g:134:8: ( typeSpec identifier -> ^( VAR_SPEC typeSpec identifier ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:135:5: typeSpec identifier
			{
			DebugLocation(135, 5);
			PushFollow(Follow._typeSpec_in_varSpec1223);
			typeSpec33=typeSpec();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeSpec.Add(typeSpec33.Tree);
			DebugLocation(135, 14);
			PushFollow(Follow._identifier_in_varSpec1225);
			identifier34=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier34.Tree);


			{
			// AST REWRITE
			// elements: typeSpec, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 136:3: -> ^( VAR_SPEC typeSpec identifier )
			{
				DebugLocation(136, 6);
				// Grammar\\SimpleC.g:136:6: ^( VAR_SPEC typeSpec identifier )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(136, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VAR_SPEC, "VAR_SPEC"), root_1);

				DebugLocation(136, 17);
				adaptor.AddChild(root_1, stream_typeSpec.NextTree());
				DebugLocation(136, 26);
				adaptor.AddChild(root_1, stream_identifier.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("varSpec", 10);
			LeaveRule("varSpec", 10);
			LeaveRule_varSpec();
		}
		DebugLocation(137, 0);
		} finally { DebugExitRule(GrammarFileName, "varSpec"); }
		return retval;

	}
	// $ANTLR end "varSpec"

	partial void EnterRule_typeSpec();
	partial void LeaveRule_typeSpec();

	// $ANTLR start "typeSpec"
	// Grammar\\SimpleC.g:139:1: typeSpec : (tn= Int |tn= Void ) -> ^( TYPE_SPEC ) ;
	[GrammarRule("typeSpec")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec()
	{
		EnterRule_typeSpec();
		EnterRule("typeSpec", 11);
		TraceIn("typeSpec", 11);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken tn = default(CommonToken);

		CommonTree tn_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Void=new RewriteRuleITokenStream(adaptor,"token Void");
		RewriteRuleITokenStream stream_Int=new RewriteRuleITokenStream(adaptor,"token Int");
		try { DebugEnterRule(GrammarFileName, "typeSpec");
		DebugLocation(139, 0);
		try
		{
			// Grammar\\SimpleC.g:139:9: ( (tn= Int |tn= Void ) -> ^( TYPE_SPEC ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:140:2: (tn= Int |tn= Void )
			{
			DebugLocation(140, 2);
			// Grammar\\SimpleC.g:140:2: (tn= Int |tn= Void )
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==Int))
			{
				alt8 = 1;
			}
			else if ((LA8_0==Void))
			{
				alt8 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:140:3: tn= Int
				{
				DebugLocation(140, 5);
				tn=(CommonToken)Match(input,Int,Follow._Int_in_typeSpec1249); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Int.Add(tn);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:140:12: tn= Void
				{
				DebugLocation(140, 14);
				tn=(CommonToken)Match(input,Void,Follow._Void_in_typeSpec1255); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Void.Add(tn);


				}
				break;

			}
			} finally { DebugExitSubRule(8); }



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 140:21: -> ^( TYPE_SPEC )
			{
				DebugLocation(140, 24);
				// Grammar\\SimpleC.g:140:24: ^( TYPE_SPEC )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(140, 26);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE_SPEC, "TYPE_SPEC"), root_1);

				DebugLocation(140, 36);
				adaptor.AddChild(root_1,  adaptor.BecomeRoot(new CommonToken(IDENT, tn.Text), adaptor.Nil()) );

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeSpec", 11);
			LeaveRule("typeSpec", 11);
			LeaveRule_typeSpec();
		}
		DebugLocation(141, 0);
		} finally { DebugExitRule(GrammarFileName, "typeSpec"); }
		return retval;

	}
	// $ANTLR end "typeSpec"

	partial void EnterRule_paramList();
	partial void LeaveRule_paramList();

	// $ANTLR start "paramList"
	// Grammar\\SimpleC.g:143:1: paramList : ( expr ( ',' expr )* )? -> ^( PARAM_LIST ( expr )* ) ;
	[GrammarRule("paramList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> paramList()
	{
		EnterRule_paramList();
		EnterRule("paramList", 12);
		TraceIn("paramList", 12);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal36 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr35 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr37 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal36_tree = default(CommonTree);
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "paramList");
		DebugLocation(143, 0);
		try
		{
			// Grammar\\SimpleC.g:143:10: ( ( expr ( ',' expr )* )? -> ^( PARAM_LIST ( expr )* ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:144:2: ( expr ( ',' expr )* )?
			{
			DebugLocation(144, 2);
			// Grammar\\SimpleC.g:144:2: ( expr ( ',' expr )* )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==ADD||LA10_0==BIT_AND||LA10_0==Identifier||LA10_0==Integer||LA10_0==MUL||LA10_0==SUB||LA10_0==SizeOf||(LA10_0>=61 && LA10_0<=62)||LA10_0==64||LA10_0==66||LA10_0==74))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:144:3: expr ( ',' expr )*
				{
				DebugLocation(144, 3);
				PushFollow(Follow._expr_in_paramList1274);
				expr35=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr35.Tree);
				DebugLocation(144, 8);
				// Grammar\\SimpleC.g:144:8: ( ',' expr )*
				try { DebugEnterSubRule(9);
				while (true)
				{
					int alt9=2;
					try { DebugEnterDecision(9, false);
					int LA9_0 = input.LA(1);

					if ((LA9_0==65))
					{
						alt9 = 1;
					}


					} finally { DebugExitDecision(9); }
					switch ( alt9 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammar\\SimpleC.g:144:9: ',' expr
						{
						DebugLocation(144, 9);
						char_literal36=(CommonToken)Match(input,65,Follow._65_in_paramList1277); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_65.Add(char_literal36);

						DebugLocation(144, 13);
						PushFollow(Follow._expr_in_paramList1279);
						expr37=expr();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expr.Add(expr37.Tree);

						}
						break;

					default:
						goto loop9;
					}
				}

				loop9:
					;

				} finally { DebugExitSubRule(9); }


				}
				break;

			}
			} finally { DebugExitSubRule(10); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 144:22: -> ^( PARAM_LIST ( expr )* )
			{
				DebugLocation(144, 25);
				// Grammar\\SimpleC.g:144:25: ^( PARAM_LIST ( expr )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(144, 27);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PARAM_LIST, "PARAM_LIST"), root_1);

				DebugLocation(144, 38);
				// Grammar\\SimpleC.g:144:38: ( expr )*
				while ( stream_expr.HasNext )
				{
					DebugLocation(144, 38);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("paramList", 12);
			LeaveRule("paramList", 12);
			LeaveRule_paramList();
		}
		DebugLocation(145, 0);
		} finally { DebugExitRule(GrammarFileName, "paramList"); }
		return retval;

	}
	// $ANTLR end "paramList"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// Grammar\\SimpleC.g:147:1: expr : binaryExpr ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 13);
		TraceIn("expr", 13);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> binaryExpr38 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(147, 0);
		try
		{
			// Grammar\\SimpleC.g:147:5: ( binaryExpr )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:148:2: binaryExpr
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(148, 2);
			PushFollow(Follow._binaryExpr_in_expr1301);
			binaryExpr38=binaryExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, binaryExpr38.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 13);
			LeaveRule("expr", 13);
			LeaveRule_expr();
		}
		DebugLocation(149, 0);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_binaryExpr();
	partial void LeaveRule_binaryExpr();

	// $ANTLR start "binaryExpr"
	// Grammar\\SimpleC.g:151:1: binaryExpr : left= unaryExpr (op= binaryOperator right= unaryExpr )* ->;
	[GrammarRule("binaryExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> binaryExpr()
	{
		EnterRule_binaryExpr();
		EnterRule("binaryExpr", 14);
		TraceIn("binaryExpr", 14);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> left = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> op = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> right = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		RewriteRuleSubtreeStream stream_unaryExpr=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpr");
		RewriteRuleSubtreeStream stream_binaryOperator=new RewriteRuleSubtreeStream(adaptor,"rule binaryOperator");

			List<ITree> expressions = new List<ITree>();
			List<IToken> operators = new List<IToken>();

		try { DebugEnterRule(GrammarFileName, "binaryExpr");
		DebugLocation(151, 0);
		try
		{
			// Grammar\\SimpleC.g:155:3: (left= unaryExpr (op= binaryOperator right= unaryExpr )* ->)
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:156:2: left= unaryExpr (op= binaryOperator right= unaryExpr )*
			{
			DebugLocation(156, 6);
			PushFollow(Follow._unaryExpr_in_binaryExpr1318);
			left=unaryExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_unaryExpr.Add(left.Tree);
			DebugLocation(156, 17);
			if (state.backtracking == 0)
			{
				 expressions.Add((ITree)left.Tree); 
			}
			DebugLocation(157, 2);
			// Grammar\\SimpleC.g:157:2: (op= binaryOperator right= unaryExpr )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if (((LA11_0>=ADD && LA11_0<=ASSIGN)||LA11_0==DIV||(LA11_0>=MOD && LA11_0<=MUL)||LA11_0==SUB))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:157:3: op= binaryOperator right= unaryExpr
					{
					DebugLocation(157, 5);
					PushFollow(Follow._binaryOperator_in_binaryExpr1326);
					op=binaryOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_binaryOperator.Add(op.Tree);
					DebugLocation(157, 26);
					PushFollow(Follow._unaryExpr_in_binaryExpr1330);
					right=unaryExpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_unaryExpr.Add(right.Tree);
					DebugLocation(157, 37);
					if (state.backtracking == 0)
					{

								operators.Add(((CommonTree)op.Tree).Token);
								expressions.Add((ITree)right.Tree);
							
					}

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 161:2: ->
			{
				DebugLocation(161, 5);
				adaptor.AddChild(root_0,  CreatePrecedenceTree(expressions, operators) );

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("binaryExpr", 14);
			LeaveRule("binaryExpr", 14);
			LeaveRule_binaryExpr();
		}
		DebugLocation(162, 0);
		} finally { DebugExitRule(GrammarFileName, "binaryExpr"); }
		return retval;

	}
	// $ANTLR end "binaryExpr"

	partial void EnterRule_unaryExpr();
	partial void LeaveRule_unaryExpr();

	// $ANTLR start "unaryExpr"
	// Grammar\\SimpleC.g:164:1: unaryExpr options {backtrack=true; } : ( '*' unaryExpr -> ^( DEREF unaryExpr ) | '&' unaryExpr -> ^( REF unaryExpr ) | '+' unaryExpr -> ^( U_PLUS unaryExpr ) | '-' unaryExpr -> ^( U_MINUS unaryExpr ) | '!' unaryExpr -> ^( BOOL_NOT unaryExpr ) | '~' unaryExpr -> ^( BIT_NOT unaryExpr ) | '++' unaryExpr -> ^( INC_PRE unaryExpr ) | '--' unaryExpr -> ^( DEC_PRE unaryExpr ) | '(' typeSpec ')' unaryExpr -> ^( TYPECAST unaryExpr typeSpec ) | SizeOf unaryExpr -> ^( SIZEOF_EXPR unaryExpr ) | SizeOf '(' typeSpec ')' -> ^( SIZEOF_TYPE typeSpec ) | primaryExpr );
	[GrammarRule("unaryExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr()
	{
		EnterRule_unaryExpr();
		EnterRule("unaryExpr", 15);
		TraceIn("unaryExpr", 15);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal39 = default(CommonToken);
		CommonToken char_literal41 = default(CommonToken);
		CommonToken char_literal43 = default(CommonToken);
		CommonToken char_literal45 = default(CommonToken);
		CommonToken char_literal47 = default(CommonToken);
		CommonToken char_literal49 = default(CommonToken);
		CommonToken string_literal51 = default(CommonToken);
		CommonToken string_literal53 = default(CommonToken);
		CommonToken char_literal55 = default(CommonToken);
		CommonToken char_literal57 = default(CommonToken);
		CommonToken SizeOf59 = default(CommonToken);
		CommonToken SizeOf61 = default(CommonToken);
		CommonToken char_literal62 = default(CommonToken);
		CommonToken char_literal64 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr40 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr42 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr44 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr46 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr48 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr50 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr52 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr54 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec56 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr58 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> unaryExpr60 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeSpec63 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> primaryExpr65 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal39_tree = default(CommonTree);
		CommonTree char_literal41_tree = default(CommonTree);
		CommonTree char_literal43_tree = default(CommonTree);
		CommonTree char_literal45_tree = default(CommonTree);
		CommonTree char_literal47_tree = default(CommonTree);
		CommonTree char_literal49_tree = default(CommonTree);
		CommonTree string_literal51_tree = default(CommonTree);
		CommonTree string_literal53_tree = default(CommonTree);
		CommonTree char_literal55_tree = default(CommonTree);
		CommonTree char_literal57_tree = default(CommonTree);
		CommonTree SizeOf59_tree = default(CommonTree);
		CommonTree SizeOf61_tree = default(CommonTree);
		CommonTree char_literal62_tree = default(CommonTree);
		CommonTree char_literal64_tree = default(CommonTree);
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_SUB=new RewriteRuleITokenStream(adaptor,"token SUB");
		RewriteRuleITokenStream stream_SizeOf=new RewriteRuleITokenStream(adaptor,"token SizeOf");
		RewriteRuleITokenStream stream_BIT_AND=new RewriteRuleITokenStream(adaptor,"token BIT_AND");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_MUL=new RewriteRuleITokenStream(adaptor,"token MUL");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_74=new RewriteRuleITokenStream(adaptor,"token 74");
		RewriteRuleITokenStream stream_61=new RewriteRuleITokenStream(adaptor,"token 61");
		RewriteRuleITokenStream stream_ADD=new RewriteRuleITokenStream(adaptor,"token ADD");
		RewriteRuleSubtreeStream stream_unaryExpr=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpr");
		RewriteRuleSubtreeStream stream_typeSpec=new RewriteRuleSubtreeStream(adaptor,"rule typeSpec");
		try { DebugEnterRule(GrammarFileName, "unaryExpr");
		DebugLocation(164, 0);
		try
		{
			// Grammar\\SimpleC.g:166:3: ( '*' unaryExpr -> ^( DEREF unaryExpr ) | '&' unaryExpr -> ^( REF unaryExpr ) | '+' unaryExpr -> ^( U_PLUS unaryExpr ) | '-' unaryExpr -> ^( U_MINUS unaryExpr ) | '!' unaryExpr -> ^( BOOL_NOT unaryExpr ) | '~' unaryExpr -> ^( BIT_NOT unaryExpr ) | '++' unaryExpr -> ^( INC_PRE unaryExpr ) | '--' unaryExpr -> ^( DEC_PRE unaryExpr ) | '(' typeSpec ')' unaryExpr -> ^( TYPECAST unaryExpr typeSpec ) | SizeOf unaryExpr -> ^( SIZEOF_EXPR unaryExpr ) | SizeOf '(' typeSpec ')' -> ^( SIZEOF_TYPE typeSpec ) | primaryExpr )
			int alt12=12;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case MUL:
				{
				alt12 = 1;
				}
				break;
			case BIT_AND:
				{
				alt12 = 2;
				}
				break;
			case ADD:
				{
				alt12 = 3;
				}
				break;
			case SUB:
				{
				alt12 = 4;
				}
				break;
			case 61:
				{
				alt12 = 5;
				}
				break;
			case 74:
				{
				alt12 = 6;
				}
				break;
			case 64:
				{
				alt12 = 7;
				}
				break;
			case 66:
				{
				alt12 = 8;
				}
				break;
			case 62:
				{
				int LA12_9 = input.LA(2);

				if ((EvaluatePredicate(synpred9_SimpleC_fragment)))
				{
					alt12 = 9;
				}
				else if ((true))
				{
					alt12 = 12;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 9, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case SizeOf:
				{
				int LA12_10 = input.LA(2);

				if ((EvaluatePredicate(synpred10_SimpleC_fragment)))
				{
					alt12 = 10;
				}
				else if ((EvaluatePredicate(synpred11_SimpleC_fragment)))
				{
					alt12 = 11;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 10, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Identifier:
			case Integer:
				{
				alt12 = 12;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:167:2: '*' unaryExpr
				{
				DebugLocation(167, 2);
				char_literal39=(CommonToken)Match(input,MUL,Follow._MUL_in_unaryExpr1359); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MUL.Add(char_literal39);

				DebugLocation(167, 6);
				PushFollow(Follow._unaryExpr_in_unaryExpr1361);
				unaryExpr40=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr40.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 167:16: -> ^( DEREF unaryExpr )
				{
					DebugLocation(167, 19);
					// Grammar\\SimpleC.g:167:19: ^( DEREF unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(167, 21);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DEREF, "DEREF"), root_1);

					DebugLocation(167, 27);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:168:4: '&' unaryExpr
				{
				DebugLocation(168, 4);
				char_literal41=(CommonToken)Match(input,BIT_AND,Follow._BIT_AND_in_unaryExpr1374); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BIT_AND.Add(char_literal41);

				DebugLocation(168, 8);
				PushFollow(Follow._unaryExpr_in_unaryExpr1376);
				unaryExpr42=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr42.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 168:18: -> ^( REF unaryExpr )
				{
					DebugLocation(168, 21);
					// Grammar\\SimpleC.g:168:21: ^( REF unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(168, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REF, "REF"), root_1);

					DebugLocation(168, 27);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleC.g:169:4: '+' unaryExpr
				{
				DebugLocation(169, 4);
				char_literal43=(CommonToken)Match(input,ADD,Follow._ADD_in_unaryExpr1389); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ADD.Add(char_literal43);

				DebugLocation(169, 8);
				PushFollow(Follow._unaryExpr_in_unaryExpr1391);
				unaryExpr44=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr44.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 169:18: -> ^( U_PLUS unaryExpr )
				{
					DebugLocation(169, 21);
					// Grammar\\SimpleC.g:169:21: ^( U_PLUS unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(169, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(U_PLUS, "U_PLUS"), root_1);

					DebugLocation(169, 30);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleC.g:170:4: '-' unaryExpr
				{
				DebugLocation(170, 4);
				char_literal45=(CommonToken)Match(input,SUB,Follow._SUB_in_unaryExpr1404); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SUB.Add(char_literal45);

				DebugLocation(170, 8);
				PushFollow(Follow._unaryExpr_in_unaryExpr1406);
				unaryExpr46=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr46.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 170:18: -> ^( U_MINUS unaryExpr )
				{
					DebugLocation(170, 21);
					// Grammar\\SimpleC.g:170:21: ^( U_MINUS unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(170, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(U_MINUS, "U_MINUS"), root_1);

					DebugLocation(170, 31);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammar\\SimpleC.g:171:4: '!' unaryExpr
				{
				DebugLocation(171, 4);
				char_literal47=(CommonToken)Match(input,61,Follow._61_in_unaryExpr1419); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_61.Add(char_literal47);

				DebugLocation(171, 8);
				PushFollow(Follow._unaryExpr_in_unaryExpr1421);
				unaryExpr48=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr48.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 171:18: -> ^( BOOL_NOT unaryExpr )
				{
					DebugLocation(171, 21);
					// Grammar\\SimpleC.g:171:21: ^( BOOL_NOT unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(171, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BOOL_NOT, "BOOL_NOT"), root_1);

					DebugLocation(171, 32);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammar\\SimpleC.g:172:4: '~' unaryExpr
				{
				DebugLocation(172, 4);
				char_literal49=(CommonToken)Match(input,74,Follow._74_in_unaryExpr1434); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_74.Add(char_literal49);

				DebugLocation(172, 8);
				PushFollow(Follow._unaryExpr_in_unaryExpr1436);
				unaryExpr50=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr50.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 172:18: -> ^( BIT_NOT unaryExpr )
				{
					DebugLocation(172, 21);
					// Grammar\\SimpleC.g:172:21: ^( BIT_NOT unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(172, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BIT_NOT, "BIT_NOT"), root_1);

					DebugLocation(172, 31);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammar\\SimpleC.g:173:4: '++' unaryExpr
				{
				DebugLocation(173, 4);
				string_literal51=(CommonToken)Match(input,64,Follow._64_in_unaryExpr1449); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(string_literal51);

				DebugLocation(173, 9);
				PushFollow(Follow._unaryExpr_in_unaryExpr1451);
				unaryExpr52=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr52.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 173:19: -> ^( INC_PRE unaryExpr )
				{
					DebugLocation(173, 22);
					// Grammar\\SimpleC.g:173:22: ^( INC_PRE unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(173, 24);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INC_PRE, "INC_PRE"), root_1);

					DebugLocation(173, 32);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammar\\SimpleC.g:174:4: '--' unaryExpr
				{
				DebugLocation(174, 4);
				string_literal53=(CommonToken)Match(input,66,Follow._66_in_unaryExpr1464); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_66.Add(string_literal53);

				DebugLocation(174, 9);
				PushFollow(Follow._unaryExpr_in_unaryExpr1466);
				unaryExpr54=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr54.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 174:19: -> ^( DEC_PRE unaryExpr )
				{
					DebugLocation(174, 22);
					// Grammar\\SimpleC.g:174:22: ^( DEC_PRE unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(174, 24);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DEC_PRE, "DEC_PRE"), root_1);

					DebugLocation(174, 32);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammar\\SimpleC.g:175:4: '(' typeSpec ')' unaryExpr
				{
				DebugLocation(175, 4);
				char_literal55=(CommonToken)Match(input,62,Follow._62_in_unaryExpr1479); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(char_literal55);

				DebugLocation(175, 8);
				PushFollow(Follow._typeSpec_in_unaryExpr1481);
				typeSpec56=typeSpec();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeSpec.Add(typeSpec56.Tree);
				DebugLocation(175, 17);
				char_literal57=(CommonToken)Match(input,63,Follow._63_in_unaryExpr1483); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal57);

				DebugLocation(175, 21);
				PushFollow(Follow._unaryExpr_in_unaryExpr1485);
				unaryExpr58=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr58.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr, typeSpec
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 175:31: -> ^( TYPECAST unaryExpr typeSpec )
				{
					DebugLocation(175, 34);
					// Grammar\\SimpleC.g:175:34: ^( TYPECAST unaryExpr typeSpec )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(175, 36);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPECAST, "TYPECAST"), root_1);

					DebugLocation(175, 45);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());
					DebugLocation(175, 55);
					adaptor.AddChild(root_1, stream_typeSpec.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Grammar\\SimpleC.g:176:4: SizeOf unaryExpr
				{
				DebugLocation(176, 4);
				SizeOf59=(CommonToken)Match(input,SizeOf,Follow._SizeOf_in_unaryExpr1500); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SizeOf.Add(SizeOf59);

				DebugLocation(176, 11);
				PushFollow(Follow._unaryExpr_in_unaryExpr1502);
				unaryExpr60=unaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpr.Add(unaryExpr60.Tree);


				{
				// AST REWRITE
				// elements: unaryExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 176:21: -> ^( SIZEOF_EXPR unaryExpr )
				{
					DebugLocation(176, 24);
					// Grammar\\SimpleC.g:176:24: ^( SIZEOF_EXPR unaryExpr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(176, 26);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SIZEOF_EXPR, "SIZEOF_EXPR"), root_1);

					DebugLocation(176, 38);
					adaptor.AddChild(root_1, stream_unaryExpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Grammar\\SimpleC.g:177:4: SizeOf '(' typeSpec ')'
				{
				DebugLocation(177, 4);
				SizeOf61=(CommonToken)Match(input,SizeOf,Follow._SizeOf_in_unaryExpr1515); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SizeOf.Add(SizeOf61);

				DebugLocation(177, 11);
				char_literal62=(CommonToken)Match(input,62,Follow._62_in_unaryExpr1517); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(char_literal62);

				DebugLocation(177, 15);
				PushFollow(Follow._typeSpec_in_unaryExpr1519);
				typeSpec63=typeSpec();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeSpec.Add(typeSpec63.Tree);
				DebugLocation(177, 24);
				char_literal64=(CommonToken)Match(input,63,Follow._63_in_unaryExpr1521); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal64);



				{
				// AST REWRITE
				// elements: typeSpec
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 177:28: -> ^( SIZEOF_TYPE typeSpec )
				{
					DebugLocation(177, 31);
					// Grammar\\SimpleC.g:177:31: ^( SIZEOF_TYPE typeSpec )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(177, 33);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SIZEOF_TYPE, "SIZEOF_TYPE"), root_1);

					DebugLocation(177, 45);
					adaptor.AddChild(root_1, stream_typeSpec.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Grammar\\SimpleC.g:178:4: primaryExpr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(178, 4);
				PushFollow(Follow._primaryExpr_in_unaryExpr1534);
				primaryExpr65=primaryExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, primaryExpr65.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpr", 15);
			LeaveRule("unaryExpr", 15);
			LeaveRule_unaryExpr();
		}
		DebugLocation(180, 0);
		} finally { DebugExitRule(GrammarFileName, "unaryExpr"); }
		return retval;

	}
	// $ANTLR end "unaryExpr"

	partial void EnterRule_primaryExpr();
	partial void LeaveRule_primaryExpr();

	// $ANTLR start "primaryExpr"
	// Grammar\\SimpleC.g:182:1: primaryExpr : basic= basicExpr ( '[' idx= expr ']' | '.' member= identifier | '->' member= identifier | '++' | '--' )* ->;
	[GrammarRule("primaryExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> primaryExpr()
	{
		EnterRule_primaryExpr();
		EnterRule("primaryExpr", 16);
		TraceIn("primaryExpr", 16);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal66 = default(CommonToken);
		CommonToken char_literal67 = default(CommonToken);
		CommonToken char_literal68 = default(CommonToken);
		CommonToken string_literal69 = default(CommonToken);
		CommonToken string_literal70 = default(CommonToken);
		CommonToken string_literal71 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> basic = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> idx = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> member = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal66_tree = default(CommonTree);
		CommonTree char_literal67_tree = default(CommonTree);
		CommonTree char_literal68_tree = default(CommonTree);
		CommonTree string_literal69_tree = default(CommonTree);
		CommonTree string_literal70_tree = default(CommonTree);
		CommonTree string_literal71_tree = default(CommonTree);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleSubtreeStream stream_basicExpr=new RewriteRuleSubtreeStream(adaptor,"rule basicExpr");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");

			List<ITree> expressions = new List<ITree>();
			List<IToken> operators = new List<IToken>();

		try { DebugEnterRule(GrammarFileName, "primaryExpr");
		DebugLocation(182, 0);
		try
		{
			// Grammar\\SimpleC.g:186:3: (basic= basicExpr ( '[' idx= expr ']' | '.' member= identifier | '->' member= identifier | '++' | '--' )* ->)
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:187:2: basic= basicExpr ( '[' idx= expr ']' | '.' member= identifier | '->' member= identifier | '++' | '--' )*
			{
			DebugLocation(187, 7);
			PushFollow(Follow._basicExpr_in_primaryExpr1552);
			basic=basicExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_basicExpr.Add(basic.Tree);
			DebugLocation(187, 18);
			if (state.backtracking == 0)
			{
				 
						expressions.Add((ITree)basic.Tree);
					
			}
			DebugLocation(190, 2);
			// Grammar\\SimpleC.g:190:2: ( '[' idx= expr ']' | '.' member= identifier | '->' member= identifier | '++' | '--' )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=6;
				try { DebugEnterDecision(13, false);
				switch (input.LA(1))
				{
				case 70:
					{
					alt13 = 1;
					}
					break;
				case 68:
					{
					alt13 = 2;
					}
					break;
				case 67:
					{
					alt13 = 3;
					}
					break;
				case 64:
					{
					alt13 = 4;
					}
					break;
				case 66:
					{
					alt13 = 5;
					}
					break;
				}

				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammar\\SimpleC.g:191:4: '[' idx= expr ']'
					{
					DebugLocation(191, 4);
					char_literal66=(CommonToken)Match(input,70,Follow._70_in_primaryExpr1562); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_70.Add(char_literal66);

					DebugLocation(191, 11);
					PushFollow(Follow._expr_in_primaryExpr1566);
					idx=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr.Add(idx.Tree);
					DebugLocation(191, 17);
					char_literal67=(CommonToken)Match(input,71,Follow._71_in_primaryExpr1568); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_71.Add(char_literal67);

					DebugLocation(191, 21);
					if (state.backtracking == 0)
					{
						 
										operators.Add(new CommonToken(SUBSCRIPT, tokenNames[SUBSCRIPT]));
										expressions.Add((ITree)idx.Tree);
									
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammar\\SimpleC.g:195:5: '.' member= identifier
					{
					DebugLocation(195, 5);
					char_literal68=(CommonToken)Match(input,68,Follow._68_in_primaryExpr1577); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_68.Add(char_literal68);

					DebugLocation(195, 15);
					PushFollow(Follow._identifier_in_primaryExpr1581);
					member=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(member.Tree);
					DebugLocation(195, 27);
					if (state.backtracking == 0)
					{

										operators.Add(new CommonToken(STRUCT_MEMBER, tokenNames[STRUCT_MEMBER]));
										expressions.Add((ITree)member.Tree);
									
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammar\\SimpleC.g:199:5: '->' member= identifier
					{
					DebugLocation(199, 5);
					string_literal69=(CommonToken)Match(input,67,Follow._67_in_primaryExpr1589); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_67.Add(string_literal69);

					DebugLocation(199, 16);
					PushFollow(Follow._identifier_in_primaryExpr1593);
					member=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(member.Tree);
					DebugLocation(199, 28);
					if (state.backtracking == 0)
					{

										operators.Add(new CommonToken(STRUCT_DEREF, tokenNames[STRUCT_DEREF]));
										expressions.Add((ITree)member.Tree);
									
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Grammar\\SimpleC.g:203:5: '++'
					{
					DebugLocation(203, 5);
					string_literal70=(CommonToken)Match(input,64,Follow._64_in_primaryExpr1601); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_64.Add(string_literal70);

					DebugLocation(203, 10);
					if (state.backtracking == 0)
					{
						 
										operators.Add(new CommonToken(INC_POST, tokenNames[INC_POST]));
										expressions.Add(null);
									
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Grammar\\SimpleC.g:207:5: '--'
					{
					DebugLocation(207, 5);
					string_literal71=(CommonToken)Match(input,66,Follow._66_in_primaryExpr1609); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_66.Add(string_literal71);

					DebugLocation(207, 10);
					if (state.backtracking == 0)
					{

										operators.Add(new CommonToken(DEC_POST, tokenNames[DEC_POST]));
										expressions.Add(null);
									
					}

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 211:5: ->
			{
				DebugLocation(211, 8);
				adaptor.AddChild(root_0,  CreatePrimaryPrecedenceTree(expressions, operators) );

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpr", 16);
			LeaveRule("primaryExpr", 16);
			LeaveRule_primaryExpr();
		}
		DebugLocation(212, 0);
		} finally { DebugExitRule(GrammarFileName, "primaryExpr"); }
		return retval;

	}
	// $ANTLR end "primaryExpr"

	partial void EnterRule_basicExpr();
	partial void LeaveRule_basicExpr();

	// $ANTLR start "basicExpr"
	// Grammar\\SimpleC.g:225:1: basicExpr : ( '(' ! expr ')' !| identifier | integer | funcCall );
	[GrammarRule("basicExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> basicExpr()
	{
		EnterRule_basicExpr();
		EnterRule("basicExpr", 17);
		TraceIn("basicExpr", 17);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal72 = default(CommonToken);
		CommonToken char_literal74 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr73 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> identifier75 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> integer76 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> funcCall77 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal72_tree = default(CommonTree);
		CommonTree char_literal74_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "basicExpr");
		DebugLocation(225, 0);
		try
		{
			// Grammar\\SimpleC.g:225:10: ( '(' ! expr ')' !| identifier | integer | funcCall )
			int alt14=4;
			try { DebugEnterDecision(14, false);
			switch (input.LA(1))
			{
			case 62:
				{
				alt14 = 1;
				}
				break;
			case Identifier:
				{
				int LA14_2 = input.LA(2);

				if ((LA14_2==EOF||(LA14_2>=ADD && LA14_2<=ASSIGN)||LA14_2==DIV||(LA14_2>=MOD && LA14_2<=MUL)||LA14_2==SUB||(LA14_2>=63 && LA14_2<=71)))
				{
					alt14 = 2;
				}
				else if ((LA14_2==62))
				{
					alt14 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 14, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Integer:
				{
				alt14 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammar\\SimpleC.g:226:2: '(' ! expr ')' !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(226, 5);
				char_literal72=(CommonToken)Match(input,62,Follow._62_in_basicExpr1631); if (state.failed) return retval;
				DebugLocation(226, 7);
				PushFollow(Follow._expr_in_basicExpr1634);
				expr73=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expr73.Tree);
				DebugLocation(226, 15);
				char_literal74=(CommonToken)Match(input,63,Follow._63_in_basicExpr1636); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammar\\SimpleC.g:227:4: identifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(227, 4);
				PushFollow(Follow._identifier_in_basicExpr1642);
				identifier75=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier75.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammar\\SimpleC.g:228:4: integer
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(228, 4);
				PushFollow(Follow._integer_in_basicExpr1648);
				integer76=integer();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, integer76.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammar\\SimpleC.g:229:4: funcCall
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(229, 4);
				PushFollow(Follow._funcCall_in_basicExpr1654);
				funcCall77=funcCall();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcCall77.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("basicExpr", 17);
			LeaveRule("basicExpr", 17);
			LeaveRule_basicExpr();
		}
		DebugLocation(230, 0);
		} finally { DebugExitRule(GrammarFileName, "basicExpr"); }
		return retval;

	}
	// $ANTLR end "basicExpr"

	partial void EnterRule_funcCall();
	partial void LeaveRule_funcCall();

	// $ANTLR start "funcCall"
	// Grammar\\SimpleC.g:232:1: funcCall : identifier '(' paramList ')' -> ^( FUNC_CALL identifier paramList ) ;
	[GrammarRule("funcCall")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> funcCall()
	{
		EnterRule_funcCall();
		EnterRule("funcCall", 18);
		TraceIn("funcCall", 18);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal79 = default(CommonToken);
		CommonToken char_literal81 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> identifier78 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> paramList80 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal79_tree = default(CommonTree);
		CommonTree char_literal81_tree = default(CommonTree);
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_paramList=new RewriteRuleSubtreeStream(adaptor,"rule paramList");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "funcCall");
		DebugLocation(232, 0);
		try
		{
			// Grammar\\SimpleC.g:232:9: ( identifier '(' paramList ')' -> ^( FUNC_CALL identifier paramList ) )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:233:2: identifier '(' paramList ')'
			{
			DebugLocation(233, 2);
			PushFollow(Follow._identifier_in_funcCall1663);
			identifier78=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier78.Tree);
			DebugLocation(233, 13);
			char_literal79=(CommonToken)Match(input,62,Follow._62_in_funcCall1665); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal79);

			DebugLocation(233, 17);
			PushFollow(Follow._paramList_in_funcCall1667);
			paramList80=paramList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_paramList.Add(paramList80.Tree);
			DebugLocation(233, 27);
			char_literal81=(CommonToken)Match(input,63,Follow._63_in_funcCall1669); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal81);



			{
			// AST REWRITE
			// elements: paramList, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 233:31: -> ^( FUNC_CALL identifier paramList )
			{
				DebugLocation(233, 34);
				// Grammar\\SimpleC.g:233:34: ^( FUNC_CALL identifier paramList )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(233, 36);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC_CALL, "FUNC_CALL"), root_1);

				DebugLocation(233, 46);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(233, 57);
				adaptor.AddChild(root_1, stream_paramList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcCall", 18);
			LeaveRule("funcCall", 18);
			LeaveRule_funcCall();
		}
		DebugLocation(234, 0);
		} finally { DebugExitRule(GrammarFileName, "funcCall"); }
		return retval;

	}
	// $ANTLR end "funcCall"

	partial void EnterRule_binaryOperator();
	partial void LeaveRule_binaryOperator();

	// $ANTLR start "binaryOperator"
	// Grammar\\SimpleC.g:236:1: binaryOperator : ( ADD | SUB | MUL | DIV | MOD | ASSIGN );
	[GrammarRule("binaryOperator")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> binaryOperator()
	{
		EnterRule_binaryOperator();
		EnterRule("binaryOperator", 19);
		TraceIn("binaryOperator", 19);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set82 = default(CommonToken);

		CommonTree set82_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "binaryOperator");
		DebugLocation(236, 0);
		try
		{
			// Grammar\\SimpleC.g:236:15: ( ADD | SUB | MUL | DIV | MOD | ASSIGN )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(236, 15);

			set82=(CommonToken)input.LT(1);
			if ((input.LA(1)>=ADD && input.LA(1)<=ASSIGN)||input.LA(1)==DIV||(input.LA(1)>=MOD && input.LA(1)<=MUL)||input.LA(1)==SUB)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set82));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("binaryOperator", 19);
			LeaveRule("binaryOperator", 19);
			LeaveRule_binaryOperator();
		}
		DebugLocation(256, 0);
		} finally { DebugExitRule(GrammarFileName, "binaryOperator"); }
		return retval;

	}
	// $ANTLR end "binaryOperator"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();

	// $ANTLR start "identifier"
	// Grammar\\SimpleC.g:259:1: identifier : Identifier ->;
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 20);
		TraceIn("identifier", 20);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken Identifier83 = default(CommonToken);

		CommonTree Identifier83_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(259, 0);
		try
		{
			// Grammar\\SimpleC.g:259:11: ( Identifier ->)
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:260:2: Identifier
			{
			DebugLocation(260, 2);
			Identifier83=(CommonToken)Match(input,Identifier,Follow._Identifier_in_identifier1736); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier83);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 260:13: ->
			{
				DebugLocation(260, 16);
				adaptor.AddChild(root_0,  
						adaptor.BecomeRoot(new CommonToken(IDENT, Identifier83.Text), adaptor.Nil()) 
					);

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 20);
			LeaveRule("identifier", 20);
			LeaveRule_identifier();
		}
		DebugLocation(263, 0);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_integer();
	partial void LeaveRule_integer();

	// $ANTLR start "integer"
	// Grammar\\SimpleC.g:265:1: integer : Integer ->;
	[GrammarRule("integer")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> integer()
	{
		EnterRule_integer();
		EnterRule("integer", 21);
		TraceIn("integer", 21);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken Integer84 = default(CommonToken);

		CommonTree Integer84_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Integer=new RewriteRuleITokenStream(adaptor,"token Integer");
		try { DebugEnterRule(GrammarFileName, "integer");
		DebugLocation(265, 0);
		try
		{
			// Grammar\\SimpleC.g:265:8: ( Integer ->)
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:266:2: Integer
			{
			DebugLocation(266, 2);
			Integer84=(CommonToken)Match(input,Integer,Follow._Integer_in_integer1749); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Integer.Add(Integer84);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 266:10: ->
			{
				DebugLocation(266, 13);
				adaptor.AddChild(root_0, 
						adaptor.BecomeRoot(new CommonToken(INTEGER, Integer84.Text), adaptor.Nil()) 
					);

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("integer", 21);
			LeaveRule("integer", 21);
			LeaveRule_integer();
		}
		DebugLocation(269, 0);
		} finally { DebugExitRule(GrammarFileName, "integer"); }
		return retval;

	}
	// $ANTLR end "integer"

	partial void EnterRule_synpred9_SimpleC_fragment();
	partial void LeaveRule_synpred9_SimpleC_fragment();

	// $ANTLR start synpred9_SimpleC
	public void synpred9_SimpleC_fragment()
	{
		EnterRule_synpred9_SimpleC_fragment();
		EnterRule("synpred9_SimpleC_fragment", 30);
		TraceIn("synpred9_SimpleC_fragment", 30);
		try
		{
			// Grammar\\SimpleC.g:175:4: ( '(' typeSpec ')' unaryExpr )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:175:4: '(' typeSpec ')' unaryExpr
			{
			DebugLocation(175, 4);
			Match(input,62,Follow._62_in_synpred9_SimpleC1479); if (state.failed) return;
			DebugLocation(175, 8);
			PushFollow(Follow._typeSpec_in_synpred9_SimpleC1481);
			typeSpec();
			PopFollow();
			if (state.failed) return;
			DebugLocation(175, 17);
			Match(input,63,Follow._63_in_synpred9_SimpleC1483); if (state.failed) return;
			DebugLocation(175, 21);
			PushFollow(Follow._unaryExpr_in_synpred9_SimpleC1485);
			unaryExpr();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_SimpleC_fragment", 30);
			LeaveRule("synpred9_SimpleC_fragment", 30);
			LeaveRule_synpred9_SimpleC_fragment();
		}
	}
	// $ANTLR end synpred9_SimpleC

	partial void EnterRule_synpred10_SimpleC_fragment();
	partial void LeaveRule_synpred10_SimpleC_fragment();

	// $ANTLR start synpred10_SimpleC
	public void synpred10_SimpleC_fragment()
	{
		EnterRule_synpred10_SimpleC_fragment();
		EnterRule("synpred10_SimpleC_fragment", 31);
		TraceIn("synpred10_SimpleC_fragment", 31);
		try
		{
			// Grammar\\SimpleC.g:176:4: ( SizeOf unaryExpr )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:176:4: SizeOf unaryExpr
			{
			DebugLocation(176, 4);
			Match(input,SizeOf,Follow._SizeOf_in_synpred10_SimpleC1500); if (state.failed) return;
			DebugLocation(176, 11);
			PushFollow(Follow._unaryExpr_in_synpred10_SimpleC1502);
			unaryExpr();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred10_SimpleC_fragment", 31);
			LeaveRule("synpred10_SimpleC_fragment", 31);
			LeaveRule_synpred10_SimpleC_fragment();
		}
	}
	// $ANTLR end synpred10_SimpleC

	partial void EnterRule_synpred11_SimpleC_fragment();
	partial void LeaveRule_synpred11_SimpleC_fragment();

	// $ANTLR start synpred11_SimpleC
	public void synpred11_SimpleC_fragment()
	{
		EnterRule_synpred11_SimpleC_fragment();
		EnterRule("synpred11_SimpleC_fragment", 32);
		TraceIn("synpred11_SimpleC_fragment", 32);
		try
		{
			// Grammar\\SimpleC.g:177:4: ( SizeOf '(' typeSpec ')' )
			DebugEnterAlt(1);
			// Grammar\\SimpleC.g:177:4: SizeOf '(' typeSpec ')'
			{
			DebugLocation(177, 4);
			Match(input,SizeOf,Follow._SizeOf_in_synpred11_SimpleC1515); if (state.failed) return;
			DebugLocation(177, 11);
			Match(input,62,Follow._62_in_synpred11_SimpleC1517); if (state.failed) return;
			DebugLocation(177, 15);
			PushFollow(Follow._typeSpec_in_synpred11_SimpleC1519);
			typeSpec();
			PopFollow();
			if (state.failed) return;
			DebugLocation(177, 24);
			Match(input,63,Follow._63_in_synpred11_SimpleC1521); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred11_SimpleC_fragment", 32);
			LeaveRule("synpred11_SimpleC_fragment", 32);
			LeaveRule_synpred11_SimpleC_fragment();
		}
	}
	// $ANTLR end synpred11_SimpleC
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA2 dfa2;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa2 = new DFA2( this );
	}

	private class DFA2 : DFA
	{
		private const string DFA2_eotS =
			"\x10\xFFFF";
		private const string DFA2_eofS =
			"\x10\xFFFF";
		private const string DFA2_minS =
			"\x1\x1E\x2\x1D\x1\x3E\x1\xFFFF\x1\x1E\x2\x1D\x1\x45\x1\x3F\x2\xFFFF\x1"+
			"\x1E\x2\x1D\x1\x3F";
		private const string DFA2_maxS =
			"\x1\x3B\x2\x1D\x1\x45\x1\xFFFF\x1\x3F\x2\x1D\x1\x48\x1\x41\x2\xFFFF\x1"+
			"\x3B\x2\x1D\x1\x41";
		private const string DFA2_acceptS =
			"\x4\xFFFF\x1\x1\x5\xFFFF\x1\x2\x1\x3\x4\xFFFF";
		private const string DFA2_specialS =
			"\x10\xFFFF}>";
		private static readonly string[] DFA2_transitionS =
			{
				"\x1\x1\x1C\xFFFF\x1\x2",
				"\x1\x3",
				"\x1\x3",
				"\x1\x5\x6\xFFFF\x1\x4",
				"",
				"\x1\x6\x1C\xFFFF\x1\x7\x3\xFFFF\x1\x8",
				"\x1\x9",
				"\x1\x9",
				"\x1\xA\x2\xFFFF\x1\xB",
				"\x1\x8\x1\xFFFF\x1\xC",
				"",
				"",
				"\x1\xD\x1C\xFFFF\x1\xE",
				"\x1\xF",
				"\x1\xF",
				"\x1\x8\x1\xFFFF\x1\xC"
			};

		private static readonly short[] DFA2_eot = DFA.UnpackEncodedString(DFA2_eotS);
		private static readonly short[] DFA2_eof = DFA.UnpackEncodedString(DFA2_eofS);
		private static readonly char[] DFA2_min = DFA.UnpackEncodedStringToUnsignedChars(DFA2_minS);
		private static readonly char[] DFA2_max = DFA.UnpackEncodedStringToUnsignedChars(DFA2_maxS);
		private static readonly short[] DFA2_accept = DFA.UnpackEncodedString(DFA2_acceptS);
		private static readonly short[] DFA2_special = DFA.UnpackEncodedString(DFA2_specialS);
		private static readonly short[][] DFA2_transition;

		static DFA2()
		{
			int numStates = DFA2_transitionS.Length;
			DFA2_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA2_transition[i] = DFA.UnpackEncodedString(DFA2_transitionS[i]);
			}
		}

		public DFA2( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 2;
			this.eot = DFA2_eot;
			this.eof = DFA2_eof;
			this.min = DFA2_min;
			this.max = DFA2_max;
			this.accept = DFA2_accept;
			this.special = DFA2_special;
			this.transition = DFA2_transition;
		}

		public override string Description { get { return "97:1: programStatement : ( varDef | funcDecl | funcDef );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _programStatement_in_program987 = new BitSet(new ulong[]{0x800000040000000UL});
		public static readonly BitSet _EOF_in_program990 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varDef_in_programStatement1009 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcDecl_in_programStatement1013 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcDef_in_programStatement1017 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varSpec_in_varDef1026 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _69_in_varDef1028 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeSpec_in_funcDecl1048 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _identifier_in_funcDecl1050 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_funcDecl1052 = new BitSet(new ulong[]{0x8800000040000000UL});
		public static readonly BitSet _paramSpecList_in_funcDecl1054 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_funcDecl1056 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _69_in_funcDecl1057 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeSpec_in_funcDef1081 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _identifier_in_funcDef1083 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_funcDef1085 = new BitSet(new ulong[]{0x8800000040000000UL});
		public static readonly BitSet _paramSpecList_in_funcDef1087 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_funcDef1089 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _72_in_funcDef1090 = new BitSet(new ulong[]{0x68050008E0000050UL,0x525UL});
		public static readonly BitSet _funcBody_in_funcDef1092 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _73_in_funcDef1094 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varSpec_in_paramSpecList1121 = new BitSet(new ulong[]{0x2UL,0x2UL});
		public static readonly BitSet _65_in_paramSpecList1124 = new BitSet(new ulong[]{0x800000040000000UL});
		public static readonly BitSet _varSpec_in_paramSpecList1126 = new BitSet(new ulong[]{0x2UL,0x2UL});
		public static readonly BitSet _statements_in_funcBody1148 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_statements1166 = new BitSet(new ulong[]{0x68050008E0000052UL,0x525UL});
		public static readonly BitSet _varDef_in_statement1176 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_statement1181 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _69_in_statement1184 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _72_in_statement1198 = new BitSet(new ulong[]{0x68050008E0000050UL,0x725UL});
		public static readonly BitSet _statements_in_statement1200 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _73_in_statement1202 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeSpec_in_varSpec1223 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _identifier_in_varSpec1225 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Int_in_typeSpec1249 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Void_in_typeSpec1255 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_paramList1274 = new BitSet(new ulong[]{0x2UL,0x2UL});
		public static readonly BitSet _65_in_paramList1277 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _expr_in_paramList1279 = new BitSet(new ulong[]{0x2UL,0x2UL});
		public static readonly BitSet _binaryExpr_in_expr1301 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpr_in_binaryExpr1318 = new BitSet(new ulong[]{0x1000C00010032UL});
		public static readonly BitSet _binaryOperator_in_binaryExpr1326 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_binaryExpr1330 = new BitSet(new ulong[]{0x1000C00010032UL});
		public static readonly BitSet _MUL_in_unaryExpr1359 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1361 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BIT_AND_in_unaryExpr1374 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1376 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ADD_in_unaryExpr1389 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1391 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUB_in_unaryExpr1404 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1406 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _61_in_unaryExpr1419 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1421 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _74_in_unaryExpr1434 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1436 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _64_in_unaryExpr1449 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _66_in_unaryExpr1464 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1466 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _62_in_unaryExpr1479 = new BitSet(new ulong[]{0x800000040000000UL});
		public static readonly BitSet _typeSpec_in_unaryExpr1481 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_unaryExpr1483 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SizeOf_in_unaryExpr1500 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_unaryExpr1502 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SizeOf_in_unaryExpr1515 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_unaryExpr1517 = new BitSet(new ulong[]{0x800000040000000UL});
		public static readonly BitSet _typeSpec_in_unaryExpr1519 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_unaryExpr1521 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpr_in_unaryExpr1534 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _basicExpr_in_primaryExpr1552 = new BitSet(new ulong[]{0x2UL,0x5DUL});
		public static readonly BitSet _70_in_primaryExpr1562 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _expr_in_primaryExpr1566 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_primaryExpr1568 = new BitSet(new ulong[]{0x2UL,0x5DUL});
		public static readonly BitSet _68_in_primaryExpr1577 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _identifier_in_primaryExpr1581 = new BitSet(new ulong[]{0x2UL,0x5DUL});
		public static readonly BitSet _67_in_primaryExpr1589 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _identifier_in_primaryExpr1593 = new BitSet(new ulong[]{0x2UL,0x5DUL});
		public static readonly BitSet _64_in_primaryExpr1601 = new BitSet(new ulong[]{0x2UL,0x5DUL});
		public static readonly BitSet _66_in_primaryExpr1609 = new BitSet(new ulong[]{0x2UL,0x5DUL});
		public static readonly BitSet _62_in_basicExpr1631 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _expr_in_basicExpr1634 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_basicExpr1636 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_basicExpr1642 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _integer_in_basicExpr1648 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcCall_in_basicExpr1654 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_funcCall1663 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_funcCall1665 = new BitSet(new ulong[]{0xE0050008A0000050UL,0x405UL});
		public static readonly BitSet _paramList_in_funcCall1667 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_funcCall1669 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_identifier1736 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Integer_in_integer1749 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _62_in_synpred9_SimpleC1479 = new BitSet(new ulong[]{0x800000040000000UL});
		public static readonly BitSet _typeSpec_in_synpred9_SimpleC1481 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_synpred9_SimpleC1483 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_synpred9_SimpleC1485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SizeOf_in_synpred10_SimpleC1500 = new BitSet(new ulong[]{0x60050008A0000050UL,0x405UL});
		public static readonly BitSet _unaryExpr_in_synpred10_SimpleC1502 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SizeOf_in_synpred11_SimpleC1515 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_synpred11_SimpleC1517 = new BitSet(new ulong[]{0x800000040000000UL});
		public static readonly BitSet _typeSpec_in_synpred11_SimpleC1519 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_synpred11_SimpleC1521 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  SimpleC.Grammar 
